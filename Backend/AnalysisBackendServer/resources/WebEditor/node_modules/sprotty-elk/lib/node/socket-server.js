"use strict";
/********************************************************************************
 * Copyright (c) 2022 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketElkServer = void 0;
const net_1 = require("net");
const layout_data_1 = require("./layout-data");
const DEFAULT_PORT = 5008;
const DEFAULT_TIMEOUT = 10000;
/**
 * Use this together with the `ElkLayoutEngine` to connect to a Java process via socket:
 * ```
 * const elkFactory: ElkFactory = () => new SocketElkServer();
 * ```
 * The `elk-server` application can be obtained here:
 * https://github.com/TypeFox/elk-server
 */
class SocketElkServer {
    constructor(options = {}) {
        var _a, _b, _c;
        const envPort = process.env.SERVER_PORT ? parseInt(process.env.SERVER_PORT, 10) : undefined;
        this.port = (_b = (_a = options.port) !== null && _a !== void 0 ? _a : envPort) !== null && _b !== void 0 ? _b : DEFAULT_PORT;
        this.timeoutDelay = (_c = options.timeoutDelay) !== null && _c !== void 0 ? _c : DEFAULT_TIMEOUT;
    }
    async layout(graph) {
        const socket = await this.createSocket();
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error(`Timeout of ${this.timeoutDelay} ms elapsed while waiting for layout server.`)), this.timeoutDelay);
            const closeCallback = () => {
                clearTimeout(timeout);
                this.socket = undefined;
                reject(new Error('The layout server socket was closed.'));
            };
            socket.on('close', closeCallback);
            // Send the input graph to the layout server
            socket.write(JSON.stringify(graph));
            // Wait for complete result
            const buffers = [];
            const parseState = { objLevel: 0 };
            const dataCallback = (chunk) => {
                buffers.push(chunk);
                (0, layout_data_1.findObjectEnd)(chunk, parseState);
                if (parseState.objLevel === 0) {
                    clearTimeout(timeout);
                    socket.removeListener('close', closeCallback);
                    socket.removeListener('data', dataCallback);
                    try {
                        const response = JSON.parse(Buffer.concat(buffers).toString());
                        if ((0, layout_data_1.isError)(response)) {
                            // The layout server responded an error
                            reject(response);
                        }
                        else {
                            (0, layout_data_1.applyLayoutData)(response, graph);
                            resolve(graph);
                        }
                    }
                    catch (err) {
                        reject(err);
                    }
                }
            };
            socket.on('data', dataCallback);
        });
    }
    createSocket() {
        if (this.socket && !this.socket.destroyed) {
            return Promise.resolve(this.socket);
        }
        return new Promise((resolve, reject) => {
            const socket = new net_1.Socket();
            socket.on('error', err => {
                this.socket = undefined;
                reject(err);
            });
            socket.connect(this.port, "127.0.0.1");
            this.socket = socket;
            socket.on('ready', () => resolve(socket));
        });
    }
    knownLayoutAlgorithms() {
        throw new Error('Method not implemented.');
    }
    knownLayoutOptions() {
        throw new Error('Method not implemented.');
    }
    knownLayoutCategories() {
        throw new Error('Method not implemented.');
    }
}
exports.SocketElkServer = SocketElkServer;
//# sourceMappingURL=socket-server.js.map