"use strict";
/********************************************************************************
 * Copyright (c) 2022 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.StdioElkServer = void 0;
const child_process_1 = require("child_process");
const layout_data_1 = require("./layout-data");
const DEFAULT_TIMEOUT = 10000;
/**
 * Use this together with the `ElkLayoutEngine` to spawn a Java process in the background:
 * ```
 * const elkFactory: ElkFactory = () => new StdioElkServer({ commandPath: './elk-server/bin/elk-server' });
 * ```
 * The `elk-server` application can be obtained here:
 * https://github.com/TypeFox/elk-server
 */
class StdioElkServer {
    constructor(options) {
        var _a;
        this.commandPath = options.commandPath;
        this.timeoutDelay = (_a = options.timeoutDelay) !== null && _a !== void 0 ? _a : DEFAULT_TIMEOUT;
        process.on('exit', () => {
            if (this.process) {
                this.process.kill();
            }
        });
    }
    async layout(graph) {
        const process = await this.createProcess();
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error(`Timeout of ${this.timeoutDelay} ms elapsed while waiting for layout server.`)), this.timeoutDelay);
            const exitCallback = () => {
                clearTimeout(timeout);
                this.process = undefined;
                reject(new Error('The layout server process terminated.'));
            };
            process.on('exit', exitCallback);
            if (!process.stdin || !process.stdout) {
                reject('The layout server process is not available.');
                return;
            }
            process.stdin.on('error', reject);
            // Send the input graph to the layout server
            process.stdin.write(JSON.stringify(graph));
            // Wait for complete result
            const buffers = [];
            const parseState = { objLevel: 0 };
            const dataCallback = (chunk) => {
                var _a, _b;
                buffers.push(chunk);
                (0, layout_data_1.findObjectEnd)(chunk, parseState);
                if (parseState.objLevel === 0) {
                    clearTimeout(timeout);
                    process.removeListener('exit', exitCallback);
                    (_a = process.stdout) === null || _a === void 0 ? void 0 : _a.removeListener('data', dataCallback);
                    (_b = process.stdin) === null || _b === void 0 ? void 0 : _b.removeListener('error', reject);
                    try {
                        const response = JSON.parse(Buffer.concat(buffers).toString());
                        if ((0, layout_data_1.isError)(response)) {
                            // The layout server responded an error
                            reject(response);
                        }
                        else {
                            this.applyLayout(response, graph);
                            resolve(graph);
                        }
                    }
                    catch (err) {
                        reject(err);
                    }
                }
            };
            process.stdout.on('data', dataCallback);
        });
    }
    applyLayout(data, graph) {
        (0, layout_data_1.applyLayoutData)(data, graph);
    }
    createProcess() {
        if (this.process && !this.process.killed) {
            return Promise.resolve(this.process);
        }
        return new Promise((resolve, reject) => {
            const process = (0, child_process_1.spawn)(this.commandPath, ['--stdio']);
            process.on('error', reject);
            process.stderr.on('data', data => console.error(data.toString()));
            this.process = process;
            setImmediate(() => resolve(process));
        });
    }
    knownLayoutAlgorithms() {
        throw new Error('Method not implemented.');
    }
    knownLayoutOptions() {
        throw new Error('Method not implemented.');
    }
    knownLayoutCategories() {
        throw new Error('Method not implemented.');
    }
}
exports.StdioElkServer = StdioElkServer;
//# sourceMappingURL=stdio-server.js.map