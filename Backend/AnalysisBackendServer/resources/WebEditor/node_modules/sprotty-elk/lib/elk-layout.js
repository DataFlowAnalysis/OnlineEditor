"use strict";
/********************************************************************************
 * Copyright (c) 2018-2022 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultLayoutConfigurator = exports.DefaultElementFilter = exports.ElkLayoutEngine = void 0;
const model_utils_1 = require("sprotty-protocol/lib/utils/model-utils");
/**
 * Layout engine that delegates to ELK by transforming the Sprotty graph into an ELK graph.
 *
 * This layout engine requires that the _basic type_ of every model element conforms to the
 * convention: `graph` for the top-level element, `node` for nodes, `edge` for edges, `label`
 * for labels, and `port` for ports. The basic type is either the value of the `type` property
 * or the substring preceding the separator `:` if present. Example: `'node:state'` is
 * interpreted as a node, while `'edge:transition'` is interpreted as an edge.
 */
class ElkLayoutEngine {
    constructor(elkFactory, filter = new DefaultElementFilter(), configurator = new DefaultLayoutConfigurator(), preprocessor, postprocessor) {
        this.filter = filter;
        this.configurator = configurator;
        this.preprocessor = preprocessor;
        this.postprocessor = postprocessor;
        this.elk = elkFactory();
    }
    /**
     * Transform the Sprotty graph into an ELK graph, invoke the ELK layout engine,
     * apply the results to the original graph, and return it.
     *
     * _Note:_ The basic type of the root element must be `graph`.
     */
    layout(sgraph, index) {
        if (this.getBasicType(sgraph) !== 'graph') {
            return sgraph;
        }
        if (!index) {
            index = new model_utils_1.SModelIndex();
            index.add(sgraph);
        }
        // STEP 1: Transform the Sprotty graph into an ELK graph with optional pre-processing
        const elkGraph = this.transformGraph(sgraph, index);
        if (this.preprocessor) {
            this.preprocessor.preprocess(elkGraph, sgraph, index);
        }
        // STEP 2: Invoke the ELK layout engine
        return this.elk.layout(elkGraph).then(result => {
            // STEP 3: Apply the results with optional post-processing to the original graph
            if (this.postprocessor) {
                this.postprocessor.postprocess(result, sgraph, index);
            }
            this.applyLayout(result, index);
            return sgraph;
        });
    }
    /**
     * Determine the _basic type_ of the given model element. The layout engine supports
     * the following values: `graph`, `node`, `edge`, `label`, `port` and `compartment`
     */
    getBasicType(smodel) {
        return (0, model_utils_1.getBasicType)(smodel);
    }
    /**
     * Transform a Sprotty graph element to an ELK graph element.
     */
    transformGraph(sgraph, index) {
        const elkGraph = {
            id: sgraph.id,
            layoutOptions: this.configurator.apply(sgraph, index)
        };
        if (sgraph.children) {
            elkGraph.children = sgraph.children
                .filter(c => this.getBasicType(c) === 'node' && this.filter.apply(c, index))
                .map(c => this.transformNode(c, index));
            elkGraph.edges = sgraph.children
                .filter(c => this.getBasicType(c) === 'edge' && this.filter.apply(c, index))
                .map(c => this.transformEdge(c, index));
        }
        return elkGraph;
    }
    /**
     * Transform a Sprotty node element to an ELK node element.
     */
    transformNode(snode, index) {
        var _a, _b;
        var _c;
        const elkNode = {
            id: snode.id,
            layoutOptions: this.configurator.apply(snode, index)
        };
        if (snode.children) {
            const padding = { top: 0, right: 0, bottom: 0, left: 0 };
            elkNode.children = this.transformCompartment(snode, index, padding);
            if (padding.top !== 0 || padding.right !== 0 || padding.bottom !== 0 || padding.left !== 0) {
                (_a = elkNode.layoutOptions) !== null && _a !== void 0 ? _a : (elkNode.layoutOptions = {});
                (_b = (_c = elkNode.layoutOptions)['org.eclipse.elk.padding']) !== null && _b !== void 0 ? _b : (_c['org.eclipse.elk.padding'] = `[top=${padding.top},left=${padding.left},bottom=${padding.bottom},right=${padding.right}]`);
            }
            elkNode.edges = snode.children
                .filter(c => this.getBasicType(c) === 'edge' && this.filter.apply(c, index))
                .map(c => this.transformEdge(c, index));
            elkNode.labels = snode.children
                .filter(c => this.getBasicType(c) === 'label' && this.filter.apply(c, index))
                .map(c => this.transformLabel(c, index));
            elkNode.ports = snode.children
                .filter(c => this.getBasicType(c) === 'port' && this.filter.apply(c, index))
                .map(c => this.transformPort(c, index));
        }
        this.transformShape(elkNode, snode);
        return elkNode;
    }
    transformCompartment(scomp, index, padding) {
        if (!scomp.children) {
            return undefined;
        }
        const nodes = scomp.children.filter(c => this.getBasicType(c) === 'node' && this.filter.apply(c, index));
        if (nodes.length > 0) {
            return nodes.map(c => this.transformNode(c, index));
        }
        for (const c of scomp.children) {
            if (this.getBasicType(c) === 'compartment' && this.filter.apply(c, index)) {
                const ccomp = c;
                if (scomp.layout) {
                    if (ccomp.position) {
                        padding.left += ccomp.position.x;
                        padding.top += ccomp.position.y;
                    }
                    if (ccomp.size && scomp.size) {
                        padding.right += scomp.size.width - ccomp.size.width - (ccomp.position ? ccomp.position.x : 0);
                        padding.bottom += scomp.size.height - ccomp.size.height - (ccomp.position ? ccomp.position.y : 0);
                    }
                }
                const childNodes = this.transformCompartment(ccomp, index, padding);
                if (childNodes) {
                    return childNodes;
                }
            }
        }
        return undefined;
    }
    /**
     * Transform a Sprotty edge element to an ELK edge element.
     */
    transformEdge(sedge, index) {
        const elkEdge = {
            id: sedge.id,
            sources: [sedge.sourceId],
            targets: [sedge.targetId],
            layoutOptions: this.configurator.apply(sedge, index)
        };
        if (sedge.children) {
            elkEdge.labels = sedge.children
                .filter(c => this.getBasicType(c) === 'label' && this.filter.apply(c, index))
                .map(c => this.transformLabel(c, index));
        }
        const points = sedge.routingPoints;
        if (points && points.length >= 2) {
            elkEdge.sections = [{
                    id: sedge.id + ':section',
                    startPoint: points[0],
                    bendPoints: points.slice(1, points.length - 1),
                    endPoint: points[points.length - 1]
                }];
        }
        return elkEdge;
    }
    /**
     * Transform a Sprotty label element to an ELK label element.
     */
    transformLabel(slabel, index) {
        const elkLabel = {
            id: slabel.id,
            text: slabel.text,
            layoutOptions: this.configurator.apply(slabel, index)
        };
        this.transformShape(elkLabel, slabel);
        return elkLabel;
    }
    /**
     * Transform a Sprotty port element to an ELK port element.
     */
    transformPort(sport, index) {
        const elkPort = {
            id: sport.id,
            layoutOptions: this.configurator.apply(sport, index)
        };
        if (sport.children) {
            elkPort.labels = sport.children
                .filter(c => this.getBasicType(c) === 'label' && this.filter.apply(c, index))
                .map(c => this.transformLabel(c, index));
        }
        this.transformShape(elkPort, sport);
        return elkPort;
    }
    /**
     * Copy the position and size of a Sprotty shape to an ELK shape.
     */
    transformShape(elkShape, sshape) {
        if (sshape.position) {
            elkShape.x = sshape.position.x;
            elkShape.y = sshape.position.y;
        }
        if (sshape.size) {
            elkShape.width = sshape.size.width;
            elkShape.height = sshape.size.height;
        }
    }
    /**
     * Apply the results of the ELK layout engine to the original Sprotty model.
     */
    applyLayout(elkNode, index) {
        const snode = index.getById(elkNode.id);
        if (snode && this.getBasicType(snode) === 'node') {
            this.applyShape(snode, elkNode, index);
        }
        if (elkNode.children) {
            for (const child of elkNode.children) {
                this.applyLayout(child, index);
            }
        }
        if (elkNode.edges) {
            for (const elkEdge of elkNode.edges) {
                const sedge = index.getById(elkEdge.id);
                if (sedge && this.getBasicType(sedge) === 'edge') {
                    this.applyEdge(sedge, elkEdge, index);
                }
            }
        }
        if (elkNode.ports) {
            for (const elkPort of elkNode.ports) {
                const sport = index.getById(elkPort.id);
                if (sport && this.getBasicType(sport) === 'port') {
                    this.applyShape(sport, elkPort, index);
                }
            }
        }
    }
    /**
     * Apply shape layout results, i.e. position and size.
     */
    applyShape(sshape, elkShape, index) {
        if (elkShape.x !== undefined && elkShape.y !== undefined) {
            sshape.position = { x: elkShape.x, y: elkShape.y };
        }
        if (elkShape.width !== undefined && elkShape.height !== undefined) {
            sshape.size = { width: elkShape.width, height: elkShape.height };
        }
        if (elkShape.labels) {
            for (const elkLabel of elkShape.labels) {
                const slabel = elkLabel.id && index.getById(elkLabel.id);
                if (slabel) {
                    this.applyShape(slabel, elkLabel, index);
                }
            }
        }
    }
    /**
     * Apply edge layout results, i.e. start point, end point and bend points.
     */
    applyEdge(sedge, elkEdge, index) {
        const points = [];
        if (elkEdge.sections && elkEdge.sections.length > 0) {
            const section = elkEdge.sections[0];
            if (section.startPoint) {
                points.push(section.startPoint);
            }
            if (section.bendPoints) {
                points.push(...section.bendPoints);
            }
            if (section.endPoint) {
                points.push(section.endPoint);
            }
        }
        else if (isPrimitiveEdge(elkEdge)) {
            if (elkEdge.sourcePoint) {
                points.push(elkEdge.sourcePoint);
            }
            if (elkEdge.bendPoints) {
                points.push(...elkEdge.bendPoints);
            }
            if (elkEdge.targetPoint) {
                points.push(elkEdge.targetPoint);
            }
        }
        sedge.routingPoints = points;
        if (elkEdge.labels) {
            elkEdge.labels.forEach((elkLabel) => {
                const sLabel = elkLabel.id && index.getById(elkLabel.id);
                if (sLabel) {
                    this.applyShape(sLabel, elkLabel, index);
                }
            });
        }
    }
}
exports.ElkLayoutEngine = ElkLayoutEngine;
function isPrimitiveEdge(edge) {
    return typeof edge.source === 'string'
        && typeof edge.target === 'string';
}
class DefaultElementFilter {
    apply(element, index) {
        switch (this.getBasicType(element)) {
            case 'node':
                return this.filterNode(element, index);
            case 'edge':
                return this.filterEdge(element, index);
            case 'label':
                return this.filterLabel(element, index);
            case 'port':
                return this.filterPort(element, index);
            case 'compartment':
                return this.filterCompartment(element, index);
            default:
                return true;
        }
    }
    getBasicType(smodel) {
        return (0, model_utils_1.getBasicType)(smodel);
    }
    filterNode(node, index) {
        return true;
    }
    filterEdge(edge, index) {
        const source = index.getById(edge.sourceId);
        if (!source)
            return false;
        const sourceType = this.getBasicType(source);
        if (sourceType === 'node' && !this.filterNode(source, index)
            || sourceType === 'port' && !this.filterPort(source, index))
            return false;
        const target = index.getById(edge.targetId);
        if (!target)
            return false;
        const targetType = this.getBasicType(target);
        if (targetType === 'node' && !this.filterNode(target, index)
            || targetType === 'port' && !this.filterPort(target, index))
            return false;
        return true;
    }
    filterLabel(label, index) {
        return true;
    }
    filterPort(port, index) {
        return true;
    }
    filterCompartment(compartment, index) {
        return true;
    }
}
exports.DefaultElementFilter = DefaultElementFilter;
class DefaultLayoutConfigurator {
    apply(element, index) {
        switch (this.getBasicType(element)) {
            case 'graph':
                return this.graphOptions(element, index);
            case 'node':
                return this.nodeOptions(element, index);
            case 'edge':
                return this.edgeOptions(element, index);
            case 'label':
                return this.labelOptions(element, index);
            case 'port':
                return this.portOptions(element, index);
            default:
                return undefined;
        }
    }
    getBasicType(smodel) {
        return (0, model_utils_1.getBasicType)(smodel);
    }
    graphOptions(sgraph, index) {
        return undefined;
    }
    nodeOptions(snode, index) {
        return undefined;
    }
    edgeOptions(sedge, index) {
        return undefined;
    }
    labelOptions(slabel, index) {
        return undefined;
    }
    portOptions(sport, index) {
        return undefined;
    }
}
exports.DefaultLayoutConfigurator = DefaultLayoutConfigurator;
//# sourceMappingURL=elk-layout.js.map