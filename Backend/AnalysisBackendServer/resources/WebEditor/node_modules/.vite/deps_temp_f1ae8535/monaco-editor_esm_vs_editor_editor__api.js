import {
  AudioCue,
  EditOperation,
  IAudioCueService,
  IClipboardService,
  IEditorWorkerService,
  IEnvironmentService,
  IWorkspaceContextService,
  STANDALONE_EDITOR_WORKSPACE_ID,
  StableEditorScrollState,
  TernarySearchTree,
  WorkspaceFolder
} from "./chunk-UB576Y65.js";
import {
  CountBadge,
  IBulkEditService,
  IEditorProgressService,
  IListService,
  IMarkerService,
  IProgressService,
  ListService,
  MarkerSeverity,
  ResourceEdit,
  ResourceTextEdit,
  WorkbenchList
} from "./chunk-DDRYTACB.js";
import {
  $,
  $window,
  Action,
  ActionBar,
  ActionRunner,
  ActionViewItem,
  AmbiguousCharacters,
  ApplyUpdateResult,
  AriaLabelProvider,
  ArrayQueue,
  BareFontInfo,
  BaseActionViewItem,
  BidirectionalMap,
  BrowserFeatures,
  BugIndicatingError,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  CancellationToken,
  CancellationTokenSource,
  CharacterClassifier,
  CodeEditorWidget,
  Codicon,
  Color,
  ColorScheme,
  CommandsRegistry,
  ConfigurationChangedEvent,
  ConsoleLogger,
  ContextKeyExpr,
  DEFAULT_WORD_REGEXP,
  DataUri,
  DebounceEmitter,
  DeferredPromise,
  Dimension,
  Disposable,
  DisposableStore,
  DomEmitter,
  DomScrollableElement,
  EDITOR_MODEL_DEFAULTS,
  EditorCommand,
  EditorContextKeys,
  EditorExtensionsRegistry,
  EditorFontLigatures,
  EditorOptions,
  EditorType,
  EditorZoom,
  ElectronAcceleratorLabelProvider,
  ElementSizeObserver,
  Emitter,
  EmptySubmenuAction,
  EncodedTokenizationResult,
  Event,
  EventHelper,
  EventType,
  EventType2,
  Extensions,
  Extensions2,
  Extensions3,
  FindInput,
  FindMatch,
  FoldingRangeKind,
  FontInfo,
  FontMeasurements,
  Gesture,
  GlobalIdleValue,
  GlyphMarginLane,
  HSLA,
  IAccessibilityService,
  IAccessibleNotificationService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextKeyService,
  IContextMenuService,
  IContextViewService,
  IInstantiationService,
  IKeybindingService,
  ILabelService,
  ILanguageConfigurationService,
  ILanguageFeaturesService,
  ILanguageService,
  ILogService,
  IME,
  IMMUTABLE_CODE_TO_KEY_CODE,
  IMarkerDecorationsService,
  IMenuService,
  IModelService,
  INotificationService,
  IOpenerService,
  IStorageService,
  ITelemetryService,
  ITextModelService,
  IThemeService,
  IUndoRedoService,
  IconLabel,
  IdGenerator,
  ImmortalReference,
  InMemoryStorageService,
  InlineDecoration,
  InternalEditorAction,
  IntervalTimer,
  InvisibleCharacters,
  Iterable,
  KeyChord,
  KeyCodeChord,
  KeyCodeUtils,
  KeybindingLabel,
  KeybindingsRegistry,
  LRUCache,
  Lazy,
  LazyTokenizationSupport,
  LcsDiff,
  LengthObj,
  LineDecoration,
  LineRange,
  LineRangeSet,
  LineTokens,
  LinkedList,
  LogLevel,
  MarkdownString,
  MenuId,
  MenuItemAction,
  MenuRegistry,
  MenuWorkbenchToolBar,
  Mimes,
  MinimapPosition,
  ModelDecorationOptions,
  ModesRegistry,
  ModifierKeyEmitter,
  MonotonousArray,
  MultiplexLogger,
  MutableDisposable,
  NoOpNotification,
  NullState,
  OS,
  OVERRIDE_PROPERTY_REGEX,
  OffsetRange,
  OffsetRangeSet,
  OverviewRulerLane,
  OverviewRulerZone,
  PLAINTEXT_LANGUAGE_ID,
  PauseableEmitter,
  Position,
  PrefixSumComputer,
  Range,
  Range2,
  RawContextKey,
  Registry,
  RenderLineInput,
  ResolvedChord,
  ResolvedKeybinding,
  ResourceEditStackSnapshot,
  ResourceMap,
  RunOnceScheduler,
  Sash,
  Schemas,
  Scrollable,
  ScrollbarState,
  Searcher,
  SelectedSuggestionInfo,
  Selection,
  Separator,
  ServiceCollection,
  SetMap,
  SmoothScrollableElement,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StopWatch,
  StringBuilder,
  StringSHA1,
  SubmenuAction,
  SubmenuItemAction,
  SymbolKinds,
  SyncDescriptor,
  TextEditInfo,
  TextModel,
  TextModelResolvedOptions,
  Themable,
  ThemeIcon,
  ThrottledDelayer,
  TimeoutTimer,
  Toggle,
  Token,
  TokenMetadata,
  TokenizationRegistry,
  TokenizationResult,
  UILabelProvider,
  URI,
  UndoRedoGroup,
  UndoRedoSource,
  UserSettingsLabelProvider,
  ViewLineRenderingData,
  WindowIntervalTimer,
  _util,
  activeContrastBorder,
  addDisposableListener,
  addMatchMediaChangeListener,
  addStandardDisposableListener,
  addToValueTree,
  append,
  applyFontInfo,
  asCSSPropertyValue,
  asCSSUrl,
  asCssVariable,
  asCssVariableName,
  assertFn,
  assertIsDefined,
  assertNever,
  assertType,
  autorun,
  autorunHandleChanges,
  autorunOpts,
  autorunWithStore,
  basename,
  basename2,
  boolean,
  booleanComparator,
  canceled,
  checkAdjacentItems,
  clampedFloat,
  clampedInt,
  clearNode,
  cloneAndChange,
  coalesce,
  combineTextEditInfos,
  combinedDisposable,
  compareBy,
  constObservable,
  createAndFillInContextMenuActions,
  createCSSRule,
  createDecorator,
  createFastDomNode,
  createProxyObject,
  createSingleCallFunction,
  createStyleSheet,
  createTrustedTypesPolicy,
  decodeKeybinding,
  deepClone,
  deepFreeze,
  defaultButtonStyles,
  defaultCountBadgeStyles,
  defaultInputBoxStyles,
  defaultInsertColor,
  defaultKeybindingLabelStyles,
  defaultMenuStyles,
  defaultProgressBarStyles,
  defaultRemoveColor,
  defaultToggleStyles,
  derived,
  derivedDisposable,
  derivedObservableWithCache,
  derivedWithStore,
  diffInserted,
  diffOverviewRulerInserted,
  diffOverviewRulerRemoved,
  diffRemoved,
  diffSets,
  disposableObservableValue,
  dispose,
  distinct,
  editorActiveIndentGuide1,
  editorBackground,
  editorForeground,
  editorInactiveSelection,
  editorIndentGuide1,
  editorOptionsRegistry,
  editorSelectionHighlight,
  ensureValidWordDefinition,
  env,
  equals,
  equals2,
  escape,
  escapeRegExpCharacters,
  expressionsAreEqualWithConstantSubstitution,
  extname,
  extractSelection,
  findFirstMaxBy,
  findFirstMonotonous,
  findLast,
  findLastIdxMonotonous,
  findLastMonotonous,
  findMaxIdxBy,
  firstNonWhitespaceIndex,
  firstOrDefault,
  forEachAdjacent,
  forEachWithNeighbors,
  format,
  getActiveDocument,
  getActiveElement,
  getActiveWindow,
  getAllMethodNames,
  getClientArea,
  getCodiconAriaLabel,
  getCodiconFontCharacters,
  getConfigurationValue,
  getDomNodePagePosition,
  getDomNodeZoomLevel,
  getIconRegistry,
  getListStyles,
  getSingletonServiceDescriptors,
  getTotalHeight,
  getTotalWidth,
  getWindow,
  getWordAtText,
  globalTransaction,
  groupAdjacentBy,
  h,
  hide,
  illegalArgument,
  illegalState,
  implies,
  isAncestor,
  isAncestorOfActiveElement,
  isBasicASCII,
  isCancellationError,
  isDark,
  isDefined,
  isDisposable,
  isEditStackElement,
  isEqualOrParent,
  isEventLike,
  isFalsyOrEmpty,
  isFirefox,
  isHighContrast,
  isHighSurrogate,
  isIMenuItem,
  isIOS,
  isISubmenuItem,
  isInShadowDOM,
  isLinux,
  isMacintosh,
  isMarkdownString,
  isMouseEvent,
  isNonEmptyArray,
  isObject,
  isSafari,
  isThenable,
  isUpperAsciiLetter,
  isWeb,
  isWebkitWebView,
  lastNonWhitespaceIndex,
  localize,
  ltrim,
  mainWindow,
  markdownStringEqual,
  matchesFuzzyIconAware,
  matchesScheme,
  matchesSomeScheme,
  memoize,
  minimapError,
  minimapInfo,
  minimapWarning,
  normalize,
  normalizePath,
  nullTokenize,
  nullTokenizeEncoded,
  numberComparator,
  observableFromEvent,
  observableSignal,
  observableSignalFromEvent,
  observableValue,
  onDidRegisterWindow,
  onUnexpectedError,
  onUnexpectedExternalError,
  onWillUnregisterWindow,
  overrideIdentifiersFromKey,
  overviewRulerError,
  overviewRulerInfo,
  overviewRulerWarning,
  parse,
  parseLabelWithIcons,
  pickerGroupBorder,
  pickerGroupForeground,
  posix,
  prepend,
  pushMany,
  quickInputBackground,
  quickInputForeground,
  quickInputListFocusBackground,
  quickInputListFocusForeground,
  quickInputListFocusIconForeground,
  quickInputTitleBackground,
  range,
  recomputeInitiallyAndOnChange,
  regExpLeadsToEndlessLoop,
  registerColor,
  registerEditorContribution,
  registerIcon,
  registerSingleton,
  removeFastWithoutKeepingOrder,
  removeFromValueTree,
  renderIcon,
  renderLabelWithIcons,
  renderMarkdown,
  renderStringAsPlaintext,
  renderViewLine,
  renderViewLine2,
  reset,
  reverseOrder,
  rtrim,
  sanitize,
  scheduleAtNextAnimationFrame,
  sep,
  setARIAContainer,
  severity_default,
  shouldSynchronizeModel,
  show,
  splitLines,
  startsWithUTF8BOM,
  stringDiff,
  stringSet,
  stripIcons,
  subtransaction,
  themeColorFromId,
  tieBreakComparators,
  timeout,
  toAction,
  toDisposable,
  toValuesTree,
  trackFocus,
  transaction,
  transformErrorForSerialization,
  waitForState,
  widgetBorder,
  widgetShadow,
  windowOpenNoOpener
} from "./chunk-Y6IYRH6M.js";
import "./chunk-6NOISVLF.js";

// node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
var AccessibilitySupport;
(function(AccessibilitySupport2) {
  AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
  AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
  AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CodeActionTriggerType;
(function(CodeActionTriggerType2) {
  CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
  CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
})(CodeActionTriggerType || (CodeActionTriggerType = {}));
var CompletionItemInsertTextRule;
(function(CompletionItemInsertTextRule2) {
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
  CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function(CompletionItemKind2) {
  CompletionItemKind2[CompletionItemKind2["Method"] = 0] = "Method";
  CompletionItemKind2[CompletionItemKind2["Function"] = 1] = "Function";
  CompletionItemKind2[CompletionItemKind2["Constructor"] = 2] = "Constructor";
  CompletionItemKind2[CompletionItemKind2["Field"] = 3] = "Field";
  CompletionItemKind2[CompletionItemKind2["Variable"] = 4] = "Variable";
  CompletionItemKind2[CompletionItemKind2["Class"] = 5] = "Class";
  CompletionItemKind2[CompletionItemKind2["Struct"] = 6] = "Struct";
  CompletionItemKind2[CompletionItemKind2["Interface"] = 7] = "Interface";
  CompletionItemKind2[CompletionItemKind2["Module"] = 8] = "Module";
  CompletionItemKind2[CompletionItemKind2["Property"] = 9] = "Property";
  CompletionItemKind2[CompletionItemKind2["Event"] = 10] = "Event";
  CompletionItemKind2[CompletionItemKind2["Operator"] = 11] = "Operator";
  CompletionItemKind2[CompletionItemKind2["Unit"] = 12] = "Unit";
  CompletionItemKind2[CompletionItemKind2["Value"] = 13] = "Value";
  CompletionItemKind2[CompletionItemKind2["Constant"] = 14] = "Constant";
  CompletionItemKind2[CompletionItemKind2["Enum"] = 15] = "Enum";
  CompletionItemKind2[CompletionItemKind2["EnumMember"] = 16] = "EnumMember";
  CompletionItemKind2[CompletionItemKind2["Keyword"] = 17] = "Keyword";
  CompletionItemKind2[CompletionItemKind2["Text"] = 18] = "Text";
  CompletionItemKind2[CompletionItemKind2["Color"] = 19] = "Color";
  CompletionItemKind2[CompletionItemKind2["File"] = 20] = "File";
  CompletionItemKind2[CompletionItemKind2["Reference"] = 21] = "Reference";
  CompletionItemKind2[CompletionItemKind2["Customcolor"] = 22] = "Customcolor";
  CompletionItemKind2[CompletionItemKind2["Folder"] = 23] = "Folder";
  CompletionItemKind2[CompletionItemKind2["TypeParameter"] = 24] = "TypeParameter";
  CompletionItemKind2[CompletionItemKind2["User"] = 25] = "User";
  CompletionItemKind2[CompletionItemKind2["Issue"] = 26] = "Issue";
  CompletionItemKind2[CompletionItemKind2["Snippet"] = 27] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemTag;
(function(CompletionItemTag2) {
  CompletionItemTag2[CompletionItemTag2["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
var CompletionTriggerKind;
(function(CompletionTriggerKind2) {
  CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
  CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
var ContentWidgetPositionPreference;
(function(ContentWidgetPositionPreference2) {
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
  ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
var CursorChangeReason;
(function(CursorChangeReason2) {
  CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
  CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
  CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
  CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
  CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
  CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
  CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));
var DefaultEndOfLine;
(function(DefaultEndOfLine2) {
  DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
  DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind2) {
  DocumentHighlightKind2[DocumentHighlightKind2["Text"] = 0] = "Text";
  DocumentHighlightKind2[DocumentHighlightKind2["Read"] = 1] = "Read";
  DocumentHighlightKind2[DocumentHighlightKind2["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var EditorAutoIndentStrategy;
(function(EditorAutoIndentStrategy2) {
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
  EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var EditorOption;
(function(EditorOption2) {
  EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
  EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
  EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
  EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
  EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
  EditorOption2[EditorOption2["ariaRequired"] = 5] = "ariaRequired";
  EditorOption2[EditorOption2["autoClosingBrackets"] = 6] = "autoClosingBrackets";
  EditorOption2[EditorOption2["autoClosingComments"] = 7] = "autoClosingComments";
  EditorOption2[EditorOption2["screenReaderAnnounceInlineSuggestion"] = 8] = "screenReaderAnnounceInlineSuggestion";
  EditorOption2[EditorOption2["autoClosingDelete"] = 9] = "autoClosingDelete";
  EditorOption2[EditorOption2["autoClosingOvertype"] = 10] = "autoClosingOvertype";
  EditorOption2[EditorOption2["autoClosingQuotes"] = 11] = "autoClosingQuotes";
  EditorOption2[EditorOption2["autoIndent"] = 12] = "autoIndent";
  EditorOption2[EditorOption2["automaticLayout"] = 13] = "automaticLayout";
  EditorOption2[EditorOption2["autoSurround"] = 14] = "autoSurround";
  EditorOption2[EditorOption2["bracketPairColorization"] = 15] = "bracketPairColorization";
  EditorOption2[EditorOption2["guides"] = 16] = "guides";
  EditorOption2[EditorOption2["codeLens"] = 17] = "codeLens";
  EditorOption2[EditorOption2["codeLensFontFamily"] = 18] = "codeLensFontFamily";
  EditorOption2[EditorOption2["codeLensFontSize"] = 19] = "codeLensFontSize";
  EditorOption2[EditorOption2["colorDecorators"] = 20] = "colorDecorators";
  EditorOption2[EditorOption2["colorDecoratorsLimit"] = 21] = "colorDecoratorsLimit";
  EditorOption2[EditorOption2["columnSelection"] = 22] = "columnSelection";
  EditorOption2[EditorOption2["comments"] = 23] = "comments";
  EditorOption2[EditorOption2["contextmenu"] = 24] = "contextmenu";
  EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 25] = "copyWithSyntaxHighlighting";
  EditorOption2[EditorOption2["cursorBlinking"] = 26] = "cursorBlinking";
  EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 27] = "cursorSmoothCaretAnimation";
  EditorOption2[EditorOption2["cursorStyle"] = 28] = "cursorStyle";
  EditorOption2[EditorOption2["cursorSurroundingLines"] = 29] = "cursorSurroundingLines";
  EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 30] = "cursorSurroundingLinesStyle";
  EditorOption2[EditorOption2["cursorWidth"] = 31] = "cursorWidth";
  EditorOption2[EditorOption2["disableLayerHinting"] = 32] = "disableLayerHinting";
  EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 33] = "disableMonospaceOptimizations";
  EditorOption2[EditorOption2["domReadOnly"] = 34] = "domReadOnly";
  EditorOption2[EditorOption2["dragAndDrop"] = 35] = "dragAndDrop";
  EditorOption2[EditorOption2["dropIntoEditor"] = 36] = "dropIntoEditor";
  EditorOption2[EditorOption2["emptySelectionClipboard"] = 37] = "emptySelectionClipboard";
  EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 38] = "experimentalWhitespaceRendering";
  EditorOption2[EditorOption2["extraEditorClassName"] = 39] = "extraEditorClassName";
  EditorOption2[EditorOption2["fastScrollSensitivity"] = 40] = "fastScrollSensitivity";
  EditorOption2[EditorOption2["find"] = 41] = "find";
  EditorOption2[EditorOption2["fixedOverflowWidgets"] = 42] = "fixedOverflowWidgets";
  EditorOption2[EditorOption2["folding"] = 43] = "folding";
  EditorOption2[EditorOption2["foldingStrategy"] = 44] = "foldingStrategy";
  EditorOption2[EditorOption2["foldingHighlight"] = 45] = "foldingHighlight";
  EditorOption2[EditorOption2["foldingImportsByDefault"] = 46] = "foldingImportsByDefault";
  EditorOption2[EditorOption2["foldingMaximumRegions"] = 47] = "foldingMaximumRegions";
  EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 48] = "unfoldOnClickAfterEndOfLine";
  EditorOption2[EditorOption2["fontFamily"] = 49] = "fontFamily";
  EditorOption2[EditorOption2["fontInfo"] = 50] = "fontInfo";
  EditorOption2[EditorOption2["fontLigatures"] = 51] = "fontLigatures";
  EditorOption2[EditorOption2["fontSize"] = 52] = "fontSize";
  EditorOption2[EditorOption2["fontWeight"] = 53] = "fontWeight";
  EditorOption2[EditorOption2["fontVariations"] = 54] = "fontVariations";
  EditorOption2[EditorOption2["formatOnPaste"] = 55] = "formatOnPaste";
  EditorOption2[EditorOption2["formatOnType"] = 56] = "formatOnType";
  EditorOption2[EditorOption2["glyphMargin"] = 57] = "glyphMargin";
  EditorOption2[EditorOption2["gotoLocation"] = 58] = "gotoLocation";
  EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 59] = "hideCursorInOverviewRuler";
  EditorOption2[EditorOption2["hover"] = 60] = "hover";
  EditorOption2[EditorOption2["inDiffEditor"] = 61] = "inDiffEditor";
  EditorOption2[EditorOption2["inlineSuggest"] = 62] = "inlineSuggest";
  EditorOption2[EditorOption2["letterSpacing"] = 63] = "letterSpacing";
  EditorOption2[EditorOption2["lightbulb"] = 64] = "lightbulb";
  EditorOption2[EditorOption2["lineDecorationsWidth"] = 65] = "lineDecorationsWidth";
  EditorOption2[EditorOption2["lineHeight"] = 66] = "lineHeight";
  EditorOption2[EditorOption2["lineNumbers"] = 67] = "lineNumbers";
  EditorOption2[EditorOption2["lineNumbersMinChars"] = 68] = "lineNumbersMinChars";
  EditorOption2[EditorOption2["linkedEditing"] = 69] = "linkedEditing";
  EditorOption2[EditorOption2["links"] = 70] = "links";
  EditorOption2[EditorOption2["matchBrackets"] = 71] = "matchBrackets";
  EditorOption2[EditorOption2["minimap"] = 72] = "minimap";
  EditorOption2[EditorOption2["mouseStyle"] = 73] = "mouseStyle";
  EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 74] = "mouseWheelScrollSensitivity";
  EditorOption2[EditorOption2["mouseWheelZoom"] = 75] = "mouseWheelZoom";
  EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 76] = "multiCursorMergeOverlapping";
  EditorOption2[EditorOption2["multiCursorModifier"] = 77] = "multiCursorModifier";
  EditorOption2[EditorOption2["multiCursorPaste"] = 78] = "multiCursorPaste";
  EditorOption2[EditorOption2["multiCursorLimit"] = 79] = "multiCursorLimit";
  EditorOption2[EditorOption2["occurrencesHighlight"] = 80] = "occurrencesHighlight";
  EditorOption2[EditorOption2["overviewRulerBorder"] = 81] = "overviewRulerBorder";
  EditorOption2[EditorOption2["overviewRulerLanes"] = 82] = "overviewRulerLanes";
  EditorOption2[EditorOption2["padding"] = 83] = "padding";
  EditorOption2[EditorOption2["pasteAs"] = 84] = "pasteAs";
  EditorOption2[EditorOption2["parameterHints"] = 85] = "parameterHints";
  EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 86] = "peekWidgetDefaultFocus";
  EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 87] = "definitionLinkOpensInPeek";
  EditorOption2[EditorOption2["quickSuggestions"] = 88] = "quickSuggestions";
  EditorOption2[EditorOption2["quickSuggestionsDelay"] = 89] = "quickSuggestionsDelay";
  EditorOption2[EditorOption2["readOnly"] = 90] = "readOnly";
  EditorOption2[EditorOption2["readOnlyMessage"] = 91] = "readOnlyMessage";
  EditorOption2[EditorOption2["renameOnType"] = 92] = "renameOnType";
  EditorOption2[EditorOption2["renderControlCharacters"] = 93] = "renderControlCharacters";
  EditorOption2[EditorOption2["renderFinalNewline"] = 94] = "renderFinalNewline";
  EditorOption2[EditorOption2["renderLineHighlight"] = 95] = "renderLineHighlight";
  EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 96] = "renderLineHighlightOnlyWhenFocus";
  EditorOption2[EditorOption2["renderValidationDecorations"] = 97] = "renderValidationDecorations";
  EditorOption2[EditorOption2["renderWhitespace"] = 98] = "renderWhitespace";
  EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 99] = "revealHorizontalRightPadding";
  EditorOption2[EditorOption2["roundedSelection"] = 100] = "roundedSelection";
  EditorOption2[EditorOption2["rulers"] = 101] = "rulers";
  EditorOption2[EditorOption2["scrollbar"] = 102] = "scrollbar";
  EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 103] = "scrollBeyondLastColumn";
  EditorOption2[EditorOption2["scrollBeyondLastLine"] = 104] = "scrollBeyondLastLine";
  EditorOption2[EditorOption2["scrollPredominantAxis"] = 105] = "scrollPredominantAxis";
  EditorOption2[EditorOption2["selectionClipboard"] = 106] = "selectionClipboard";
  EditorOption2[EditorOption2["selectionHighlight"] = 107] = "selectionHighlight";
  EditorOption2[EditorOption2["selectOnLineNumbers"] = 108] = "selectOnLineNumbers";
  EditorOption2[EditorOption2["showFoldingControls"] = 109] = "showFoldingControls";
  EditorOption2[EditorOption2["showUnused"] = 110] = "showUnused";
  EditorOption2[EditorOption2["snippetSuggestions"] = 111] = "snippetSuggestions";
  EditorOption2[EditorOption2["smartSelect"] = 112] = "smartSelect";
  EditorOption2[EditorOption2["smoothScrolling"] = 113] = "smoothScrolling";
  EditorOption2[EditorOption2["stickyScroll"] = 114] = "stickyScroll";
  EditorOption2[EditorOption2["stickyTabStops"] = 115] = "stickyTabStops";
  EditorOption2[EditorOption2["stopRenderingLineAfter"] = 116] = "stopRenderingLineAfter";
  EditorOption2[EditorOption2["suggest"] = 117] = "suggest";
  EditorOption2[EditorOption2["suggestFontSize"] = 118] = "suggestFontSize";
  EditorOption2[EditorOption2["suggestLineHeight"] = 119] = "suggestLineHeight";
  EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 120] = "suggestOnTriggerCharacters";
  EditorOption2[EditorOption2["suggestSelection"] = 121] = "suggestSelection";
  EditorOption2[EditorOption2["tabCompletion"] = 122] = "tabCompletion";
  EditorOption2[EditorOption2["tabIndex"] = 123] = "tabIndex";
  EditorOption2[EditorOption2["unicodeHighlighting"] = 124] = "unicodeHighlighting";
  EditorOption2[EditorOption2["unusualLineTerminators"] = 125] = "unusualLineTerminators";
  EditorOption2[EditorOption2["useShadowDOM"] = 126] = "useShadowDOM";
  EditorOption2[EditorOption2["useTabStops"] = 127] = "useTabStops";
  EditorOption2[EditorOption2["wordBreak"] = 128] = "wordBreak";
  EditorOption2[EditorOption2["wordSeparators"] = 129] = "wordSeparators";
  EditorOption2[EditorOption2["wordWrap"] = 130] = "wordWrap";
  EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 131] = "wordWrapBreakAfterCharacters";
  EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 132] = "wordWrapBreakBeforeCharacters";
  EditorOption2[EditorOption2["wordWrapColumn"] = 133] = "wordWrapColumn";
  EditorOption2[EditorOption2["wordWrapOverride1"] = 134] = "wordWrapOverride1";
  EditorOption2[EditorOption2["wordWrapOverride2"] = 135] = "wordWrapOverride2";
  EditorOption2[EditorOption2["wrappingIndent"] = 136] = "wrappingIndent";
  EditorOption2[EditorOption2["wrappingStrategy"] = 137] = "wrappingStrategy";
  EditorOption2[EditorOption2["showDeprecated"] = 138] = "showDeprecated";
  EditorOption2[EditorOption2["inlayHints"] = 139] = "inlayHints";
  EditorOption2[EditorOption2["editorClassName"] = 140] = "editorClassName";
  EditorOption2[EditorOption2["pixelRatio"] = 141] = "pixelRatio";
  EditorOption2[EditorOption2["tabFocusMode"] = 142] = "tabFocusMode";
  EditorOption2[EditorOption2["layoutInfo"] = 143] = "layoutInfo";
  EditorOption2[EditorOption2["wrappingInfo"] = 144] = "wrappingInfo";
  EditorOption2[EditorOption2["defaultColorDecorators"] = 145] = "defaultColorDecorators";
  EditorOption2[EditorOption2["colorDecoratorsActivatedOn"] = 146] = "colorDecoratorsActivatedOn";
  EditorOption2[EditorOption2["inlineCompletionsAccessibilityVerbose"] = 147] = "inlineCompletionsAccessibilityVerbose";
})(EditorOption || (EditorOption = {}));
var EndOfLinePreference;
(function(EndOfLinePreference2) {
  EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
  EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
  EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
var EndOfLineSequence;
(function(EndOfLineSequence2) {
  EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
  EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
var GlyphMarginLane2;
(function(GlyphMarginLane3) {
  GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
  GlyphMarginLane3[GlyphMarginLane3["Right"] = 2] = "Right";
})(GlyphMarginLane2 || (GlyphMarginLane2 = {}));
var IndentAction;
(function(IndentAction2) {
  IndentAction2[IndentAction2["None"] = 0] = "None";
  IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
  IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
  IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
var InjectedTextCursorStops;
(function(InjectedTextCursorStops2) {
  InjectedTextCursorStops2[InjectedTextCursorStops2["Both"] = 0] = "Both";
  InjectedTextCursorStops2[InjectedTextCursorStops2["Right"] = 1] = "Right";
  InjectedTextCursorStops2[InjectedTextCursorStops2["Left"] = 2] = "Left";
  InjectedTextCursorStops2[InjectedTextCursorStops2["None"] = 3] = "None";
})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
var InlayHintKind;
(function(InlayHintKind2) {
  InlayHintKind2[InlayHintKind2["Type"] = 1] = "Type";
  InlayHintKind2[InlayHintKind2["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}));
var InlineCompletionTriggerKind;
(function(InlineCompletionTriggerKind2) {
  InlineCompletionTriggerKind2[InlineCompletionTriggerKind2["Automatic"] = 0] = "Automatic";
  InlineCompletionTriggerKind2[InlineCompletionTriggerKind2["Explicit"] = 1] = "Explicit";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var KeyCode;
(function(KeyCode3) {
  KeyCode3[KeyCode3["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
  KeyCode3[KeyCode3["Unknown"] = 0] = "Unknown";
  KeyCode3[KeyCode3["Backspace"] = 1] = "Backspace";
  KeyCode3[KeyCode3["Tab"] = 2] = "Tab";
  KeyCode3[KeyCode3["Enter"] = 3] = "Enter";
  KeyCode3[KeyCode3["Shift"] = 4] = "Shift";
  KeyCode3[KeyCode3["Ctrl"] = 5] = "Ctrl";
  KeyCode3[KeyCode3["Alt"] = 6] = "Alt";
  KeyCode3[KeyCode3["PauseBreak"] = 7] = "PauseBreak";
  KeyCode3[KeyCode3["CapsLock"] = 8] = "CapsLock";
  KeyCode3[KeyCode3["Escape"] = 9] = "Escape";
  KeyCode3[KeyCode3["Space"] = 10] = "Space";
  KeyCode3[KeyCode3["PageUp"] = 11] = "PageUp";
  KeyCode3[KeyCode3["PageDown"] = 12] = "PageDown";
  KeyCode3[KeyCode3["End"] = 13] = "End";
  KeyCode3[KeyCode3["Home"] = 14] = "Home";
  KeyCode3[KeyCode3["LeftArrow"] = 15] = "LeftArrow";
  KeyCode3[KeyCode3["UpArrow"] = 16] = "UpArrow";
  KeyCode3[KeyCode3["RightArrow"] = 17] = "RightArrow";
  KeyCode3[KeyCode3["DownArrow"] = 18] = "DownArrow";
  KeyCode3[KeyCode3["Insert"] = 19] = "Insert";
  KeyCode3[KeyCode3["Delete"] = 20] = "Delete";
  KeyCode3[KeyCode3["Digit0"] = 21] = "Digit0";
  KeyCode3[KeyCode3["Digit1"] = 22] = "Digit1";
  KeyCode3[KeyCode3["Digit2"] = 23] = "Digit2";
  KeyCode3[KeyCode3["Digit3"] = 24] = "Digit3";
  KeyCode3[KeyCode3["Digit4"] = 25] = "Digit4";
  KeyCode3[KeyCode3["Digit5"] = 26] = "Digit5";
  KeyCode3[KeyCode3["Digit6"] = 27] = "Digit6";
  KeyCode3[KeyCode3["Digit7"] = 28] = "Digit7";
  KeyCode3[KeyCode3["Digit8"] = 29] = "Digit8";
  KeyCode3[KeyCode3["Digit9"] = 30] = "Digit9";
  KeyCode3[KeyCode3["KeyA"] = 31] = "KeyA";
  KeyCode3[KeyCode3["KeyB"] = 32] = "KeyB";
  KeyCode3[KeyCode3["KeyC"] = 33] = "KeyC";
  KeyCode3[KeyCode3["KeyD"] = 34] = "KeyD";
  KeyCode3[KeyCode3["KeyE"] = 35] = "KeyE";
  KeyCode3[KeyCode3["KeyF"] = 36] = "KeyF";
  KeyCode3[KeyCode3["KeyG"] = 37] = "KeyG";
  KeyCode3[KeyCode3["KeyH"] = 38] = "KeyH";
  KeyCode3[KeyCode3["KeyI"] = 39] = "KeyI";
  KeyCode3[KeyCode3["KeyJ"] = 40] = "KeyJ";
  KeyCode3[KeyCode3["KeyK"] = 41] = "KeyK";
  KeyCode3[KeyCode3["KeyL"] = 42] = "KeyL";
  KeyCode3[KeyCode3["KeyM"] = 43] = "KeyM";
  KeyCode3[KeyCode3["KeyN"] = 44] = "KeyN";
  KeyCode3[KeyCode3["KeyO"] = 45] = "KeyO";
  KeyCode3[KeyCode3["KeyP"] = 46] = "KeyP";
  KeyCode3[KeyCode3["KeyQ"] = 47] = "KeyQ";
  KeyCode3[KeyCode3["KeyR"] = 48] = "KeyR";
  KeyCode3[KeyCode3["KeyS"] = 49] = "KeyS";
  KeyCode3[KeyCode3["KeyT"] = 50] = "KeyT";
  KeyCode3[KeyCode3["KeyU"] = 51] = "KeyU";
  KeyCode3[KeyCode3["KeyV"] = 52] = "KeyV";
  KeyCode3[KeyCode3["KeyW"] = 53] = "KeyW";
  KeyCode3[KeyCode3["KeyX"] = 54] = "KeyX";
  KeyCode3[KeyCode3["KeyY"] = 55] = "KeyY";
  KeyCode3[KeyCode3["KeyZ"] = 56] = "KeyZ";
  KeyCode3[KeyCode3["Meta"] = 57] = "Meta";
  KeyCode3[KeyCode3["ContextMenu"] = 58] = "ContextMenu";
  KeyCode3[KeyCode3["F1"] = 59] = "F1";
  KeyCode3[KeyCode3["F2"] = 60] = "F2";
  KeyCode3[KeyCode3["F3"] = 61] = "F3";
  KeyCode3[KeyCode3["F4"] = 62] = "F4";
  KeyCode3[KeyCode3["F5"] = 63] = "F5";
  KeyCode3[KeyCode3["F6"] = 64] = "F6";
  KeyCode3[KeyCode3["F7"] = 65] = "F7";
  KeyCode3[KeyCode3["F8"] = 66] = "F8";
  KeyCode3[KeyCode3["F9"] = 67] = "F9";
  KeyCode3[KeyCode3["F10"] = 68] = "F10";
  KeyCode3[KeyCode3["F11"] = 69] = "F11";
  KeyCode3[KeyCode3["F12"] = 70] = "F12";
  KeyCode3[KeyCode3["F13"] = 71] = "F13";
  KeyCode3[KeyCode3["F14"] = 72] = "F14";
  KeyCode3[KeyCode3["F15"] = 73] = "F15";
  KeyCode3[KeyCode3["F16"] = 74] = "F16";
  KeyCode3[KeyCode3["F17"] = 75] = "F17";
  KeyCode3[KeyCode3["F18"] = 76] = "F18";
  KeyCode3[KeyCode3["F19"] = 77] = "F19";
  KeyCode3[KeyCode3["F20"] = 78] = "F20";
  KeyCode3[KeyCode3["F21"] = 79] = "F21";
  KeyCode3[KeyCode3["F22"] = 80] = "F22";
  KeyCode3[KeyCode3["F23"] = 81] = "F23";
  KeyCode3[KeyCode3["F24"] = 82] = "F24";
  KeyCode3[KeyCode3["NumLock"] = 83] = "NumLock";
  KeyCode3[KeyCode3["ScrollLock"] = 84] = "ScrollLock";
  KeyCode3[KeyCode3["Semicolon"] = 85] = "Semicolon";
  KeyCode3[KeyCode3["Equal"] = 86] = "Equal";
  KeyCode3[KeyCode3["Comma"] = 87] = "Comma";
  KeyCode3[KeyCode3["Minus"] = 88] = "Minus";
  KeyCode3[KeyCode3["Period"] = 89] = "Period";
  KeyCode3[KeyCode3["Slash"] = 90] = "Slash";
  KeyCode3[KeyCode3["Backquote"] = 91] = "Backquote";
  KeyCode3[KeyCode3["BracketLeft"] = 92] = "BracketLeft";
  KeyCode3[KeyCode3["Backslash"] = 93] = "Backslash";
  KeyCode3[KeyCode3["BracketRight"] = 94] = "BracketRight";
  KeyCode3[KeyCode3["Quote"] = 95] = "Quote";
  KeyCode3[KeyCode3["OEM_8"] = 96] = "OEM_8";
  KeyCode3[KeyCode3["IntlBackslash"] = 97] = "IntlBackslash";
  KeyCode3[KeyCode3["Numpad0"] = 98] = "Numpad0";
  KeyCode3[KeyCode3["Numpad1"] = 99] = "Numpad1";
  KeyCode3[KeyCode3["Numpad2"] = 100] = "Numpad2";
  KeyCode3[KeyCode3["Numpad3"] = 101] = "Numpad3";
  KeyCode3[KeyCode3["Numpad4"] = 102] = "Numpad4";
  KeyCode3[KeyCode3["Numpad5"] = 103] = "Numpad5";
  KeyCode3[KeyCode3["Numpad6"] = 104] = "Numpad6";
  KeyCode3[KeyCode3["Numpad7"] = 105] = "Numpad7";
  KeyCode3[KeyCode3["Numpad8"] = 106] = "Numpad8";
  KeyCode3[KeyCode3["Numpad9"] = 107] = "Numpad9";
  KeyCode3[KeyCode3["NumpadMultiply"] = 108] = "NumpadMultiply";
  KeyCode3[KeyCode3["NumpadAdd"] = 109] = "NumpadAdd";
  KeyCode3[KeyCode3["NUMPAD_SEPARATOR"] = 110] = "NUMPAD_SEPARATOR";
  KeyCode3[KeyCode3["NumpadSubtract"] = 111] = "NumpadSubtract";
  KeyCode3[KeyCode3["NumpadDecimal"] = 112] = "NumpadDecimal";
  KeyCode3[KeyCode3["NumpadDivide"] = 113] = "NumpadDivide";
  KeyCode3[KeyCode3["KEY_IN_COMPOSITION"] = 114] = "KEY_IN_COMPOSITION";
  KeyCode3[KeyCode3["ABNT_C1"] = 115] = "ABNT_C1";
  KeyCode3[KeyCode3["ABNT_C2"] = 116] = "ABNT_C2";
  KeyCode3[KeyCode3["AudioVolumeMute"] = 117] = "AudioVolumeMute";
  KeyCode3[KeyCode3["AudioVolumeUp"] = 118] = "AudioVolumeUp";
  KeyCode3[KeyCode3["AudioVolumeDown"] = 119] = "AudioVolumeDown";
  KeyCode3[KeyCode3["BrowserSearch"] = 120] = "BrowserSearch";
  KeyCode3[KeyCode3["BrowserHome"] = 121] = "BrowserHome";
  KeyCode3[KeyCode3["BrowserBack"] = 122] = "BrowserBack";
  KeyCode3[KeyCode3["BrowserForward"] = 123] = "BrowserForward";
  KeyCode3[KeyCode3["MediaTrackNext"] = 124] = "MediaTrackNext";
  KeyCode3[KeyCode3["MediaTrackPrevious"] = 125] = "MediaTrackPrevious";
  KeyCode3[KeyCode3["MediaStop"] = 126] = "MediaStop";
  KeyCode3[KeyCode3["MediaPlayPause"] = 127] = "MediaPlayPause";
  KeyCode3[KeyCode3["LaunchMediaPlayer"] = 128] = "LaunchMediaPlayer";
  KeyCode3[KeyCode3["LaunchMail"] = 129] = "LaunchMail";
  KeyCode3[KeyCode3["LaunchApp2"] = 130] = "LaunchApp2";
  KeyCode3[KeyCode3["Clear"] = 131] = "Clear";
  KeyCode3[KeyCode3["MAX_VALUE"] = 132] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));
var MarkerSeverity2;
(function(MarkerSeverity4) {
  MarkerSeverity4[MarkerSeverity4["Hint"] = 1] = "Hint";
  MarkerSeverity4[MarkerSeverity4["Info"] = 2] = "Info";
  MarkerSeverity4[MarkerSeverity4["Warning"] = 4] = "Warning";
  MarkerSeverity4[MarkerSeverity4["Error"] = 8] = "Error";
})(MarkerSeverity2 || (MarkerSeverity2 = {}));
var MarkerTag;
(function(MarkerTag3) {
  MarkerTag3[MarkerTag3["Unnecessary"] = 1] = "Unnecessary";
  MarkerTag3[MarkerTag3["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
var MinimapPosition2;
(function(MinimapPosition3) {
  MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
  MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
})(MinimapPosition2 || (MinimapPosition2 = {}));
var MouseTargetType;
(function(MouseTargetType2) {
  MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
  MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
  MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
  MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
  MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
  MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
  MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
  MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
  MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
  MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
  MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
  MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
var OverlayWidgetPositionPreference;
(function(OverlayWidgetPositionPreference2) {
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
  OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
var OverviewRulerLane2;
(function(OverviewRulerLane3) {
  OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
  OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
  OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
  OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
})(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
var PositionAffinity;
(function(PositionAffinity2) {
  PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
  PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
  PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
  PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
  PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
})(PositionAffinity || (PositionAffinity = {}));
var RenderLineNumbersType;
(function(RenderLineNumbersType2) {
  RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
  RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
  RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
  RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
  RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var RenderMinimap;
(function(RenderMinimap2) {
  RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
  RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
  RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var ScrollType;
(function(ScrollType2) {
  ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
  ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
var ScrollbarVisibility;
(function(ScrollbarVisibility2) {
  ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
  ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
  ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
var SelectionDirection;
(function(SelectionDirection3) {
  SelectionDirection3[SelectionDirection3["LTR"] = 0] = "LTR";
  SelectionDirection3[SelectionDirection3["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var ShowAiIconMode;
(function(ShowAiIconMode2) {
  ShowAiIconMode2["Off"] = "off";
  ShowAiIconMode2["OnCode"] = "onCode";
  ShowAiIconMode2["On"] = "on";
})(ShowAiIconMode || (ShowAiIconMode = {}));
var SignatureHelpTriggerKind;
(function(SignatureHelpTriggerKind2) {
  SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["Invoke"] = 1] = "Invoke";
  SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["TriggerCharacter"] = 2] = "TriggerCharacter";
  SignatureHelpTriggerKind2[SignatureHelpTriggerKind2["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
var SymbolKind;
(function(SymbolKind2) {
  SymbolKind2[SymbolKind2["File"] = 0] = "File";
  SymbolKind2[SymbolKind2["Module"] = 1] = "Module";
  SymbolKind2[SymbolKind2["Namespace"] = 2] = "Namespace";
  SymbolKind2[SymbolKind2["Package"] = 3] = "Package";
  SymbolKind2[SymbolKind2["Class"] = 4] = "Class";
  SymbolKind2[SymbolKind2["Method"] = 5] = "Method";
  SymbolKind2[SymbolKind2["Property"] = 6] = "Property";
  SymbolKind2[SymbolKind2["Field"] = 7] = "Field";
  SymbolKind2[SymbolKind2["Constructor"] = 8] = "Constructor";
  SymbolKind2[SymbolKind2["Enum"] = 9] = "Enum";
  SymbolKind2[SymbolKind2["Interface"] = 10] = "Interface";
  SymbolKind2[SymbolKind2["Function"] = 11] = "Function";
  SymbolKind2[SymbolKind2["Variable"] = 12] = "Variable";
  SymbolKind2[SymbolKind2["Constant"] = 13] = "Constant";
  SymbolKind2[SymbolKind2["String"] = 14] = "String";
  SymbolKind2[SymbolKind2["Number"] = 15] = "Number";
  SymbolKind2[SymbolKind2["Boolean"] = 16] = "Boolean";
  SymbolKind2[SymbolKind2["Array"] = 17] = "Array";
  SymbolKind2[SymbolKind2["Object"] = 18] = "Object";
  SymbolKind2[SymbolKind2["Key"] = 19] = "Key";
  SymbolKind2[SymbolKind2["Null"] = 20] = "Null";
  SymbolKind2[SymbolKind2["EnumMember"] = 21] = "EnumMember";
  SymbolKind2[SymbolKind2["Struct"] = 22] = "Struct";
  SymbolKind2[SymbolKind2["Event"] = 23] = "Event";
  SymbolKind2[SymbolKind2["Operator"] = 24] = "Operator";
  SymbolKind2[SymbolKind2["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag2) {
  SymbolTag2[SymbolTag2["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
var TextEditorCursorBlinkingStyle;
(function(TextEditorCursorBlinkingStyle2) {
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
  TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
var TextEditorCursorStyle;
(function(TextEditorCursorStyle2) {
  TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
  TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
  TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
  TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
  TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
  TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
var TrackedRangeStickiness;
(function(TrackedRangeStickiness2) {
  TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
  TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
var WrappingIndent;
(function(WrappingIndent2) {
  WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
  WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
  WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
  WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));

// node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
var KeyMod = class {
  static chord(firstPart, secondPart) {
    return KeyChord(firstPart, secondPart);
  }
};
KeyMod.CtrlCmd = 2048;
KeyMod.Shift = 1024;
KeyMod.Alt = 512;
KeyMod.WinCtrl = 256;
function createMonacoBaseAPI() {
  return {
    editor: void 0,
    // undefined override expected here
    languages: void 0,
    // undefined override expected here
    CancellationTokenSource,
    Emitter,
    KeyCode,
    KeyMod,
    Position,
    Range,
    Selection,
    SelectionDirection,
    MarkerSeverity: MarkerSeverity2,
    MarkerTag,
    Uri: URI,
    Token
  };
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneEditor.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/editor/standalone/browser/standalone-tokens.css";

// node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
var INITIALIZE = "$initialize";
var webWorkerWarningLogged = false;
function logOnceWebWorkerWarning(err) {
  if (!isWeb) {
    return;
  }
  if (!webWorkerWarningLogged) {
    webWorkerWarningLogged = true;
    console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq");
  }
  console.warn(err.message);
}
var RequestMessage = class {
  constructor(vsWorker, req, method, args) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.method = method;
    this.args = args;
    this.type = 0;
  }
};
var ReplyMessage = class {
  constructor(vsWorker, seq, res, err) {
    this.vsWorker = vsWorker;
    this.seq = seq;
    this.res = res;
    this.err = err;
    this.type = 1;
  }
};
var SubscribeEventMessage = class {
  constructor(vsWorker, req, eventName, arg) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.eventName = eventName;
    this.arg = arg;
    this.type = 2;
  }
};
var EventMessage = class {
  constructor(vsWorker, req, event) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.event = event;
    this.type = 3;
  }
};
var UnsubscribeEventMessage = class {
  constructor(vsWorker, req) {
    this.vsWorker = vsWorker;
    this.req = req;
    this.type = 4;
  }
};
var SimpleWorkerProtocol = class {
  constructor(handler) {
    this._workerId = -1;
    this._handler = handler;
    this._lastSentReq = 0;
    this._pendingReplies = /* @__PURE__ */ Object.create(null);
    this._pendingEmitters = /* @__PURE__ */ new Map();
    this._pendingEvents = /* @__PURE__ */ new Map();
  }
  setWorkerId(workerId) {
    this._workerId = workerId;
  }
  sendMessage(method, args) {
    const req = String(++this._lastSentReq);
    return new Promise((resolve, reject) => {
      this._pendingReplies[req] = {
        resolve,
        reject
      };
      this._send(new RequestMessage(this._workerId, req, method, args));
    });
  }
  listen(eventName, arg) {
    let req = null;
    const emitter = new Emitter({
      onWillAddFirstListener: () => {
        req = String(++this._lastSentReq);
        this._pendingEmitters.set(req, emitter);
        this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
      },
      onDidRemoveLastListener: () => {
        this._pendingEmitters.delete(req);
        this._send(new UnsubscribeEventMessage(this._workerId, req));
        req = null;
      }
    });
    return emitter.event;
  }
  handleMessage(message) {
    if (!message || !message.vsWorker) {
      return;
    }
    if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
      return;
    }
    this._handleMessage(message);
  }
  _handleMessage(msg) {
    switch (msg.type) {
      case 1:
        return this._handleReplyMessage(msg);
      case 0:
        return this._handleRequestMessage(msg);
      case 2:
        return this._handleSubscribeEventMessage(msg);
      case 3:
        return this._handleEventMessage(msg);
      case 4:
        return this._handleUnsubscribeEventMessage(msg);
    }
  }
  _handleReplyMessage(replyMessage) {
    if (!this._pendingReplies[replyMessage.seq]) {
      console.warn("Got reply to unknown seq");
      return;
    }
    const reply = this._pendingReplies[replyMessage.seq];
    delete this._pendingReplies[replyMessage.seq];
    if (replyMessage.err) {
      let err = replyMessage.err;
      if (replyMessage.err.$isError) {
        err = new Error();
        err.name = replyMessage.err.name;
        err.message = replyMessage.err.message;
        err.stack = replyMessage.err.stack;
      }
      reply.reject(err);
      return;
    }
    reply.resolve(replyMessage.res);
  }
  _handleRequestMessage(requestMessage) {
    const req = requestMessage.req;
    const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
    result.then((r) => {
      this._send(new ReplyMessage(this._workerId, req, r, void 0));
    }, (e) => {
      if (e.detail instanceof Error) {
        e.detail = transformErrorForSerialization(e.detail);
      }
      this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));
    });
  }
  _handleSubscribeEventMessage(msg) {
    const req = msg.req;
    const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
      this._send(new EventMessage(this._workerId, req, event));
    });
    this._pendingEvents.set(req, disposable);
  }
  _handleEventMessage(msg) {
    if (!this._pendingEmitters.has(msg.req)) {
      console.warn("Got event for unknown req");
      return;
    }
    this._pendingEmitters.get(msg.req).fire(msg.event);
  }
  _handleUnsubscribeEventMessage(msg) {
    if (!this._pendingEvents.has(msg.req)) {
      console.warn("Got unsubscribe for unknown req");
      return;
    }
    this._pendingEvents.get(msg.req).dispose();
    this._pendingEvents.delete(msg.req);
  }
  _send(msg) {
    const transfer = [];
    if (msg.type === 0) {
      for (let i = 0; i < msg.args.length; i++) {
        if (msg.args[i] instanceof ArrayBuffer) {
          transfer.push(msg.args[i]);
        }
      }
    } else if (msg.type === 1) {
      if (msg.res instanceof ArrayBuffer) {
        transfer.push(msg.res);
      }
    }
    this._handler.sendMessage(msg, transfer);
  }
};
var SimpleWorkerClient = class extends Disposable {
  constructor(workerFactory, moduleId, host) {
    super();
    let lazyProxyReject = null;
    this._worker = this._register(workerFactory.create("vs/base/common/worker/simpleWorker", (msg) => {
      this._protocol.handleMessage(msg);
    }, (err) => {
      lazyProxyReject === null || lazyProxyReject === void 0 ? void 0 : lazyProxyReject(err);
    }));
    this._protocol = new SimpleWorkerProtocol({
      sendMessage: (msg, transfer) => {
        this._worker.postMessage(msg, transfer);
      },
      handleMessage: (method, args) => {
        if (typeof host[method] !== "function") {
          return Promise.reject(new Error("Missing method " + method + " on main thread host."));
        }
        try {
          return Promise.resolve(host[method].apply(host, args));
        } catch (e) {
          return Promise.reject(e);
        }
      },
      handleEvent: (eventName, arg) => {
        if (propertyIsDynamicEvent(eventName)) {
          const event = host[eventName].call(host, arg);
          if (typeof event !== "function") {
            throw new Error(`Missing dynamic event ${eventName} on main thread host.`);
          }
          return event;
        }
        if (propertyIsEvent(eventName)) {
          const event = host[eventName];
          if (typeof event !== "function") {
            throw new Error(`Missing event ${eventName} on main thread host.`);
          }
          return event;
        }
        throw new Error(`Malformed event name ${eventName}`);
      }
    });
    this._protocol.setWorkerId(this._worker.getId());
    let loaderConfiguration = null;
    const globalRequire = globalThis.require;
    if (typeof globalRequire !== "undefined" && typeof globalRequire.getConfig === "function") {
      loaderConfiguration = globalRequire.getConfig();
    } else if (typeof globalThis.requirejs !== "undefined") {
      loaderConfiguration = globalThis.requirejs.s.contexts._.config;
    }
    const hostMethods = getAllMethodNames(host);
    this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(loaderConfiguration)),
      moduleId,
      hostMethods
    ]);
    const proxyMethodRequest = (method, args) => {
      return this._request(method, args);
    };
    const proxyListen = (eventName, arg) => {
      return this._protocol.listen(eventName, arg);
    };
    this._lazyProxy = new Promise((resolve, reject) => {
      lazyProxyReject = reject;
      this._onModuleLoaded.then((availableMethods) => {
        resolve(createProxyObject2(availableMethods, proxyMethodRequest, proxyListen));
      }, (e) => {
        reject(e);
        this._onError("Worker failed to load " + moduleId, e);
      });
    });
  }
  getProxyObject() {
    return this._lazyProxy;
  }
  _request(method, args) {
    return new Promise((resolve, reject) => {
      this._onModuleLoaded.then(() => {
        this._protocol.sendMessage(method, args).then(resolve, reject);
      }, reject);
    });
  }
  _onError(message, error) {
    console.error(message);
    console.info(error);
  }
};
function propertyIsEvent(name) {
  return name[0] === "o" && name[1] === "n" && isUpperAsciiLetter(name.charCodeAt(2));
}
function propertyIsDynamicEvent(name) {
  return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));
}
function createProxyObject2(methodNames, invoke, proxyListen) {
  const createProxyMethod = (method) => {
    return function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return invoke(method, args);
    };
  };
  const createProxyDynamicEvent = (eventName) => {
    return function(arg) {
      return proxyListen(eventName, arg);
    };
  };
  const result = {};
  for (const methodName of methodNames) {
    if (propertyIsDynamicEvent(methodName)) {
      result[methodName] = createProxyDynamicEvent(methodName);
      continue;
    }
    if (propertyIsEvent(methodName)) {
      result[methodName] = proxyListen(methodName, void 0);
      continue;
    }
    result[methodName] = createProxyMethod(methodName);
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/base/browser/defaultWorkerFactory.js
var ttPolicy = createTrustedTypesPolicy("defaultWorkerFactory", { createScriptURL: (value) => value });
function getWorker(label) {
  const monacoEnvironment2 = globalThis.MonacoEnvironment;
  if (monacoEnvironment2) {
    if (typeof monacoEnvironment2.getWorker === "function") {
      return monacoEnvironment2.getWorker("workerMain.js", label);
    }
    if (typeof monacoEnvironment2.getWorkerUrl === "function") {
      const workerUrl = monacoEnvironment2.getWorkerUrl("workerMain.js", label);
      return new Worker(ttPolicy ? ttPolicy.createScriptURL(workerUrl) : workerUrl, { name: label });
    }
  }
  throw new Error(`You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker`);
}
function isPromiseLike(obj) {
  if (typeof obj.then === "function") {
    return true;
  }
  return false;
}
var WebWorker = class {
  constructor(moduleId, id, label, onMessageCallback, onErrorCallback) {
    this.id = id;
    this.label = label;
    const workerOrPromise = getWorker(label);
    if (isPromiseLike(workerOrPromise)) {
      this.worker = workerOrPromise;
    } else {
      this.worker = Promise.resolve(workerOrPromise);
    }
    this.postMessage(moduleId, []);
    this.worker.then((w) => {
      w.onmessage = function(ev) {
        onMessageCallback(ev.data);
      };
      w.onmessageerror = onErrorCallback;
      if (typeof w.addEventListener === "function") {
        w.addEventListener("error", onErrorCallback);
      }
    });
  }
  getId() {
    return this.id;
  }
  postMessage(message, transfer) {
    var _a;
    (_a = this.worker) === null || _a === void 0 ? void 0 : _a.then((w) => {
      try {
        w.postMessage(message, transfer);
      } catch (err) {
        onUnexpectedError(err);
        onUnexpectedError(new Error(`FAILED to post message to '${this.label}'-worker`, { cause: err }));
      }
    });
  }
  dispose() {
    var _a;
    (_a = this.worker) === null || _a === void 0 ? void 0 : _a.then((w) => w.terminate());
    this.worker = null;
  }
};
var DefaultWorkerFactory = class _DefaultWorkerFactory {
  constructor(label) {
    this._label = label;
    this._webWorkerFailedBeforeError = false;
  }
  create(moduleId, onMessageCallback, onErrorCallback) {
    const workerId = ++_DefaultWorkerFactory.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError) {
      throw this._webWorkerFailedBeforeError;
    }
    return new WebWorker(moduleId, workerId, this._label || "anonymous" + workerId, onMessageCallback, (err) => {
      logOnceWebWorkerWarning(err);
      this._webWorkerFailedBeforeError = err;
      onErrorCallback(err);
    });
  }
};
DefaultWorkerFactory.LAST_WORKER_ID = 0;

// node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
var MirrorTextModel = class {
  constructor(uri, lines, eol, versionId) {
    this._uri = uri;
    this._lines = lines;
    this._eol = eol;
    this._versionId = versionId;
    this._lineStarts = null;
    this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    if (this._cachedTextValue === null) {
      this._cachedTextValue = this._lines.join(this._eol);
    }
    return this._cachedTextValue;
  }
  onEvents(e) {
    if (e.eol && e.eol !== this._eol) {
      this._eol = e.eol;
      this._lineStarts = null;
    }
    const changes = e.changes;
    for (const change of changes) {
      this._acceptDeleteRange(change.range);
      this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
    }
    this._versionId = e.versionId;
    this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const eolLength = this._eol.length;
      const linesLength = this._lines.length;
      const lineStartValues = new Uint32Array(linesLength);
      for (let i = 0; i < linesLength; i++) {
        lineStartValues[i] = this._lines[i].length + eolLength;
      }
      this._lineStarts = new PrefixSumComputer(lineStartValues);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(lineIndex, newValue) {
    this._lines[lineIndex] = newValue;
    if (this._lineStarts) {
      this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
    }
  }
  _acceptDeleteRange(range2) {
    if (range2.startLineNumber === range2.endLineNumber) {
      if (range2.startColumn === range2.endColumn) {
        return;
      }
      this._setLineText(range2.startLineNumber - 1, this._lines[range2.startLineNumber - 1].substring(0, range2.startColumn - 1) + this._lines[range2.startLineNumber - 1].substring(range2.endColumn - 1));
      return;
    }
    this._setLineText(range2.startLineNumber - 1, this._lines[range2.startLineNumber - 1].substring(0, range2.startColumn - 1) + this._lines[range2.endLineNumber - 1].substring(range2.endColumn - 1));
    this._lines.splice(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    if (this._lineStarts) {
      this._lineStarts.removeValues(range2.startLineNumber, range2.endLineNumber - range2.startLineNumber);
    }
  }
  _acceptInsertText(position, insertText) {
    if (insertText.length === 0) {
      return;
    }
    const insertLines = splitLines(insertText);
    if (insertLines.length === 1) {
      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
      return;
    }
    insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
    this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
    const newLengths = new Uint32Array(insertLines.length - 1);
    for (let i = 1; i < insertLines.length; i++) {
      this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
      newLengths[i - 1] = insertLines[i].length + this._eol.length;
    }
    if (this._lineStarts) {
      this._lineStarts.insertValues(position.lineNumber, newLengths);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
var Uint8Matrix = class {
  constructor(rows, cols, defaultValue) {
    const data = new Uint8Array(rows * cols);
    for (let i = 0, len = rows * cols; i < len; i++) {
      data[i] = defaultValue;
    }
    this._data = data;
    this.rows = rows;
    this.cols = cols;
  }
  get(row, col) {
    return this._data[row * this.cols + col];
  }
  set(row, col, value) {
    this._data[row * this.cols + col] = value;
  }
};
var StateMachine = class {
  constructor(edges) {
    let maxCharCode = 0;
    let maxState = 0;
    for (let i = 0, len = edges.length; i < len; i++) {
      const [from, chCode, to] = edges[i];
      if (chCode > maxCharCode) {
        maxCharCode = chCode;
      }
      if (from > maxState) {
        maxState = from;
      }
      if (to > maxState) {
        maxState = to;
      }
    }
    maxCharCode++;
    maxState++;
    const states = new Uint8Matrix(
      maxState,
      maxCharCode,
      0
      /* State.Invalid */
    );
    for (let i = 0, len = edges.length; i < len; i++) {
      const [from, chCode, to] = edges[i];
      states.set(from, chCode, to);
    }
    this._states = states;
    this._maxCharCode = maxCharCode;
  }
  nextState(currentState, chCode) {
    if (chCode < 0 || chCode >= this._maxCharCode) {
      return 0;
    }
    return this._states.get(currentState, chCode);
  }
};
var _stateMachine = null;
function getStateMachine() {
  if (_stateMachine === null) {
    _stateMachine = new StateMachine([
      [
        1,
        104,
        2
        /* State.H */
      ],
      [
        1,
        72,
        2
        /* State.H */
      ],
      [
        1,
        102,
        6
        /* State.F */
      ],
      [
        1,
        70,
        6
        /* State.F */
      ],
      [
        2,
        116,
        3
        /* State.HT */
      ],
      [
        2,
        84,
        3
        /* State.HT */
      ],
      [
        3,
        116,
        4
        /* State.HTT */
      ],
      [
        3,
        84,
        4
        /* State.HTT */
      ],
      [
        4,
        112,
        5
        /* State.HTTP */
      ],
      [
        4,
        80,
        5
        /* State.HTTP */
      ],
      [
        5,
        115,
        9
        /* State.BeforeColon */
      ],
      [
        5,
        83,
        9
        /* State.BeforeColon */
      ],
      [
        5,
        58,
        10
        /* State.AfterColon */
      ],
      [
        6,
        105,
        7
        /* State.FI */
      ],
      [
        6,
        73,
        7
        /* State.FI */
      ],
      [
        7,
        108,
        8
        /* State.FIL */
      ],
      [
        7,
        76,
        8
        /* State.FIL */
      ],
      [
        8,
        101,
        9
        /* State.BeforeColon */
      ],
      [
        8,
        69,
        9
        /* State.BeforeColon */
      ],
      [
        9,
        58,
        10
        /* State.AfterColon */
      ],
      [
        10,
        47,
        11
        /* State.AlmostThere */
      ],
      [
        11,
        47,
        12
        /* State.End */
      ]
    ]);
  }
  return _stateMachine;
}
var _classifier = null;
function getClassifier() {
  if (_classifier === null) {
    _classifier = new CharacterClassifier(
      0
      /* CharacterClass.None */
    );
    const FORCE_TERMINATION_CHARACTERS = ` 	<>'"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…`;
    for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
      _classifier.set(
        FORCE_TERMINATION_CHARACTERS.charCodeAt(i),
        1
        /* CharacterClass.ForceTermination */
      );
    }
    const CANNOT_END_WITH_CHARACTERS = ".,;:";
    for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
      _classifier.set(
        CANNOT_END_WITH_CHARACTERS.charCodeAt(i),
        2
        /* CharacterClass.CannotEndIn */
      );
    }
  }
  return _classifier;
}
var LinkComputer = class _LinkComputer {
  static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
    let lastIncludedCharIndex = linkEndIndex - 1;
    do {
      const chCode = line.charCodeAt(lastIncludedCharIndex);
      const chClass = classifier.get(chCode);
      if (chClass !== 2) {
        break;
      }
      lastIncludedCharIndex--;
    } while (lastIncludedCharIndex > linkBeginIndex);
    if (linkBeginIndex > 0) {
      const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
      const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
      if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
        lastIncludedCharIndex--;
      }
    }
    return {
      range: {
        startLineNumber: lineNumber,
        startColumn: linkBeginIndex + 1,
        endLineNumber: lineNumber,
        endColumn: lastIncludedCharIndex + 2
      },
      url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
    };
  }
  static computeLinks(model, stateMachine = getStateMachine()) {
    const classifier = getClassifier();
    const result = [];
    for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
      const line = model.getLineContent(i);
      const len = line.length;
      let j = 0;
      let linkBeginIndex = 0;
      let linkBeginChCode = 0;
      let state = 1;
      let hasOpenParens = false;
      let hasOpenSquareBracket = false;
      let inSquareBrackets = false;
      let hasOpenCurlyBracket = false;
      while (j < len) {
        let resetStateMachine = false;
        const chCode = line.charCodeAt(j);
        if (state === 13) {
          let chClass;
          switch (chCode) {
            case 40:
              hasOpenParens = true;
              chClass = 0;
              break;
            case 41:
              chClass = hasOpenParens ? 0 : 1;
              break;
            case 91:
              inSquareBrackets = true;
              hasOpenSquareBracket = true;
              chClass = 0;
              break;
            case 93:
              inSquareBrackets = false;
              chClass = hasOpenSquareBracket ? 0 : 1;
              break;
            case 123:
              hasOpenCurlyBracket = true;
              chClass = 0;
              break;
            case 125:
              chClass = hasOpenCurlyBracket ? 0 : 1;
              break;
            case 39:
            case 34:
            case 96:
              if (linkBeginChCode === chCode) {
                chClass = 1;
              } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                chClass = 0;
              } else {
                chClass = 1;
              }
              break;
            case 42:
              chClass = linkBeginChCode === 42 ? 1 : 0;
              break;
            case 124:
              chClass = linkBeginChCode === 124 ? 1 : 0;
              break;
            case 32:
              chClass = inSquareBrackets ? 0 : 1;
              break;
            default:
              chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
            resetStateMachine = true;
          }
        } else if (state === 12) {
          let chClass;
          if (chCode === 91) {
            hasOpenSquareBracket = true;
            chClass = 0;
          } else {
            chClass = classifier.get(chCode);
          }
          if (chClass === 1) {
            resetStateMachine = true;
          } else {
            state = 13;
          }
        } else {
          state = stateMachine.nextState(state, chCode);
          if (state === 0) {
            resetStateMachine = true;
          }
        }
        if (resetStateMachine) {
          state = 1;
          hasOpenParens = false;
          hasOpenSquareBracket = false;
          hasOpenCurlyBracket = false;
          linkBeginIndex = j + 1;
          linkBeginChCode = chCode;
        }
        j++;
      }
      if (state === 13) {
        result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
      }
    }
    return result;
  }
};
function computeLinks(model) {
  if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
    return [];
  }
  return LinkComputer.computeLinks(model);
}

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
var BasicInplaceReplace = class {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(range1, text1, range2, text2, up) {
    if (range1 && text1) {
      const result = this.doNavigateValueSet(text1, up);
      if (result) {
        return {
          range: range1,
          value: result
        };
      }
    }
    if (range2 && text2) {
      const result = this.doNavigateValueSet(text2, up);
      if (result) {
        return {
          range: range2,
          value: result
        };
      }
    }
    return null;
  }
  doNavigateValueSet(text, up) {
    const numberResult = this.numberReplace(text, up);
    if (numberResult !== null) {
      return numberResult;
    }
    return this.textReplace(text, up);
  }
  numberReplace(value, up) {
    const precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
    let n1 = Number(value);
    const n2 = parseFloat(value);
    if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
      if (n1 === 0 && !up) {
        return null;
      } else {
        n1 = Math.floor(n1 * precision);
        n1 += up ? precision : -precision;
        return String(n1 / precision);
      }
    }
    return null;
  }
  textReplace(value, up) {
    return this.valueSetsReplace(this._defaultValueSet, value, up);
  }
  valueSetsReplace(valueSets, value, up) {
    let result = null;
    for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
      result = this.valueSetReplace(valueSets[i], value, up);
    }
    return result;
  }
  valueSetReplace(valueSet, value, up) {
    let idx = valueSet.indexOf(value);
    if (idx >= 0) {
      idx += up ? 1 : -1;
      if (idx < 0) {
        idx = valueSet.length - 1;
      } else {
        idx %= valueSet.length;
      }
      return valueSet[idx];
    }
    return null;
  }
};
BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();

// node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
var UnicodeTextModelHighlighter = class {
  static computeUnicodeHighlights(model, options, range2) {
    const startLine = range2 ? range2.startLineNumber : 1;
    const endLine = range2 ? range2.endLineNumber : model.getLineCount();
    const codePointHighlighter = new CodePointHighlighter(options);
    const candidates = codePointHighlighter.getCandidateCodePoints();
    let regex;
    if (candidates === "allNonBasicAscii") {
      regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
    } else {
      regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
    }
    const searcher = new Searcher(null, regex);
    const ranges = [];
    let hasMore = false;
    let m;
    let ambiguousCharacterCount = 0;
    let invisibleCharacterCount = 0;
    let nonBasicAsciiCharacterCount = 0;
    forLoop:
      for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
        const lineContent = model.getLineContent(lineNumber);
        const lineLength = lineContent.length;
        searcher.reset(0);
        do {
          m = searcher.next(lineContent);
          if (m) {
            let startIndex = m.index;
            let endIndex = m.index + m[0].length;
            if (startIndex > 0) {
              const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
              if (isHighSurrogate(charCodeBefore)) {
                startIndex--;
              }
            }
            if (endIndex + 1 < lineLength) {
              const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
              if (isHighSurrogate(charCodeBefore)) {
                endIndex++;
              }
            }
            const str = lineContent.substring(startIndex, endIndex);
            let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
            if (word && word.endColumn <= startIndex + 1) {
              word = null;
            }
            const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
            if (highlightReason !== 0) {
              if (highlightReason === 3) {
                ambiguousCharacterCount++;
              } else if (highlightReason === 2) {
                invisibleCharacterCount++;
              } else if (highlightReason === 1) {
                nonBasicAsciiCharacterCount++;
              } else {
                assertNever(highlightReason);
              }
              const MAX_RESULT_LENGTH = 1e3;
              if (ranges.length >= MAX_RESULT_LENGTH) {
                hasMore = true;
                break forLoop;
              }
              ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
            }
          }
        } while (m);
      }
    return {
      ranges,
      hasMore,
      ambiguousCharacterCount,
      invisibleCharacterCount,
      nonBasicAsciiCharacterCount
    };
  }
  static computeUnicodeHighlightReason(char, options) {
    const codePointHighlighter = new CodePointHighlighter(options);
    const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
    switch (reason) {
      case 0:
        return null;
      case 2:
        return {
          kind: 1
          /* UnicodeHighlighterReasonKind.Invisible */
        };
      case 3: {
        const codePoint = char.codePointAt(0);
        const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
        const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
        return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
      }
      case 1:
        return {
          kind: 2
          /* UnicodeHighlighterReasonKind.NonBasicAscii */
        };
    }
  }
};
function buildRegExpCharClassExpr(codePoints, flags) {
  const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
  return src;
}
var CodePointHighlighter = class {
  constructor(options) {
    this.options = options;
    this.allowedCodePoints = new Set(options.allowedCodePoints);
    this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
  }
  getCandidateCodePoints() {
    if (this.options.nonBasicASCII) {
      return "allNonBasicAscii";
    }
    const set = /* @__PURE__ */ new Set();
    if (this.options.invisibleCharacters) {
      for (const cp of InvisibleCharacters.codePoints) {
        if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
          set.add(cp);
        }
      }
    }
    if (this.options.ambiguousCharacters) {
      for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
        set.add(cp);
      }
    }
    for (const cp of this.allowedCodePoints) {
      set.delete(cp);
    }
    return set;
  }
  shouldHighlightNonBasicASCII(character, wordContext) {
    const codePoint = character.codePointAt(0);
    if (this.allowedCodePoints.has(codePoint)) {
      return 0;
    }
    if (this.options.nonBasicASCII) {
      return 1;
    }
    let hasBasicASCIICharacters = false;
    let hasNonConfusableNonBasicAsciiCharacter = false;
    if (wordContext) {
      for (const char of wordContext) {
        const codePoint2 = char.codePointAt(0);
        const isBasicASCII2 = isBasicASCII(char);
        hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
        if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
          hasNonConfusableNonBasicAsciiCharacter = true;
        }
      }
    }
    if (
      /* Don't allow mixing weird looking characters with ASCII */
      !hasBasicASCIICharacters && /* Is there an obviously weird looking character? */
      hasNonConfusableNonBasicAsciiCharacter
    ) {
      return 0;
    }
    if (this.options.invisibleCharacters) {
      if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
        return 2;
      }
    }
    if (this.options.ambiguousCharacters) {
      if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
        return 3;
      }
    }
    return 0;
  }
};
function isAllowedInvisibleCharacter(character) {
  return character === " " || character === "\n" || character === "	";
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js
var LinesDiff = class {
  constructor(changes, moves, hitTimeout) {
    this.changes = changes;
    this.moves = moves;
    this.hitTimeout = hitTimeout;
  }
};
var MovedText = class {
  constructor(lineRangeMapping, changes) {
    this.lineRangeMapping = lineRangeMapping;
    this.changes = changes;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js
var LineRangeMapping = class _LineRangeMapping {
  static inverse(mapping, originalLineCount, modifiedLineCount) {
    const result = [];
    let lastOriginalEndLineNumber = 1;
    let lastModifiedEndLineNumber = 1;
    for (const m of mapping) {
      const r2 = new DetailedLineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber), void 0);
      if (!r2.modified.isEmpty) {
        result.push(r2);
      }
      lastOriginalEndLineNumber = m.original.endLineNumberExclusive;
      lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;
    }
    const r = new DetailedLineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), void 0);
    if (!r.modified.isEmpty) {
      result.push(r);
    }
    return result;
  }
  constructor(originalRange, modifiedRange) {
    this.original = originalRange;
    this.modified = modifiedRange;
  }
  toString() {
    return `{${this.original.toString()}->${this.modified.toString()}}`;
  }
  flip() {
    return new _LineRangeMapping(this.modified, this.original);
  }
  join(other) {
    return new _LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));
  }
};
var DetailedLineRangeMapping = class _DetailedLineRangeMapping extends LineRangeMapping {
  constructor(originalRange, modifiedRange, innerChanges) {
    super(originalRange, modifiedRange);
    this.innerChanges = innerChanges;
  }
  flip() {
    var _a;
    return new _DetailedLineRangeMapping(this.modified, this.original, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map((c) => c.flip()));
  }
};
var RangeMapping = class _RangeMapping {
  constructor(originalRange, modifiedRange) {
    this.originalRange = originalRange;
    this.modifiedRange = modifiedRange;
  }
  toString() {
    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
  }
  flip() {
    return new _RangeMapping(this.modifiedRange, this.originalRange);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js
var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
var LegacyLinesDiffComputer = class {
  computeDiff(originalLines, modifiedLines, options) {
    var _a;
    const diffComputer = new DiffComputer(originalLines, modifiedLines, {
      maxComputationTime: options.maxComputationTimeMs,
      shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
      shouldComputeCharChanges: true,
      shouldMakePrettyDiff: true,
      shouldPostProcessCharChanges: true
    });
    const result = diffComputer.computeDiff();
    const changes = [];
    let lastChange = null;
    for (const c of result.changes) {
      let originalRange;
      if (c.originalEndLineNumber === 0) {
        originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);
      } else {
        originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);
      }
      let modifiedRange;
      if (c.modifiedEndLineNumber === 0) {
        modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);
      } else {
        modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
      }
      let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map((c2) => new RangeMapping(new Range(c2.originalStartLineNumber, c2.originalStartColumn, c2.originalEndLineNumber, c2.originalEndColumn), new Range(c2.modifiedStartLineNumber, c2.modifiedStartColumn, c2.modifiedEndLineNumber, c2.modifiedEndColumn))));
      if (lastChange) {
        if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {
          change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
          changes.pop();
        }
      }
      changes.push(change);
      lastChange = change;
    }
    assertFn(() => {
      return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
      m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
    });
    return new LinesDiff(changes, [], result.quitEarly);
  }
};
function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
  return diffAlgo.ComputeDiff(pretty);
}
var LineSequence = class {
  constructor(lines) {
    const startColumns = [];
    const endColumns = [];
    for (let i = 0, length = lines.length; i < length; i++) {
      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
      endColumns[i] = getLastNonBlankColumn(lines[i], 1);
    }
    this.lines = lines;
    this._startColumns = startColumns;
    this._endColumns = endColumns;
  }
  getElements() {
    const elements = [];
    for (let i = 0, len = this.lines.length; i < len; i++) {
      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
    }
    return elements;
  }
  getStrictElement(index) {
    return this.lines[index];
  }
  getStartLineNumber(i) {
    return i + 1;
  }
  getEndLineNumber(i) {
    return i + 1;
  }
  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
    const charCodes = [];
    const lineNumbers = [];
    const columns = [];
    let len = 0;
    for (let index = startIndex; index <= endIndex; index++) {
      const lineContent = this.lines[index];
      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
      for (let col = startColumn; col < endColumn; col++) {
        charCodes[len] = lineContent.charCodeAt(col - 1);
        lineNumbers[len] = index + 1;
        columns[len] = col;
        len++;
      }
      if (!shouldIgnoreTrimWhitespace && index < endIndex) {
        charCodes[len] = 10;
        lineNumbers[len] = index + 1;
        columns[len] = lineContent.length + 1;
        len++;
      }
    }
    return new CharSequence(charCodes, lineNumbers, columns);
  }
};
var CharSequence = class {
  constructor(charCodes, lineNumbers, columns) {
    this._charCodes = charCodes;
    this._lineNumbers = lineNumbers;
    this._columns = columns;
  }
  toString() {
    return "[" + this._charCodes.map((s, idx) => (s === 10 ? "\\n" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
  }
  _assertIndex(index, arr) {
    if (index < 0 || index >= arr.length) {
      throw new Error(`Illegal index`);
    }
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(i) {
    if (i > 0 && i === this._lineNumbers.length) {
      return this.getEndLineNumber(i - 1);
    }
    this._assertIndex(i, this._lineNumbers);
    return this._lineNumbers[i];
  }
  getEndLineNumber(i) {
    if (i === -1) {
      return this.getStartLineNumber(i + 1);
    }
    this._assertIndex(i, this._lineNumbers);
    if (this._charCodes[i] === 10) {
      return this._lineNumbers[i] + 1;
    }
    return this._lineNumbers[i];
  }
  getStartColumn(i) {
    if (i > 0 && i === this._columns.length) {
      return this.getEndColumn(i - 1);
    }
    this._assertIndex(i, this._columns);
    return this._columns[i];
  }
  getEndColumn(i) {
    if (i === -1) {
      return this.getStartColumn(i + 1);
    }
    this._assertIndex(i, this._columns);
    if (this._charCodes[i] === 10) {
      return 1;
    }
    return this._columns[i] + 1;
  }
};
var CharChange = class _CharChange {
  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalStartColumn = originalStartColumn;
    this.originalEndLineNumber = originalEndLineNumber;
    this.originalEndColumn = originalEndColumn;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedStartColumn = modifiedStartColumn;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.modifiedEndColumn = modifiedEndColumn;
  }
  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
    const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
    const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
    const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
    const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
    const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
    const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
    const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
  }
};
function postProcessCharChanges(rawChanges) {
  if (rawChanges.length <= 1) {
    return rawChanges;
  }
  const result = [rawChanges[0]];
  let prevChange = result[0];
  for (let i = 1, len = rawChanges.length; i < len; i++) {
    const currChange = rawChanges[i];
    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
    } else {
      result.push(currChange);
      prevChange = currChange;
    }
  }
  return result;
}
var LineChange = class _LineChange {
  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
    this.originalStartLineNumber = originalStartLineNumber;
    this.originalEndLineNumber = originalEndLineNumber;
    this.modifiedStartLineNumber = modifiedStartLineNumber;
    this.modifiedEndLineNumber = modifiedEndLineNumber;
    this.charChanges = charChanges;
  }
  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
    let originalStartLineNumber;
    let originalEndLineNumber;
    let modifiedStartLineNumber;
    let modifiedEndLineNumber;
    let charChanges = void 0;
    if (diffChange.originalLength === 0) {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
      originalEndLineNumber = 0;
    } else {
      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
    }
    if (diffChange.modifiedLength === 0) {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
      modifiedEndLineNumber = 0;
    } else {
      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
    }
    if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
      if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
        let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
        if (shouldPostProcessCharChanges) {
          rawChanges = postProcessCharChanges(rawChanges);
        }
        charChanges = [];
        for (let i = 0, length = rawChanges.length; i < length; i++) {
          charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
        }
      }
    }
    return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
  }
};
var DiffComputer = class {
  constructor(originalLines, modifiedLines, opts) {
    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
    this.originalLines = originalLines;
    this.modifiedLines = modifiedLines;
    this.original = new LineSequence(originalLines);
    this.modified = new LineSequence(modifiedLines);
    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {
          quitEarly: false,
          changes: []
        };
      }
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: void 0
        }]
      };
    }
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
      return {
        quitEarly: false,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: void 0
        }]
      };
    }
    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
    const rawChanges = diffResult.changes;
    const quitEarly = diffResult.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const lineChanges = [];
      for (let i = 0, length = rawChanges.length; i < length; i++) {
        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      }
      return {
        quitEarly,
        changes: lineChanges
      };
    }
    const result = [];
    let originalLineIndex = 0;
    let modifiedLineIndex = 0;
    for (let i = -1, len = rawChanges.length; i < len; i++) {
      const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
      while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
        const originalLine = this.originalLines[originalLineIndex];
        const modifiedLine = this.modifiedLines[modifiedLineIndex];
        if (originalLine !== modifiedLine) {
          {
            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
            while (originalStartColumn > 1 && modifiedStartColumn > 1) {
              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalStartColumn--;
              modifiedStartColumn--;
            }
            if (originalStartColumn > 1 || modifiedStartColumn > 1) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
            }
          }
          {
            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
            const originalMaxColumn = originalLine.length + 1;
            const modifiedMaxColumn = modifiedLine.length + 1;
            while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
              if (originalChar !== modifiedChar) {
                break;
              }
              originalEndColumn++;
              modifiedEndColumn++;
            }
            if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
            }
          }
        }
        originalLineIndex++;
        modifiedLineIndex++;
      }
      if (nextChange) {
        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        originalLineIndex += nextChange.originalLength;
        modifiedLineIndex += nextChange.modifiedLength;
      }
    }
    return {
      quitEarly,
      changes: result
    };
  }
  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
      return;
    }
    let charChanges = void 0;
    if (this.shouldComputeCharChanges) {
      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
    }
    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
  }
  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
    const len = result.length;
    if (len === 0) {
      return false;
    }
    const prevChange = result[len - 1];
    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
      return false;
    }
    if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
      if (this.shouldComputeCharChanges && prevChange.charChanges) {
        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
      }
      return true;
    }
    if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
      prevChange.originalEndLineNumber = originalLineNumber;
      prevChange.modifiedEndLineNumber = modifiedLineNumber;
      if (this.shouldComputeCharChanges && prevChange.charChanges) {
        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
      }
      return true;
    }
    return false;
  }
};
function getFirstNonBlankColumn(txt, defaultValue) {
  const r = firstNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 1;
}
function getLastNonBlankColumn(txt, defaultValue) {
  const r = lastNonWhitespaceIndex(txt);
  if (r === -1) {
    return defaultValue;
  }
  return r + 2;
}
function createContinueProcessingPredicate(maximumRuntime) {
  if (maximumRuntime === 0) {
    return () => true;
  }
  const startTime = Date.now();
  return () => {
    return Date.now() - startTime < maximumRuntime;
  };
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js
var DiffAlgorithmResult = class _DiffAlgorithmResult {
  static trivial(seq1, seq2) {
    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);
  }
  static trivialTimedOut(seq1, seq2) {
    return new _DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);
  }
  constructor(diffs, hitTimeout) {
    this.diffs = diffs;
    this.hitTimeout = hitTimeout;
  }
};
var SequenceDiff = class _SequenceDiff {
  static invert(sequenceDiffs, doc1Length) {
    const result = [];
    forEachAdjacent(sequenceDiffs, (a, b) => {
      result.push(_SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));
    });
    return result;
  }
  static fromOffsetPairs(start, endExclusive) {
    return new _SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));
  }
  constructor(seq1Range, seq2Range) {
    this.seq1Range = seq1Range;
    this.seq2Range = seq2Range;
  }
  swap() {
    return new _SequenceDiff(this.seq2Range, this.seq1Range);
  }
  toString() {
    return `${this.seq1Range} <-> ${this.seq2Range}`;
  }
  join(other) {
    return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
  }
  delta(offset) {
    if (offset === 0) {
      return this;
    }
    return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
  }
  deltaStart(offset) {
    if (offset === 0) {
      return this;
    }
    return new _SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));
  }
  deltaEnd(offset) {
    if (offset === 0) {
      return this;
    }
    return new _SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));
  }
  intersect(other) {
    const i1 = this.seq1Range.intersect(other.seq1Range);
    const i2 = this.seq2Range.intersect(other.seq2Range);
    if (!i1 || !i2) {
      return void 0;
    }
    return new _SequenceDiff(i1, i2);
  }
  getStarts() {
    return new OffsetPair(this.seq1Range.start, this.seq2Range.start);
  }
  getEndExclusives() {
    return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
  }
};
var OffsetPair = class {
  constructor(offset1, offset2) {
    this.offset1 = offset1;
    this.offset2 = offset2;
  }
  toString() {
    return `${this.offset1} <-> ${this.offset2}`;
  }
};
OffsetPair.zero = new OffsetPair(0, 0);
OffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
var InfiniteTimeout = class {
  isValid() {
    return true;
  }
};
InfiniteTimeout.instance = new InfiniteTimeout();
var DateTimeout = class {
  constructor(timeout2) {
    this.timeout = timeout2;
    this.startTime = Date.now();
    this.valid = true;
    if (timeout2 <= 0) {
      throw new BugIndicatingError("timeout must be positive");
    }
  }
  // Recommendation: Set a log-point `{this.disable()}` in the body
  isValid() {
    const valid = Date.now() - this.startTime < this.timeout;
    if (!valid && this.valid) {
      this.valid = false;
      debugger;
    }
    return this.valid;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js
var Array2D = class {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.array = [];
    this.array = new Array(width * height);
  }
  get(x, y) {
    return this.array[x + y * this.width];
  }
  set(x, y, value) {
    this.array[x + y * this.width] = value;
  }
};
function isSpace(charCode) {
  return charCode === 32 || charCode === 9;
}
var LineRangeFragment = class _LineRangeFragment {
  static getKey(chr) {
    let key = this.chrKeys.get(chr);
    if (key === void 0) {
      key = this.chrKeys.size;
      this.chrKeys.set(chr, key);
    }
    return key;
  }
  constructor(range2, lines, source) {
    this.range = range2;
    this.lines = lines;
    this.source = source;
    this.histogram = [];
    let counter = 0;
    for (let i = range2.startLineNumber - 1; i < range2.endLineNumberExclusive - 1; i++) {
      const line = lines[i];
      for (let j = 0; j < line.length; j++) {
        counter++;
        const chr = line[j];
        const key2 = _LineRangeFragment.getKey(chr);
        this.histogram[key2] = (this.histogram[key2] || 0) + 1;
      }
      counter++;
      const key = _LineRangeFragment.getKey("\n");
      this.histogram[key] = (this.histogram[key] || 0) + 1;
    }
    this.totalCount = counter;
  }
  computeSimilarity(other) {
    var _a, _b;
    let sumDifferences = 0;
    const maxLength = Math.max(this.histogram.length, other.histogram.length);
    for (let i = 0; i < maxLength; i++) {
      sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));
    }
    return 1 - sumDifferences / (this.totalCount + other.totalCount);
  }
};
LineRangeFragment.chrKeys = /* @__PURE__ */ new Map();

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js
var DynamicProgrammingDiffing = class {
  compute(sequence1, sequence2, timeout2 = InfiniteTimeout.instance, equalityScore) {
    if (sequence1.length === 0 || sequence2.length === 0) {
      return DiffAlgorithmResult.trivial(sequence1, sequence2);
    }
    const lcsLengths = new Array2D(sequence1.length, sequence2.length);
    const directions = new Array2D(sequence1.length, sequence2.length);
    const lengths = new Array2D(sequence1.length, sequence2.length);
    for (let s12 = 0; s12 < sequence1.length; s12++) {
      for (let s22 = 0; s22 < sequence2.length; s22++) {
        if (!timeout2.isValid()) {
          return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
        }
        const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);
        const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);
        let extendedSeqScore;
        if (sequence1.getElement(s12) === sequence2.getElement(s22)) {
          if (s12 === 0 || s22 === 0) {
            extendedSeqScore = 0;
          } else {
            extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);
          }
          if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {
            extendedSeqScore += lengths.get(s12 - 1, s22 - 1);
          }
          extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;
        } else {
          extendedSeqScore = -1;
        }
        const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
        if (newValue === extendedSeqScore) {
          const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;
          lengths.set(s12, s22, prevLen + 1);
          directions.set(s12, s22, 3);
        } else if (newValue === horizontalLen) {
          lengths.set(s12, s22, 0);
          directions.set(s12, s22, 1);
        } else if (newValue === verticalLen) {
          lengths.set(s12, s22, 0);
          directions.set(s12, s22, 2);
        }
        lcsLengths.set(s12, s22, newValue);
      }
    }
    const result = [];
    let lastAligningPosS1 = sequence1.length;
    let lastAligningPosS2 = sequence2.length;
    function reportDecreasingAligningPositions(s12, s22) {
      if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {
        result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));
      }
      lastAligningPosS1 = s12;
      lastAligningPosS2 = s22;
    }
    let s1 = sequence1.length - 1;
    let s2 = sequence2.length - 1;
    while (s1 >= 0 && s2 >= 0) {
      if (directions.get(s1, s2) === 3) {
        reportDecreasingAligningPositions(s1, s2);
        s1--;
        s2--;
      } else {
        if (directions.get(s1, s2) === 1) {
          s1--;
        } else {
          s2--;
        }
      }
    }
    reportDecreasingAligningPositions(-1, -1);
    result.reverse();
    return new DiffAlgorithmResult(result, false);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js
var MyersDiffAlgorithm = class {
  compute(seq1, seq2, timeout2 = InfiniteTimeout.instance) {
    if (seq1.length === 0 || seq2.length === 0) {
      return DiffAlgorithmResult.trivial(seq1, seq2);
    }
    const seqX = seq1;
    const seqY = seq2;
    function getXAfterSnake(x, y) {
      while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {
        x++;
        y++;
      }
      return x;
    }
    let d = 0;
    const V = new FastInt32Array();
    V.set(0, getXAfterSnake(0, 0));
    const paths = new FastArrayNegativeIndices();
    paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));
    let k = 0;
    loop:
      while (true) {
        d++;
        if (!timeout2.isValid()) {
          return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);
        }
        const lowerBound = -Math.min(d, seqY.length + d % 2);
        const upperBound = Math.min(d, seqX.length + d % 2);
        for (k = lowerBound; k <= upperBound; k += 2) {
          let step = 0;
          const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1);
          const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1;
          step++;
          const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);
          const y = x - k;
          step++;
          if (x > seqX.length || y > seqY.length) {
            continue;
          }
          const newMaxX = getXAfterSnake(x, y);
          V.set(k, newMaxX);
          const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);
          paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);
          if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {
            break loop;
          }
        }
      }
    let path = paths.get(k);
    const result = [];
    let lastAligningPosS1 = seqX.length;
    let lastAligningPosS2 = seqY.length;
    while (true) {
      const endX = path ? path.x + path.length : 0;
      const endY = path ? path.y + path.length : 0;
      if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
        result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));
      }
      if (!path) {
        break;
      }
      lastAligningPosS1 = path.x;
      lastAligningPosS2 = path.y;
      path = path.prev;
    }
    result.reverse();
    return new DiffAlgorithmResult(result, false);
  }
};
var SnakePath = class {
  constructor(prev, x, y, length) {
    this.prev = prev;
    this.x = x;
    this.y = y;
    this.length = length;
  }
};
var FastInt32Array = class {
  constructor() {
    this.positiveArr = new Int32Array(10);
    this.negativeArr = new Int32Array(10);
  }
  get(idx) {
    if (idx < 0) {
      idx = -idx - 1;
      return this.negativeArr[idx];
    } else {
      return this.positiveArr[idx];
    }
  }
  set(idx, value) {
    if (idx < 0) {
      idx = -idx - 1;
      if (idx >= this.negativeArr.length) {
        const arr = this.negativeArr;
        this.negativeArr = new Int32Array(arr.length * 2);
        this.negativeArr.set(arr);
      }
      this.negativeArr[idx] = value;
    } else {
      if (idx >= this.positiveArr.length) {
        const arr = this.positiveArr;
        this.positiveArr = new Int32Array(arr.length * 2);
        this.positiveArr.set(arr);
      }
      this.positiveArr[idx] = value;
    }
  }
};
var FastArrayNegativeIndices = class {
  constructor() {
    this.positiveArr = [];
    this.negativeArr = [];
  }
  get(idx) {
    if (idx < 0) {
      idx = -idx - 1;
      return this.negativeArr[idx];
    } else {
      return this.positiveArr[idx];
    }
  }
  set(idx, value) {
    if (idx < 0) {
      idx = -idx - 1;
      this.negativeArr[idx] = value;
    } else {
      this.positiveArr[idx] = value;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js
var LinesSliceCharSequence = class {
  constructor(lines, lineRange, considerWhitespaceChanges) {
    this.lines = lines;
    this.considerWhitespaceChanges = considerWhitespaceChanges;
    this.elements = [];
    this.firstCharOffsetByLine = [];
    this.additionalOffsetByLine = [];
    let trimFirstLineFully = false;
    if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {
      lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);
      trimFirstLineFully = true;
    }
    this.lineRange = lineRange;
    this.firstCharOffsetByLine[0] = 0;
    for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {
      let line = lines[i];
      let offset = 0;
      if (trimFirstLineFully) {
        offset = line.length;
        line = "";
        trimFirstLineFully = false;
      } else if (!considerWhitespaceChanges) {
        const trimmedStartLine = line.trimStart();
        offset = line.length - trimmedStartLine.length;
        line = trimmedStartLine.trimEnd();
      }
      this.additionalOffsetByLine.push(offset);
      for (let i2 = 0; i2 < line.length; i2++) {
        this.elements.push(line.charCodeAt(i2));
      }
      if (i < lines.length - 1) {
        this.elements.push("\n".charCodeAt(0));
        this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;
      }
    }
    this.additionalOffsetByLine.push(0);
  }
  toString() {
    return `Slice: "${this.text}"`;
  }
  get text() {
    return this.getText(new OffsetRange(0, this.length));
  }
  getText(range2) {
    return this.elements.slice(range2.start, range2.endExclusive).map((e) => String.fromCharCode(e)).join("");
  }
  getElement(offset) {
    return this.elements[offset];
  }
  get length() {
    return this.elements.length;
  }
  getBoundaryScore(length) {
    const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
    const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
    if (prevCategory === 7 && nextCategory === 8) {
      return 0;
    }
    let score3 = 0;
    if (prevCategory !== nextCategory) {
      score3 += 10;
      if (prevCategory === 0 && nextCategory === 1) {
        score3 += 1;
      }
    }
    score3 += getCategoryBoundaryScore(prevCategory);
    score3 += getCategoryBoundaryScore(nextCategory);
    return score3;
  }
  translateOffset(offset) {
    if (this.lineRange.isEmpty) {
      return new Position(this.lineRange.start + 1, 1);
    }
    const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);
    return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);
  }
  translateRange(range2) {
    return Range.fromPositions(this.translateOffset(range2.start), this.translateOffset(range2.endExclusive));
  }
  /**
   * Finds the word that contains the character at the given offset
   */
  findWordContaining(offset) {
    if (offset < 0 || offset >= this.elements.length) {
      return void 0;
    }
    if (!isWordChar(this.elements[offset])) {
      return void 0;
    }
    let start = offset;
    while (start > 0 && isWordChar(this.elements[start - 1])) {
      start--;
    }
    let end = offset;
    while (end < this.elements.length && isWordChar(this.elements[end])) {
      end++;
    }
    return new OffsetRange(start, end);
  }
  countLinesIn(range2) {
    return this.translateOffset(range2.endExclusive).lineNumber - this.translateOffset(range2.start).lineNumber;
  }
  isStronglyEqual(offset1, offset2) {
    return this.elements[offset1] === this.elements[offset2];
  }
  extendToFullLines(range2) {
    var _a, _b;
    const start = (_a = findLastMonotonous(this.firstCharOffsetByLine, (x) => x <= range2.start)) !== null && _a !== void 0 ? _a : 0;
    const end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, (x) => range2.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;
    return new OffsetRange(start, end);
  }
};
function isWordChar(charCode) {
  return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
}
var score = {
  [
    0
    /* CharBoundaryCategory.WordLower */
  ]: 0,
  [
    1
    /* CharBoundaryCategory.WordUpper */
  ]: 0,
  [
    2
    /* CharBoundaryCategory.WordNumber */
  ]: 0,
  [
    3
    /* CharBoundaryCategory.End */
  ]: 10,
  [
    4
    /* CharBoundaryCategory.Other */
  ]: 2,
  [
    5
    /* CharBoundaryCategory.Separator */
  ]: 3,
  [
    6
    /* CharBoundaryCategory.Space */
  ]: 3,
  [
    7
    /* CharBoundaryCategory.LineBreakCR */
  ]: 10,
  [
    8
    /* CharBoundaryCategory.LineBreakLF */
  ]: 10
};
function getCategoryBoundaryScore(category) {
  return score[category];
}
function getCategory(charCode) {
  if (charCode === 10) {
    return 8;
  } else if (charCode === 13) {
    return 7;
  } else if (isSpace(charCode)) {
    return 6;
  } else if (charCode >= 97 && charCode <= 122) {
    return 0;
  } else if (charCode >= 65 && charCode <= 90) {
    return 1;
  } else if (charCode >= 48 && charCode <= 57) {
    return 2;
  } else if (charCode === -1) {
    return 3;
  } else if (charCode === 44 || charCode === 59) {
    return 5;
  } else {
    return 4;
  }
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js
function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout2) {
  let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout2);
  if (!timeout2.isValid()) {
    return [];
  }
  const filteredChanges = changes.filter((c) => !excludedChanges.has(c));
  const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout2);
  pushMany(moves, unchangedMoves);
  moves = joinCloseConsecutiveMoves(moves);
  moves = moves.filter((current) => {
    const lines = current.original.toOffsetRange().slice(originalLines).map((l) => l.trim());
    const originalText = lines.join("\n");
    return originalText.length >= 15 && countWhere(lines, (l) => l.length >= 2) >= 2;
  });
  moves = removeMovesInSameDiff(changes, moves);
  return moves;
}
function countWhere(arr, predicate) {
  let count = 0;
  for (const t of arr) {
    if (predicate(t)) {
      count++;
    }
  }
  return count;
}
function computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout2) {
  const moves = [];
  const deletions = changes.filter((c) => c.modified.isEmpty && c.original.length >= 3).map((d) => new LineRangeFragment(d.original, originalLines, d));
  const insertions = new Set(changes.filter((c) => c.original.isEmpty && c.modified.length >= 3).map((d) => new LineRangeFragment(d.modified, modifiedLines, d)));
  const excludedChanges = /* @__PURE__ */ new Set();
  for (const deletion of deletions) {
    let highestSimilarity = -1;
    let best;
    for (const insertion of insertions) {
      const similarity = deletion.computeSimilarity(insertion);
      if (similarity > highestSimilarity) {
        highestSimilarity = similarity;
        best = insertion;
      }
    }
    if (highestSimilarity > 0.9 && best) {
      insertions.delete(best);
      moves.push(new LineRangeMapping(deletion.range, best.range));
      excludedChanges.add(deletion.source);
      excludedChanges.add(best.source);
    }
    if (!timeout2.isValid()) {
      return { moves, excludedChanges };
    }
  }
  return { moves, excludedChanges };
}
function computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout2) {
  const moves = [];
  const original3LineHashes = new SetMap();
  for (const change of changes) {
    for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {
      const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;
      original3LineHashes.add(key, { range: new LineRange(i, i + 3) });
    }
  }
  const possibleMappings = [];
  changes.sort(compareBy((c) => c.modified.startLineNumber, numberComparator));
  for (const change of changes) {
    let lastMappings = [];
    for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {
      const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;
      const currentModifiedRange = new LineRange(i, i + 3);
      const nextMappings = [];
      original3LineHashes.forEach(key, ({ range: range2 }) => {
        for (const lastMapping of lastMappings) {
          if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range2.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {
            lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range2.endLineNumberExclusive);
            lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);
            nextMappings.push(lastMapping);
            return;
          }
        }
        const mapping = {
          modifiedLineRange: currentModifiedRange,
          originalLineRange: range2
        };
        possibleMappings.push(mapping);
        nextMappings.push(mapping);
      });
      lastMappings = nextMappings;
    }
    if (!timeout2.isValid()) {
      return [];
    }
  }
  possibleMappings.sort(reverseOrder(compareBy((m) => m.modifiedLineRange.length, numberComparator)));
  const modifiedSet = new LineRangeSet();
  const originalSet = new LineRangeSet();
  for (const mapping of possibleMappings) {
    const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;
    const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);
    const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);
    const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);
    for (const s of modifiedIntersectedSections.ranges) {
      if (s.length < 3) {
        continue;
      }
      const modifiedLineRange = s;
      const originalLineRange = s.delta(-diffOrigToMod);
      moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));
      modifiedSet.addRange(modifiedLineRange);
      originalSet.addRange(originalLineRange);
    }
  }
  moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
  const monotonousChanges = new MonotonousArray(changes);
  for (let i = 0; i < moves.length; i++) {
    const move = moves[i];
    const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber <= move.original.startLineNumber);
    const firstTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber <= move.modified.startLineNumber);
    const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);
    const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous((c) => c.original.startLineNumber < move.original.endLineNumberExclusive);
    const lastTouchingChangeMod = findLastMonotonous(changes, (c) => c.modified.startLineNumber < move.modified.endLineNumberExclusive);
    const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);
    let extendToTop;
    for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {
      const origLine = move.original.startLineNumber - extendToTop - 1;
      const modLine = move.modified.startLineNumber - extendToTop - 1;
      if (origLine > originalLines.length || modLine > modifiedLines.length) {
        break;
      }
      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
        break;
      }
      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout2)) {
        break;
      }
    }
    if (extendToTop > 0) {
      originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));
      modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));
    }
    let extendToBottom;
    for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {
      const origLine = move.original.endLineNumberExclusive + extendToBottom;
      const modLine = move.modified.endLineNumberExclusive + extendToBottom;
      if (origLine > originalLines.length || modLine > modifiedLines.length) {
        break;
      }
      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {
        break;
      }
      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout2)) {
        break;
      }
    }
    if (extendToBottom > 0) {
      originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));
      modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));
    }
    if (extendToTop > 0 || extendToBottom > 0) {
      moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));
    }
  }
  return moves;
}
function areLinesSimilar(line1, line2, timeout2) {
  if (line1.trim() === line2.trim()) {
    return true;
  }
  if (line1.length > 300 && line2.length > 300) {
    return false;
  }
  const myersDiffingAlgorithm = new MyersDiffAlgorithm();
  const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout2);
  let commonNonSpaceCharCount = 0;
  const inverted = SequenceDiff.invert(result.diffs, line1.length);
  for (const seq of inverted) {
    seq.seq1Range.forEach((idx) => {
      if (!isSpace(line1.charCodeAt(idx))) {
        commonNonSpaceCharCount++;
      }
    });
  }
  function countNonWsChars(str) {
    let count = 0;
    for (let i = 0; i < line1.length; i++) {
      if (!isSpace(str.charCodeAt(i))) {
        count++;
      }
    }
    return count;
  }
  const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);
  const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;
  return r;
}
function joinCloseConsecutiveMoves(moves) {
  if (moves.length === 0) {
    return moves;
  }
  moves.sort(compareBy((m) => m.original.startLineNumber, numberComparator));
  const result = [moves[0]];
  for (let i = 1; i < moves.length; i++) {
    const last = result[result.length - 1];
    const current = moves[i];
    const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;
    const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;
    const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;
    if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {
      result[result.length - 1] = last.join(current);
      continue;
    }
    result.push(current);
  }
  return result;
}
function removeMovesInSameDiff(changes, moves) {
  const changesMonotonous = new MonotonousArray(changes);
  moves = moves.filter((m) => {
    const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous((c) => c.original.startLineNumber < m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));
    const diffBeforeEndOfMoveModified = findLastMonotonous(changes, (c) => c.modified.startLineNumber < m.modified.endLineNumberExclusive);
    const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;
    return differentDiffs;
  });
  return moves;
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js
function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
  let result = sequenceDiffs;
  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);
  result = shiftSequenceDiffs(sequence1, sequence2, result);
  return result;
}
function joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {
  if (sequenceDiffs.length === 0) {
    return sequenceDiffs;
  }
  const result = [];
  result.push(sequenceDiffs[0]);
  for (let i = 1; i < sequenceDiffs.length; i++) {
    const prevResult = result[result.length - 1];
    let cur = sequenceDiffs[i];
    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
      const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
      let d;
      for (d = 1; d <= length; d++) {
        if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {
          break;
        }
      }
      d--;
      if (d === length) {
        result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));
        continue;
      }
      cur = cur.delta(-d);
    }
    result.push(cur);
  }
  const result2 = [];
  for (let i = 0; i < result.length - 1; i++) {
    const nextResult = result[i + 1];
    let cur = result[i];
    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
      const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
      let d;
      for (d = 0; d < length; d++) {
        if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) || !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {
          break;
        }
      }
      if (d === length) {
        result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));
        continue;
      }
      if (d > 0) {
        cur = cur.delta(d);
      }
    }
    result2.push(cur);
  }
  if (result.length > 0) {
    result2.push(result[result.length - 1]);
  }
  return result2;
}
function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
    return sequenceDiffs;
  }
  for (let i = 0; i < sequenceDiffs.length; i++) {
    const prevDiff = i > 0 ? sequenceDiffs[i - 1] : void 0;
    const diff = sequenceDiffs[i];
    const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : void 0;
    const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);
    const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);
    if (diff.seq1Range.isEmpty) {
      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
    } else if (diff.seq2Range.isEmpty) {
      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();
    }
  }
  return sequenceDiffs;
}
function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
  const maxShiftLimit = 100;
  let deltaBefore = 1;
  while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
    deltaBefore++;
  }
  deltaBefore--;
  let deltaAfter = 0;
  while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
    deltaAfter++;
  }
  if (deltaBefore === 0 && deltaAfter === 0) {
    return diff;
  }
  let bestDelta = 0;
  let bestScore = -1;
  for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
    const seq2OffsetStart = diff.seq2Range.start + delta;
    const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
    const seq1Offset = diff.seq1Range.start + delta;
    const score3 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
    if (score3 > bestScore) {
      bestScore = score3;
      bestDelta = delta;
    }
  }
  return diff.delta(bestDelta);
}
function removeShortMatches(sequence1, sequence2, sequenceDiffs) {
  const result = [];
  for (const s of sequenceDiffs) {
    const last = result[result.length - 1];
    if (!last) {
      result.push(s);
      continue;
    }
    if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {
      result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));
    } else {
      result.push(s);
    }
  }
  return result;
}
function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {
  const additional = [];
  let lastModifiedWord = void 0;
  function maybePushWordToAdditional() {
    if (!lastModifiedWord) {
      return;
    }
    const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;
    const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;
    if (originalLength1 !== originalLength2) {
    }
    if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {
      additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));
    }
    lastModifiedWord = void 0;
  }
  for (const s of sequenceDiffs) {
    let processWord = function(s1Range, s2Range) {
      var _a, _b, _c, _d;
      if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {
        if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {
          const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);
          const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);
          lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;
          lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;
          lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);
          lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);
        } else {
          maybePushWordToAdditional();
          lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range, s2Range };
        }
      }
      const changedS1 = s1Range.intersect(s.seq1Range);
      const changedS2 = s2Range.intersect(s.seq2Range);
      lastModifiedWord.count++;
      lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;
      lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;
    };
    const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);
    const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);
    const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);
    const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);
    if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {
      processWord(w1Before, w2Before);
    } else {
      if (w1Before && w2Before) {
        processWord(w1Before, w2Before);
      }
      if (w1After && w2After) {
        processWord(w1After, w2After);
      }
    }
  }
  maybePushWordToAdditional();
  const merged = mergeSequenceDiffs(sequenceDiffs, additional);
  return merged;
}
function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
  const result = [];
  while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
    const sd1 = sequenceDiffs1[0];
    const sd2 = sequenceDiffs2[0];
    let next;
    if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
      next = sequenceDiffs1.shift();
    } else {
      next = sequenceDiffs2.shift();
    }
    if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
      result[result.length - 1] = result[result.length - 1].join(next);
    } else {
      result.push(next);
    }
  }
  return result;
}
function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {
  let diffs = sequenceDiffs;
  if (diffs.length === 0) {
    return diffs;
  }
  let counter = 0;
  let shouldRepeat;
  do {
    shouldRepeat = false;
    const result = [
      diffs[0]
    ];
    for (let i = 1; i < diffs.length; i++) {
      let shouldJoinDiffs = function(before, after) {
        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
        const unchangedText = sequence1.getText(unchangedRange);
        const unchangedTextWithoutWs = unchangedText.replace(/\s/g, "");
        if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {
          return true;
        }
        return false;
      };
      const cur = diffs[i];
      const lastResult = result[result.length - 1];
      const shouldJoin = shouldJoinDiffs(lastResult, cur);
      if (shouldJoin) {
        shouldRepeat = true;
        result[result.length - 1] = result[result.length - 1].join(cur);
      } else {
        result.push(cur);
      }
    }
    diffs = result;
  } while (counter++ < 10 && shouldRepeat);
  return diffs;
}
function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {
  let diffs = sequenceDiffs;
  if (diffs.length === 0) {
    return diffs;
  }
  let counter = 0;
  let shouldRepeat;
  do {
    shouldRepeat = false;
    const result = [
      diffs[0]
    ];
    for (let i = 1; i < diffs.length; i++) {
      let shouldJoinDiffs = function(before, after) {
        const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);
        const unchangedLineCount = sequence1.countLinesIn(unchangedRange);
        if (unchangedLineCount > 5 || unchangedRange.length > 500) {
          return false;
        }
        const unchangedText = sequence1.getText(unchangedRange).trim();
        if (unchangedText.length > 20 || unchangedText.split(/\r\n|\r|\n/).length > 1) {
          return false;
        }
        const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);
        const beforeSeq1Length = before.seq1Range.length;
        const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);
        const beforeSeq2Length = before.seq2Range.length;
        const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);
        const afterSeq1Length = after.seq1Range.length;
        const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);
        const afterSeq2Length = after.seq2Range.length;
        const max = 2 * 40 + 50;
        function cap(v) {
          return Math.min(v, max);
        }
        if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > (max ** 1.5) ** 1.5 * 1.3) {
          return true;
        }
        return false;
      };
      const cur = diffs[i];
      const lastResult = result[result.length - 1];
      const shouldJoin = shouldJoinDiffs(lastResult, cur);
      if (shouldJoin) {
        shouldRepeat = true;
        result[result.length - 1] = result[result.length - 1].join(cur);
      } else {
        result.push(cur);
      }
    }
    diffs = result;
  } while (counter++ < 10 && shouldRepeat);
  const newDiffs = [];
  forEachWithNeighbors(diffs, (prev, cur, next) => {
    let newDiff = cur;
    function shouldMarkAsChanged(text) {
      return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;
    }
    const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);
    const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));
    if (shouldMarkAsChanged(prefix)) {
      newDiff = newDiff.deltaStart(-prefix.length);
    }
    const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));
    if (shouldMarkAsChanged(suffix)) {
      newDiff = newDiff.deltaEnd(suffix.length);
    }
    const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);
    const result = newDiff.intersect(availableSpace);
    newDiffs.push(result);
  });
  return newDiffs;
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js
var LineSequence2 = class {
  constructor(trimmedHash, lines) {
    this.trimmedHash = trimmedHash;
    this.lines = lines;
  }
  getElement(offset) {
    return this.trimmedHash[offset];
  }
  get length() {
    return this.trimmedHash.length;
  }
  getBoundaryScore(length) {
    const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);
    const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);
    return 1e3 - (indentationBefore + indentationAfter);
  }
  getText(range2) {
    return this.lines.slice(range2.start, range2.endExclusive).join("\n");
  }
  isStronglyEqual(offset1, offset2) {
    return this.lines[offset1] === this.lines[offset2];
  }
};
function getIndentation(str) {
  let i = 0;
  while (i < str.length && (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {
    i++;
  }
  return i;
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js
var DefaultLinesDiffComputer = class {
  constructor() {
    this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();
    this.myersDiffingAlgorithm = new MyersDiffAlgorithm();
  }
  computeDiff(originalLines, modifiedLines, options) {
    if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {
      return new LinesDiff([], [], false);
    }
    if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {
      return new LinesDiff([
        new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [
          new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))
        ])
      ], [], false);
    }
    const timeout2 = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);
    const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
    const perfectHashes = /* @__PURE__ */ new Map();
    function getOrCreateHash(text) {
      let hash = perfectHashes.get(text);
      if (hash === void 0) {
        hash = perfectHashes.size;
        perfectHashes.set(text, hash);
      }
      return hash;
    }
    const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));
    const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));
    const sequence1 = new LineSequence2(originalLinesHashes, originalLines);
    const sequence2 = new LineSequence2(modifiedLinesHashes, modifiedLines);
    const lineAlignmentResult = (() => {
      if (sequence1.length + sequence2.length < 1700) {
        return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout2, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
      }
      return this.myersDiffingAlgorithm.compute(sequence1, sequence2);
    })();
    let lineAlignments = lineAlignmentResult.diffs;
    let hitTimeout = lineAlignmentResult.hitTimeout;
    lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);
    lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);
    const alignments = [];
    const scanForWhitespaceChanges = (equalLinesCount) => {
      if (!considerWhitespaceChanges) {
        return;
      }
      for (let i = 0; i < equalLinesCount; i++) {
        const seq1Offset = seq1LastStart + i;
        const seq2Offset = seq2LastStart + i;
        if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
          const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout2, considerWhitespaceChanges);
          for (const a of characterDiffs.mappings) {
            alignments.push(a);
          }
          if (characterDiffs.hitTimeout) {
            hitTimeout = true;
          }
        }
      }
    };
    let seq1LastStart = 0;
    let seq2LastStart = 0;
    for (const diff of lineAlignments) {
      assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
      const equalLinesCount = diff.seq1Range.start - seq1LastStart;
      scanForWhitespaceChanges(equalLinesCount);
      seq1LastStart = diff.seq1Range.endExclusive;
      seq2LastStart = diff.seq2Range.endExclusive;
      const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout2, considerWhitespaceChanges);
      if (characterDiffs.hitTimeout) {
        hitTimeout = true;
      }
      for (const a of characterDiffs.mappings) {
        alignments.push(a);
      }
    }
    scanForWhitespaceChanges(originalLines.length - seq1LastStart);
    const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
    let moves = [];
    if (options.computeMoves) {
      moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout2, considerWhitespaceChanges);
    }
    assertFn(() => {
      function validatePosition(pos, lines) {
        if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {
          return false;
        }
        const line = lines[pos.lineNumber - 1];
        if (pos.column < 1 || pos.column > line.length + 1) {
          return false;
        }
        return true;
      }
      function validateRange(range2, lines) {
        if (range2.startLineNumber < 1 || range2.startLineNumber > lines.length + 1) {
          return false;
        }
        if (range2.endLineNumberExclusive < 1 || range2.endLineNumberExclusive > lines.length + 1) {
          return false;
        }
        return true;
      }
      for (const c of changes) {
        if (!c.innerChanges) {
          return false;
        }
        for (const ic of c.innerChanges) {
          const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);
          if (!valid) {
            return false;
          }
        }
        if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {
          return false;
        }
      }
      return true;
    });
    return new LinesDiff(changes, moves, hitTimeout);
  }
  computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout2, considerWhitespaceChanges) {
    const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout2);
    const movesWithDiffs = moves.map((m) => {
      const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout2, considerWhitespaceChanges);
      const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
      return new MovedText(m, mappings);
    });
    return movesWithDiffs;
  }
  refineDiff(originalLines, modifiedLines, diff, timeout2, considerWhitespaceChanges) {
    const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);
    const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
    const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout2) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout2);
    let diffs = diffResult.diffs;
    diffs = optimizeSequenceDiffs(slice1, slice2, diffs);
    diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);
    diffs = removeShortMatches(slice1, slice2, diffs);
    diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);
    const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));
    return {
      mappings: result,
      hitTimeout: diffResult.hitTimeout
    };
  }
};
function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
  const changes = [];
  for (const g of groupAdjacentBy(alignments.map((a) => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified))) {
    const first = g[0];
    const last = g[g.length - 1];
    changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map((a) => a.innerChanges[0])));
  }
  assertFn(() => {
    if (!dontAssertStartLine) {
      if (changes.length > 0 && changes[0].original.startLineNumber !== changes[0].modified.startLineNumber) {
        return false;
      }
    }
    return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
    m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);
  });
  return changes;
}
function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
  let lineStartDelta = 0;
  let lineEndDelta = 0;
  if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
    lineEndDelta = -1;
  }
  if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
    lineStartDelta = 1;
  }
  const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
  const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
  return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
}

// node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js
var linesDiffComputers = {
  getLegacy: () => new LegacyLinesDiffComputer(),
  getDefault: () => new DefaultLinesDiffComputer()
};

// node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js
function _parseCaptureGroups(captureGroups) {
  const values = [];
  for (const captureGroup of captureGroups) {
    const parsedNumber = Number(captureGroup);
    if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\s/g, "") !== "") {
      values.push(parsedNumber);
    }
  }
  return values;
}
function _toIColor(r, g, b, a) {
  return {
    red: r / 255,
    blue: b / 255,
    green: g / 255,
    alpha: a
  };
}
function _findRange(model, match2) {
  const index = match2.index;
  const length = match2[0].length;
  if (!index) {
    return;
  }
  const startPosition = model.positionAt(index);
  const range2 = {
    startLineNumber: startPosition.lineNumber,
    startColumn: startPosition.column,
    endLineNumber: startPosition.lineNumber,
    endColumn: startPosition.column + length
  };
  return range2;
}
function _findHexColorInformation(range2, hexValue) {
  if (!range2) {
    return;
  }
  const parsedHexColor = Color.Format.CSS.parseHex(hexValue);
  if (!parsedHexColor) {
    return;
  }
  return {
    range: range2,
    color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)
  };
}
function _findRGBColorInformation(range2, matches, isAlpha) {
  if (!range2 || matches.length !== 1) {
    return;
  }
  const match2 = matches[0];
  const captureGroups = match2.values();
  const parsedRegex = _parseCaptureGroups(captureGroups);
  return {
    range: range2,
    color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)
  };
}
function _findHSLColorInformation(range2, matches, isAlpha) {
  if (!range2 || matches.length !== 1) {
    return;
  }
  const match2 = matches[0];
  const captureGroups = match2.values();
  const parsedRegex = _parseCaptureGroups(captureGroups);
  const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));
  return {
    range: range2,
    color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)
  };
}
function _findMatches(model, regex) {
  if (typeof model === "string") {
    return [...model.matchAll(regex)];
  } else {
    return model.findMatches(regex);
  }
}
function computeColors(model) {
  const result = [];
  const initialValidationRegex = /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm;
  const initialValidationMatches = _findMatches(model, initialValidationRegex);
  if (initialValidationMatches.length > 0) {
    for (const initialMatch of initialValidationMatches) {
      const initialCaptureGroups = initialMatch.filter((captureGroup) => captureGroup !== void 0);
      const colorScheme = initialCaptureGroups[1];
      const colorParameters = initialCaptureGroups[2];
      if (!colorParameters) {
        continue;
      }
      let colorInformation;
      if (colorScheme === "rgb") {
        const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
      } else if (colorScheme === "rgba") {
        const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
      } else if (colorScheme === "hsl") {
        const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
      } else if (colorScheme === "hsla") {
        const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
      } else if (colorScheme === "#") {
        colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);
      }
      if (colorInformation) {
        result.push(colorInformation);
      }
    }
  }
  return result;
}
function computeDefaultDocumentColors(model) {
  if (!model || typeof model.getValue !== "function" || typeof model.positionAt !== "function") {
    return [];
  }
  return computeColors(model);
}

// node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
var MirrorModel = class extends MirrorTextModel {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  findMatches(regex) {
    const matches = [];
    for (let i = 0; i < this._lines.length; i++) {
      const line = this._lines[i];
      const offsetToAdd = this.offsetAt(new Position(i + 1, 1));
      const iteratorOverMatches = line.matchAll(regex);
      for (const match2 of iteratorOverMatches) {
        if (match2.index || match2.index === 0) {
          match2.index = match2.index + offsetToAdd;
        }
        matches.push(match2);
      }
    }
    return matches;
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(lineNumber) {
    return this._lines[lineNumber - 1];
  }
  getWordAtPosition(position, wordDefinition) {
    const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
    if (wordAtText) {
      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
    }
    return null;
  }
  words(wordDefinition) {
    const lines = this._lines;
    const wordenize = this._wordenize.bind(this);
    let lineNumber = 0;
    let lineText = "";
    let wordRangesIdx = 0;
    let wordRanges = [];
    return {
      *[Symbol.iterator]() {
        while (true) {
          if (wordRangesIdx < wordRanges.length) {
            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
            wordRangesIdx += 1;
            yield value;
          } else {
            if (lineNumber < lines.length) {
              lineText = lines[lineNumber];
              wordRanges = wordenize(lineText, wordDefinition);
              wordRangesIdx = 0;
              lineNumber += 1;
            } else {
              break;
            }
          }
        }
      }
    };
  }
  getLineWords(lineNumber, wordDefinition) {
    const content = this._lines[lineNumber - 1];
    const ranges = this._wordenize(content, wordDefinition);
    const words = [];
    for (const range2 of ranges) {
      words.push({
        word: content.substring(range2.start, range2.end),
        startColumn: range2.start + 1,
        endColumn: range2.end + 1
      });
    }
    return words;
  }
  _wordenize(content, wordDefinition) {
    const result = [];
    let match2;
    wordDefinition.lastIndex = 0;
    while (match2 = wordDefinition.exec(content)) {
      if (match2[0].length === 0) {
        break;
      }
      result.push({ start: match2.index, end: match2.index + match2[0].length });
    }
    return result;
  }
  getValueInRange(range2) {
    range2 = this._validateRange(range2);
    if (range2.startLineNumber === range2.endLineNumber) {
      return this._lines[range2.startLineNumber - 1].substring(range2.startColumn - 1, range2.endColumn - 1);
    }
    const lineEnding = this._eol;
    const startLineIndex = range2.startLineNumber - 1;
    const endLineIndex = range2.endLineNumber - 1;
    const resultLines = [];
    resultLines.push(this._lines[startLineIndex].substring(range2.startColumn - 1));
    for (let i = startLineIndex + 1; i < endLineIndex; i++) {
      resultLines.push(this._lines[i]);
    }
    resultLines.push(this._lines[endLineIndex].substring(0, range2.endColumn - 1));
    return resultLines.join(lineEnding);
  }
  offsetAt(position) {
    position = this._validatePosition(position);
    this._ensureLineStarts();
    return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
  }
  positionAt(offset) {
    offset = Math.floor(offset);
    offset = Math.max(0, offset);
    this._ensureLineStarts();
    const out = this._lineStarts.getIndexOf(offset);
    const lineLength = this._lines[out.index].length;
    return {
      lineNumber: 1 + out.index,
      column: 1 + Math.min(out.remainder, lineLength)
    };
  }
  _validateRange(range2) {
    const start = this._validatePosition({ lineNumber: range2.startLineNumber, column: range2.startColumn });
    const end = this._validatePosition({ lineNumber: range2.endLineNumber, column: range2.endColumn });
    if (start.lineNumber !== range2.startLineNumber || start.column !== range2.startColumn || end.lineNumber !== range2.endLineNumber || end.column !== range2.endColumn) {
      return {
        startLineNumber: start.lineNumber,
        startColumn: start.column,
        endLineNumber: end.lineNumber,
        endColumn: end.column
      };
    }
    return range2;
  }
  _validatePosition(position) {
    if (!Position.isIPosition(position)) {
      throw new Error("bad position");
    }
    let { lineNumber, column } = position;
    let hasChanged = false;
    if (lineNumber < 1) {
      lineNumber = 1;
      column = 1;
      hasChanged = true;
    } else if (lineNumber > this._lines.length) {
      lineNumber = this._lines.length;
      column = this._lines[lineNumber - 1].length + 1;
      hasChanged = true;
    } else {
      const maxCharacter = this._lines[lineNumber - 1].length + 1;
      if (column < 1) {
        column = 1;
        hasChanged = true;
      } else if (column > maxCharacter) {
        column = maxCharacter;
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return position;
    } else {
      return { lineNumber, column };
    }
  }
};
var EditorSimpleWorker = class _EditorSimpleWorker {
  constructor(host, foreignModuleFactory) {
    this._host = host;
    this._models = /* @__PURE__ */ Object.create(null);
    this._foreignModuleFactory = foreignModuleFactory;
    this._foreignModule = null;
  }
  dispose() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  _getModel(uri) {
    return this._models[uri];
  }
  _getModels() {
    const all = [];
    Object.keys(this._models).forEach((key) => all.push(this._models[key]));
    return all;
  }
  acceptNewModel(data) {
    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
  }
  acceptModelChanged(strURL, e) {
    if (!this._models[strURL]) {
      return;
    }
    const model = this._models[strURL];
    model.onEvents(e);
  }
  acceptRemovedModel(strURL) {
    if (!this._models[strURL]) {
      return;
    }
    delete this._models[strURL];
  }
  async computeUnicodeHighlights(url, options, range2) {
    const model = this._getModel(url);
    if (!model) {
      return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
    }
    return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range2);
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  async computeDiff(originalUrl, modifiedUrl, options, algorithm) {
    const original = this._getModel(originalUrl);
    const modified = this._getModel(modifiedUrl);
    if (!original || !modified) {
      return null;
    }
    return _EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
  }
  static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
    const diffAlgorithm = algorithm === "advanced" ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();
    const originalLines = originalTextModel.getLinesContent();
    const modifiedLines = modifiedTextModel.getLinesContent();
    const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
    const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);
    function getLineChanges(changes) {
      return changes.map((m) => {
        var _a;
        return [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a = m.innerChanges) === null || _a === void 0 ? void 0 : _a.map((m2) => [
          m2.originalRange.startLineNumber,
          m2.originalRange.startColumn,
          m2.originalRange.endLineNumber,
          m2.originalRange.endColumn,
          m2.modifiedRange.startLineNumber,
          m2.modifiedRange.startColumn,
          m2.modifiedRange.endLineNumber,
          m2.modifiedRange.endColumn
        ])];
      });
    }
    return {
      identical,
      quitEarly: result.hitTimeout,
      changes: getLineChanges(result.changes),
      moves: result.moves.map((m) => [
        m.lineRangeMapping.original.startLineNumber,
        m.lineRangeMapping.original.endLineNumberExclusive,
        m.lineRangeMapping.modified.startLineNumber,
        m.lineRangeMapping.modified.endLineNumberExclusive,
        getLineChanges(m.changes)
      ])
    };
  }
  static _modelsAreIdentical(original, modified) {
    const originalLineCount = original.getLineCount();
    const modifiedLineCount = modified.getLineCount();
    if (originalLineCount !== modifiedLineCount) {
      return false;
    }
    for (let line = 1; line <= originalLineCount; line++) {
      const originalLine = original.getLineContent(line);
      const modifiedLine = modified.getLineContent(line);
      if (originalLine !== modifiedLine) {
        return false;
      }
    }
    return true;
  }
  async computeMoreMinimalEdits(modelUrl, edits, pretty) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return edits;
    }
    const result = [];
    let lastEol = void 0;
    edits = edits.slice(0).sort((a, b) => {
      if (a.range && b.range) {
        return Range.compareRangesUsingStarts(a.range, b.range);
      }
      const aRng = a.range ? 0 : 1;
      const bRng = b.range ? 0 : 1;
      return aRng - bRng;
    });
    let writeIndex = 0;
    for (let readIndex = 1; readIndex < edits.length; readIndex++) {
      if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {
        edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));
        edits[writeIndex].text += edits[readIndex].text;
      } else {
        writeIndex++;
        edits[writeIndex] = edits[readIndex];
      }
    }
    edits.length = writeIndex + 1;
    for (let { range: range2, text, eol } of edits) {
      if (typeof eol === "number") {
        lastEol = eol;
      }
      if (Range.isEmpty(range2) && !text) {
        continue;
      }
      const original = model.getValueInRange(range2);
      text = text.replace(/\r\n|\n|\r/g, model.eol);
      if (original === text) {
        continue;
      }
      if (Math.max(text.length, original.length) > _EditorSimpleWorker._diffLimit) {
        result.push({ range: range2, text });
        continue;
      }
      const changes = stringDiff(original, text, pretty);
      const editOffset = model.offsetAt(Range.lift(range2).getStartPosition());
      for (const change of changes) {
        const start = model.positionAt(editOffset + change.originalStart);
        const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
        const newEdit = {
          text: text.substr(change.modifiedStart, change.modifiedLength),
          range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
        };
        if (model.getValueInRange(newEdit.range) !== newEdit.text) {
          result.push(newEdit);
        }
      }
    }
    if (typeof lastEol === "number") {
      result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
    }
    return result;
  }
  // ---- END minimal edits ---------------------------------------------------------------
  async computeLinks(modelUrl) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return null;
    }
    return computeLinks(model);
  }
  // --- BEGIN default document colors -----------------------------------------------------------
  async computeDefaultDocumentColors(modelUrl) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return null;
    }
    return computeDefaultDocumentColors(model);
  }
  async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
    const sw = new StopWatch();
    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
    const seen = /* @__PURE__ */ new Set();
    outer:
      for (const url of modelUrls) {
        const model = this._getModel(url);
        if (!model) {
          continue;
        }
        for (const word of model.words(wordDefRegExp)) {
          if (word === leadingWord || !isNaN(Number(word))) {
            continue;
          }
          seen.add(word);
          if (seen.size > _EditorSimpleWorker._suggestionsLimit) {
            break outer;
          }
        }
      }
    return { words: Array.from(seen), duration: sw.elapsed() };
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  async computeWordRanges(modelUrl, range2, wordDef, wordDefFlags) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return /* @__PURE__ */ Object.create(null);
    }
    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
    const result = /* @__PURE__ */ Object.create(null);
    for (let line = range2.startLineNumber; line < range2.endLineNumber; line++) {
      const words = model.getLineWords(line, wordDefRegExp);
      for (const word of words) {
        if (!isNaN(Number(word.word))) {
          continue;
        }
        let array = result[word.word];
        if (!array) {
          array = [];
          result[word.word] = array;
        }
        array.push({
          startLineNumber: line,
          startColumn: word.startColumn,
          endLineNumber: line,
          endColumn: word.endColumn
        });
      }
    }
    return result;
  }
  //#endregion
  async navigateValueSet(modelUrl, range2, up, wordDef, wordDefFlags) {
    const model = this._getModel(modelUrl);
    if (!model) {
      return null;
    }
    const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
    if (range2.startColumn === range2.endColumn) {
      range2 = {
        startLineNumber: range2.startLineNumber,
        startColumn: range2.startColumn,
        endLineNumber: range2.endLineNumber,
        endColumn: range2.endColumn + 1
      };
    }
    const selectionText = model.getValueInRange(range2);
    const wordRange = model.getWordAtPosition({ lineNumber: range2.startLineNumber, column: range2.startColumn }, wordDefRegExp);
    if (!wordRange) {
      return null;
    }
    const word = model.getValueInRange(wordRange);
    const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range2, selectionText, wordRange, word, up);
    return result;
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  loadForeignModule(moduleId, createData, foreignHostMethods) {
    const proxyMethodRequest = (method, args) => {
      return this._host.fhr(method, args);
    };
    const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
    const ctx = {
      host: foreignHost,
      getMirrorModels: () => {
        return this._getModels();
      }
    };
    if (this._foreignModuleFactory) {
      this._foreignModule = this._foreignModuleFactory(ctx, createData);
      return Promise.resolve(getAllMethodNames(this._foreignModule));
    }
    return Promise.reject(new Error(`Unexpected usage`));
  }
  // foreign method request
  fmr(method, args) {
    if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
      return Promise.reject(new Error("Missing requestHandler or method: " + method));
    }
    try {
      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
};
EditorSimpleWorker._diffLimit = 1e5;
EditorSimpleWorker._suggestionsLimit = 1e4;
if (typeof importScripts === "function") {
  globalThis.monaco = createMonacoBaseAPI();
}

// node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js
var ITextResourceConfigurationService = createDecorator("textResourceConfigurationService");
var ITextResourcePropertiesService = createDecorator("textResourcePropertiesService");

// node_modules/monaco-editor/esm/vs/editor/browser/services/editorWorkerService.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1e3;
var STOP_WORKER_DELTA_TIME_MS = 5 * 60 * 1e3;
function canSyncModel(modelService, resource) {
  const model = modelService.getModel(resource);
  if (!model) {
    return false;
  }
  if (model.isTooLargeForSyncing()) {
    return false;
  }
  return true;
}
var EditorWorkerService = class EditorWorkerService2 extends Disposable {
  constructor(modelService, configurationService, logService, languageConfigurationService, languageFeaturesService) {
    super();
    this._modelService = modelService;
    this._workerManager = this._register(new WorkerManager(this._modelService, languageConfigurationService));
    this._logService = logService;
    this._register(languageFeaturesService.linkProvider.register({ language: "*", hasAccessToAllModels: true }, {
      provideLinks: (model, token) => {
        if (!canSyncModel(this._modelService, model.uri)) {
          return Promise.resolve({ links: [] });
        }
        return this._workerManager.withWorker().then((client) => client.computeLinks(model.uri)).then((links) => {
          return links && { links };
        });
      }
    }));
    this._register(languageFeaturesService.completionProvider.register("*", new WordBasedCompletionItemProvider(this._workerManager, configurationService, this._modelService, languageConfigurationService)));
  }
  dispose() {
    super.dispose();
  }
  canComputeUnicodeHighlights(uri) {
    return canSyncModel(this._modelService, uri);
  }
  computedUnicodeHighlights(uri, options, range2) {
    return this._workerManager.withWorker().then((client) => client.computedUnicodeHighlights(uri, options, range2));
  }
  async computeDiff(original, modified, options, algorithm) {
    const result = await this._workerManager.withWorker().then((client) => client.computeDiff(original, modified, options, algorithm));
    if (!result) {
      return null;
    }
    const diff = {
      identical: result.identical,
      quitEarly: result.quitEarly,
      changes: toLineRangeMappings(result.changes),
      moves: result.moves.map((m) => new MovedText(new LineRangeMapping(new LineRange(m[0], m[1]), new LineRange(m[2], m[3])), toLineRangeMappings(m[4])))
    };
    return diff;
    function toLineRangeMappings(changes) {
      return changes.map((c) => {
        var _a;
        return new DetailedLineRangeMapping(new LineRange(c[0], c[1]), new LineRange(c[2], c[3]), (_a = c[4]) === null || _a === void 0 ? void 0 : _a.map((c2) => new RangeMapping(new Range(c2[0], c2[1], c2[2], c2[3]), new Range(c2[4], c2[5], c2[6], c2[7]))));
      });
    }
  }
  computeMoreMinimalEdits(resource, edits, pretty = false) {
    if (isNonEmptyArray(edits)) {
      if (!canSyncModel(this._modelService, resource)) {
        return Promise.resolve(edits);
      }
      const sw = StopWatch.create();
      const result = this._workerManager.withWorker().then((client) => client.computeMoreMinimalEdits(resource, edits, pretty));
      result.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", resource.toString(true), sw.elapsed()));
      return Promise.race([result, timeout(1e3).then(() => edits)]);
    } else {
      return Promise.resolve(void 0);
    }
  }
  canNavigateValueSet(resource) {
    return canSyncModel(this._modelService, resource);
  }
  navigateValueSet(resource, range2, up) {
    return this._workerManager.withWorker().then((client) => client.navigateValueSet(resource, range2, up));
  }
  canComputeWordRanges(resource) {
    return canSyncModel(this._modelService, resource);
  }
  computeWordRanges(resource, range2) {
    return this._workerManager.withWorker().then((client) => client.computeWordRanges(resource, range2));
  }
};
EditorWorkerService = __decorate([
  __param(0, IModelService),
  __param(1, ITextResourceConfigurationService),
  __param(2, ILogService),
  __param(3, ILanguageConfigurationService),
  __param(4, ILanguageFeaturesService)
], EditorWorkerService);
var WordBasedCompletionItemProvider = class {
  constructor(workerManager, configurationService, modelService, languageConfigurationService) {
    this.languageConfigurationService = languageConfigurationService;
    this._debugDisplayName = "wordbasedCompletions";
    this._workerManager = workerManager;
    this._configurationService = configurationService;
    this._modelService = modelService;
  }
  async provideCompletionItems(model, position) {
    const config = this._configurationService.getValue(model.uri, position, "editor");
    if (config.wordBasedSuggestions === "off") {
      return void 0;
    }
    const models = [];
    if (config.wordBasedSuggestions === "currentDocument") {
      if (canSyncModel(this._modelService, model.uri)) {
        models.push(model.uri);
      }
    } else {
      for (const candidate of this._modelService.getModels()) {
        if (!canSyncModel(this._modelService, candidate.uri)) {
          continue;
        }
        if (candidate === model) {
          models.unshift(candidate.uri);
        } else if (config.wordBasedSuggestions === "allDocuments" || candidate.getLanguageId() === model.getLanguageId()) {
          models.push(candidate.uri);
        }
      }
    }
    if (models.length === 0) {
      return void 0;
    }
    const wordDefRegExp = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
    const word = model.getWordAtPosition(position);
    const replace = !word ? Range.fromPositions(position) : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
    const insert = replace.setEndPosition(position.lineNumber, position.column);
    const client = await this._workerManager.withWorker();
    const data = await client.textualSuggest(models, word === null || word === void 0 ? void 0 : word.word, wordDefRegExp);
    if (!data) {
      return void 0;
    }
    return {
      duration: data.duration,
      suggestions: data.words.map((word2) => {
        return {
          kind: 18,
          label: word2,
          insertText: word2,
          range: { insert, replace }
        };
      })
    };
  }
};
var WorkerManager = class extends Disposable {
  constructor(modelService, languageConfigurationService) {
    super();
    this.languageConfigurationService = languageConfigurationService;
    this._modelService = modelService;
    this._editorWorkerClient = null;
    this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime();
    const stopWorkerInterval = this._register(new WindowIntervalTimer());
    stopWorkerInterval.cancelAndSet(() => this._checkStopIdleWorker(), Math.round(STOP_WORKER_DELTA_TIME_MS / 2), $window);
    this._register(this._modelService.onModelRemoved((_) => this._checkStopEmptyWorker()));
  }
  dispose() {
    if (this._editorWorkerClient) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
    super.dispose();
  }
  /**
   * Check if the model service has no more models and stop the worker if that is the case.
   */
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient) {
      return;
    }
    const models = this._modelService.getModels();
    if (models.length === 0) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
  }
  /**
   * Check if the worker has been idle for a while and then stop it.
   */
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient) {
      return;
    }
    const timeSinceLastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime() - this._lastWorkerUsedTime;
    if (timeSinceLastWorkerUsedTime > STOP_WORKER_DELTA_TIME_MS) {
      this._editorWorkerClient.dispose();
      this._editorWorkerClient = null;
    }
  }
  withWorker() {
    this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime();
    if (!this._editorWorkerClient) {
      this._editorWorkerClient = new EditorWorkerClient(this._modelService, false, "editorWorkerService", this.languageConfigurationService);
    }
    return Promise.resolve(this._editorWorkerClient);
  }
};
var EditorModelManager = class extends Disposable {
  constructor(proxy, modelService, keepIdleModels) {
    super();
    this._syncedModels = /* @__PURE__ */ Object.create(null);
    this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null);
    this._proxy = proxy;
    this._modelService = modelService;
    if (!keepIdleModels) {
      const timer = new IntervalTimer();
      timer.cancelAndSet(() => this._checkStopModelSync(), Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));
      this._register(timer);
    }
  }
  dispose() {
    for (const modelUrl in this._syncedModels) {
      dispose(this._syncedModels[modelUrl]);
    }
    this._syncedModels = /* @__PURE__ */ Object.create(null);
    this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null);
    super.dispose();
  }
  ensureSyncedResources(resources, forceLargeModels) {
    for (const resource of resources) {
      const resourceStr = resource.toString();
      if (!this._syncedModels[resourceStr]) {
        this._beginModelSync(resource, forceLargeModels);
      }
      if (this._syncedModels[resourceStr]) {
        this._syncedModelsLastUsedTime[resourceStr] = (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
  _checkStopModelSync() {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const toRemove = [];
    for (const modelUrl in this._syncedModelsLastUsedTime) {
      const elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];
      if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {
        toRemove.push(modelUrl);
      }
    }
    for (const e of toRemove) {
      this._stopModelSync(e);
    }
  }
  _beginModelSync(resource, forceLargeModels) {
    const model = this._modelService.getModel(resource);
    if (!model) {
      return;
    }
    if (!forceLargeModels && model.isTooLargeForSyncing()) {
      return;
    }
    const modelUrl = resource.toString();
    this._proxy.acceptNewModel({
      url: model.uri.toString(),
      lines: model.getLinesContent(),
      EOL: model.getEOL(),
      versionId: model.getVersionId()
    });
    const toDispose = new DisposableStore();
    toDispose.add(model.onDidChangeContent((e) => {
      this._proxy.acceptModelChanged(modelUrl.toString(), e);
    }));
    toDispose.add(model.onWillDispose(() => {
      this._stopModelSync(modelUrl);
    }));
    toDispose.add(toDisposable(() => {
      this._proxy.acceptRemovedModel(modelUrl);
    }));
    this._syncedModels[modelUrl] = toDispose;
  }
  _stopModelSync(modelUrl) {
    const toDispose = this._syncedModels[modelUrl];
    delete this._syncedModels[modelUrl];
    delete this._syncedModelsLastUsedTime[modelUrl];
    dispose(toDispose);
  }
};
var SynchronousWorkerClient = class {
  constructor(instance) {
    this._instance = instance;
    this._proxyObj = Promise.resolve(this._instance);
  }
  dispose() {
    this._instance.dispose();
  }
  getProxyObject() {
    return this._proxyObj;
  }
};
var EditorWorkerHost = class {
  constructor(workerClient) {
    this._workerClient = workerClient;
  }
  // foreign host request
  fhr(method, args) {
    return this._workerClient.fhr(method, args);
  }
};
var EditorWorkerClient = class extends Disposable {
  constructor(modelService, keepIdleModels, label, languageConfigurationService) {
    super();
    this.languageConfigurationService = languageConfigurationService;
    this._disposed = false;
    this._modelService = modelService;
    this._keepIdleModels = keepIdleModels;
    this._workerFactory = new DefaultWorkerFactory(label);
    this._worker = null;
    this._modelManager = null;
  }
  // foreign host request
  fhr(method, args) {
    throw new Error(`Not implemented!`);
  }
  _getOrCreateWorker() {
    if (!this._worker) {
      try {
        this._worker = this._register(new SimpleWorkerClient(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new EditorWorkerHost(this)));
      } catch (err) {
        logOnceWebWorkerWarning(err);
        this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(this), null));
      }
    }
    return this._worker;
  }
  _getProxy() {
    return this._getOrCreateWorker().getProxyObject().then(void 0, (err) => {
      logOnceWebWorkerWarning(err);
      this._worker = new SynchronousWorkerClient(new EditorSimpleWorker(new EditorWorkerHost(this), null));
      return this._getOrCreateWorker().getProxyObject();
    });
  }
  _getOrCreateModelManager(proxy) {
    if (!this._modelManager) {
      this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, this._keepIdleModels));
    }
    return this._modelManager;
  }
  async _withSyncedResources(resources, forceLargeModels = false) {
    if (this._disposed) {
      return Promise.reject(canceled());
    }
    return this._getProxy().then((proxy) => {
      this._getOrCreateModelManager(proxy).ensureSyncedResources(resources, forceLargeModels);
      return proxy;
    });
  }
  computedUnicodeHighlights(uri, options, range2) {
    return this._withSyncedResources([uri]).then((proxy) => {
      return proxy.computeUnicodeHighlights(uri.toString(), options, range2);
    });
  }
  computeDiff(original, modified, options, algorithm) {
    return this._withSyncedResources(
      [original, modified],
      /* forceLargeModels */
      true
    ).then((proxy) => {
      return proxy.computeDiff(original.toString(), modified.toString(), options, algorithm);
    });
  }
  computeMoreMinimalEdits(resource, edits, pretty) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeMoreMinimalEdits(resource.toString(), edits, pretty);
    });
  }
  computeLinks(resource) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeLinks(resource.toString());
    });
  }
  computeDefaultDocumentColors(resource) {
    return this._withSyncedResources([resource]).then((proxy) => {
      return proxy.computeDefaultDocumentColors(resource.toString());
    });
  }
  async textualSuggest(resources, leadingWord, wordDefRegExp) {
    const proxy = await this._withSyncedResources(resources);
    const wordDef = wordDefRegExp.source;
    const wordDefFlags = wordDefRegExp.flags;
    return proxy.textualSuggest(resources.map((r) => r.toString()), leadingWord, wordDef, wordDefFlags);
  }
  computeWordRanges(resource, range2) {
    return this._withSyncedResources([resource]).then((proxy) => {
      const model = this._modelService.getModel(resource);
      if (!model) {
        return Promise.resolve(null);
      }
      const wordDefRegExp = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
      const wordDef = wordDefRegExp.source;
      const wordDefFlags = wordDefRegExp.flags;
      return proxy.computeWordRanges(resource.toString(), range2, wordDef, wordDefFlags);
    });
  }
  navigateValueSet(resource, range2, up) {
    return this._withSyncedResources([resource]).then((proxy) => {
      const model = this._modelService.getModel(resource);
      if (!model) {
        return null;
      }
      const wordDefRegExp = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
      const wordDef = wordDefRegExp.source;
      const wordDefFlags = wordDefRegExp.flags;
      return proxy.navigateValueSet(resource.toString(), range2, up, wordDef, wordDefFlags);
    });
  }
  dispose() {
    super.dispose();
    this._disposed = true;
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/services/webWorker.js
function createWebWorker(modelService, languageConfigurationService, opts) {
  return new MonacoWebWorkerImpl(modelService, languageConfigurationService, opts);
}
var MonacoWebWorkerImpl = class extends EditorWorkerClient {
  constructor(modelService, languageConfigurationService, opts) {
    super(modelService, opts.keepIdleModels || false, opts.label, languageConfigurationService);
    this._foreignModuleId = opts.moduleId;
    this._foreignModuleCreateData = opts.createData || null;
    this._foreignModuleHost = opts.host || null;
    this._foreignProxy = null;
  }
  // foreign host request
  fhr(method, args) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[method] !== "function") {
      return Promise.reject(new Error("Missing method " + method + " or missing main thread foreign host."));
    }
    try {
      return Promise.resolve(this._foreignModuleHost[method].apply(this._foreignModuleHost, args));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  _getForeignProxy() {
    if (!this._foreignProxy) {
      this._foreignProxy = this._getProxy().then((proxy) => {
        const foreignHostMethods = this._foreignModuleHost ? getAllMethodNames(this._foreignModuleHost) : [];
        return proxy.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, foreignHostMethods).then((foreignMethods) => {
          this._foreignModuleCreateData = null;
          const proxyMethodRequest = (method, args) => {
            return proxy.fmr(method, args);
          };
          const createProxyMethod = (method, proxyMethodRequest2) => {
            return function() {
              const args = Array.prototype.slice.call(arguments, 0);
              return proxyMethodRequest2(method, args);
            };
          };
          const foreignProxy = {};
          for (const foreignMethod of foreignMethods) {
            foreignProxy[foreignMethod] = createProxyMethod(foreignMethod, proxyMethodRequest);
          }
          return foreignProxy;
        });
      });
    }
    return this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(resources) {
    return this._withSyncedResources(resources).then((_) => this.getProxy());
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCommon.js
function isFuzzyActionArr(what) {
  return Array.isArray(what);
}
function isFuzzyAction(what) {
  return !isFuzzyActionArr(what);
}
function isString(what) {
  return typeof what === "string";
}
function isIAction(what) {
  return !isString(what);
}
function empty(s) {
  return s ? false : true;
}
function fixCase(lexer, str) {
  return lexer.ignoreCase && str ? str.toLowerCase() : str;
}
function sanitize2(s) {
  return s.replace(/[&<>'"_]/g, "-");
}
function log(lexer, msg) {
  console.log(`${lexer.languageId}: ${msg}`);
}
function createError(lexer, msg) {
  return new Error(`${lexer.languageId}: ${msg}`);
}
function substituteMatches(lexer, str, id, matches, state) {
  const re = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let stateMatches = null;
  return str.replace(re, function(full, sub, dollar, hash, n, s, attr, ofs, total) {
    if (!empty(dollar)) {
      return "$";
    }
    if (!empty(hash)) {
      return fixCase(lexer, id);
    }
    if (!empty(n) && n < matches.length) {
      return fixCase(lexer, matches[n]);
    }
    if (!empty(attr) && lexer && typeof lexer[attr] === "string") {
      return lexer[attr];
    }
    if (stateMatches === null) {
      stateMatches = state.split(".");
      stateMatches.unshift(state);
    }
    if (!empty(s) && s < stateMatches.length) {
      return fixCase(lexer, stateMatches[s]);
    }
    return "";
  });
}
function findRules(lexer, inState) {
  let state = inState;
  while (state && state.length > 0) {
    const rules = lexer.tokenizer[state];
    if (rules) {
      return rules;
    }
    const idx = state.lastIndexOf(".");
    if (idx < 0) {
      state = null;
    } else {
      state = state.substr(0, idx);
    }
  }
  return null;
}
function stateExists(lexer, inState) {
  let state = inState;
  while (state && state.length > 0) {
    const exist = lexer.stateNames[state];
    if (exist) {
      return true;
    }
    const idx = state.lastIndexOf(".");
    if (idx < 0) {
      state = null;
    } else {
      state = state.substr(0, idx);
    }
  }
  return false;
}

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MonarchTokenizer_1;
var CACHE_STACK_DEPTH = 5;
var MonarchStackElementFactory = class {
  static create(parent, state) {
    return this._INSTANCE.create(parent, state);
  }
  constructor(maxCacheDepth) {
    this._maxCacheDepth = maxCacheDepth;
    this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(parent, state) {
    if (parent !== null && parent.depth >= this._maxCacheDepth) {
      return new MonarchStackElement(parent, state);
    }
    let stackElementId = MonarchStackElement.getStackElementId(parent);
    if (stackElementId.length > 0) {
      stackElementId += "|";
    }
    stackElementId += state;
    let result = this._entries[stackElementId];
    if (result) {
      return result;
    }
    result = new MonarchStackElement(parent, state);
    this._entries[stackElementId] = result;
    return result;
  }
};
MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);
var MonarchStackElement = class _MonarchStackElement {
  constructor(parent, state) {
    this.parent = parent;
    this.state = state;
    this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(element) {
    let result = "";
    while (element !== null) {
      if (result.length > 0) {
        result += "|";
      }
      result += element.state;
      element = element.parent;
    }
    return result;
  }
  static _equals(a, b) {
    while (a !== null && b !== null) {
      if (a === b) {
        return true;
      }
      if (a.state !== b.state) {
        return false;
      }
      a = a.parent;
      b = b.parent;
    }
    if (a === null && b === null) {
      return true;
    }
    return false;
  }
  equals(other) {
    return _MonarchStackElement._equals(this, other);
  }
  push(state) {
    return MonarchStackElementFactory.create(this, state);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let result = this;
    while (result.parent) {
      result = result.parent;
    }
    return result;
  }
  switchTo(state) {
    return MonarchStackElementFactory.create(this.parent, state);
  }
};
var EmbeddedLanguageData = class _EmbeddedLanguageData {
  constructor(languageId, state) {
    this.languageId = languageId;
    this.state = state;
  }
  equals(other) {
    return this.languageId === other.languageId && this.state.equals(other.state);
  }
  clone() {
    const stateClone = this.state.clone();
    if (stateClone === this.state) {
      return this;
    }
    return new _EmbeddedLanguageData(this.languageId, this.state);
  }
};
var MonarchLineStateFactory = class {
  static create(stack, embeddedLanguageData) {
    return this._INSTANCE.create(stack, embeddedLanguageData);
  }
  constructor(maxCacheDepth) {
    this._maxCacheDepth = maxCacheDepth;
    this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(stack, embeddedLanguageData) {
    if (embeddedLanguageData !== null) {
      return new MonarchLineState(stack, embeddedLanguageData);
    }
    if (stack !== null && stack.depth >= this._maxCacheDepth) {
      return new MonarchLineState(stack, embeddedLanguageData);
    }
    const stackElementId = MonarchStackElement.getStackElementId(stack);
    let result = this._entries[stackElementId];
    if (result) {
      return result;
    }
    result = new MonarchLineState(stack, null);
    this._entries[stackElementId] = result;
    return result;
  }
};
MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);
var MonarchLineState = class _MonarchLineState {
  constructor(stack, embeddedLanguageData) {
    this.stack = stack;
    this.embeddedLanguageData = embeddedLanguageData;
  }
  clone() {
    const embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null;
    if (embeddedlanguageDataClone === this.embeddedLanguageData) {
      return this;
    }
    return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);
  }
  equals(other) {
    if (!(other instanceof _MonarchLineState)) {
      return false;
    }
    if (!this.stack.equals(other.stack)) {
      return false;
    }
    if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {
      return true;
    }
    if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {
      return false;
    }
    return this.embeddedLanguageData.equals(other.embeddedLanguageData);
  }
};
var MonarchClassicTokensCollector = class {
  constructor() {
    this._tokens = [];
    this._languageId = null;
    this._lastTokenType = null;
    this._lastTokenLanguage = null;
  }
  enterLanguage(languageId) {
    this._languageId = languageId;
  }
  emit(startOffset, type) {
    if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {
      return;
    }
    this._lastTokenType = type;
    this._lastTokenLanguage = this._languageId;
    this._tokens.push(new Token(startOffset, type, this._languageId));
  }
  nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {
    const nestedLanguageId = embeddedLanguageData.languageId;
    const embeddedModeState = embeddedLanguageData.state;
    const nestedLanguageTokenizationSupport = TokenizationRegistry.get(nestedLanguageId);
    if (!nestedLanguageTokenizationSupport) {
      this.enterLanguage(nestedLanguageId);
      this.emit(offsetDelta, "");
      return embeddedModeState;
    }
    const nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);
    if (offsetDelta !== 0) {
      for (const token of nestedResult.tokens) {
        this._tokens.push(new Token(token.offset + offsetDelta, token.type, token.language));
      }
    } else {
      this._tokens = this._tokens.concat(nestedResult.tokens);
    }
    this._lastTokenType = null;
    this._lastTokenLanguage = null;
    this._languageId = null;
    return nestedResult.endState;
  }
  finalize(endState) {
    return new TokenizationResult(this._tokens, endState);
  }
};
var MonarchModernTokensCollector = class _MonarchModernTokensCollector {
  constructor(languageService, theme) {
    this._languageService = languageService;
    this._theme = theme;
    this._prependTokens = null;
    this._tokens = [];
    this._currentLanguageId = 0;
    this._lastTokenMetadata = 0;
  }
  enterLanguage(languageId) {
    this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);
  }
  emit(startOffset, type) {
    const metadata = this._theme.match(this._currentLanguageId, type) | 1024;
    if (this._lastTokenMetadata === metadata) {
      return;
    }
    this._lastTokenMetadata = metadata;
    this._tokens.push(startOffset);
    this._tokens.push(metadata);
  }
  static _merge(a, b, c) {
    const aLen = a !== null ? a.length : 0;
    const bLen = b.length;
    const cLen = c !== null ? c.length : 0;
    if (aLen === 0 && bLen === 0 && cLen === 0) {
      return new Uint32Array(0);
    }
    if (aLen === 0 && bLen === 0) {
      return c;
    }
    if (bLen === 0 && cLen === 0) {
      return a;
    }
    const result = new Uint32Array(aLen + bLen + cLen);
    if (a !== null) {
      result.set(a);
    }
    for (let i = 0; i < bLen; i++) {
      result[aLen + i] = b[i];
    }
    if (c !== null) {
      result.set(c, aLen + bLen);
    }
    return result;
  }
  nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {
    const nestedLanguageId = embeddedLanguageData.languageId;
    const embeddedModeState = embeddedLanguageData.state;
    const nestedLanguageTokenizationSupport = TokenizationRegistry.get(nestedLanguageId);
    if (!nestedLanguageTokenizationSupport) {
      this.enterLanguage(nestedLanguageId);
      this.emit(offsetDelta, "");
      return embeddedModeState;
    }
    const nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);
    if (offsetDelta !== 0) {
      for (let i = 0, len = nestedResult.tokens.length; i < len; i += 2) {
        nestedResult.tokens[i] += offsetDelta;
      }
    }
    this._prependTokens = _MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);
    this._tokens = [];
    this._currentLanguageId = 0;
    this._lastTokenMetadata = 0;
    return nestedResult.endState;
  }
  finalize(endState) {
    return new EncodedTokenizationResult(_MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);
  }
};
var MonarchTokenizer = MonarchTokenizer_1 = class MonarchTokenizer2 extends Disposable {
  constructor(languageService, standaloneThemeService, languageId, lexer, _configurationService) {
    super();
    this._configurationService = _configurationService;
    this._languageService = languageService;
    this._standaloneThemeService = standaloneThemeService;
    this._languageId = languageId;
    this._lexer = lexer;
    this._embeddedLanguages = /* @__PURE__ */ Object.create(null);
    this.embeddedLoaded = Promise.resolve(void 0);
    let emitting = false;
    this._register(TokenizationRegistry.onDidChange((e) => {
      if (emitting) {
        return;
      }
      let isOneOfMyEmbeddedModes = false;
      for (let i = 0, len = e.changedLanguages.length; i < len; i++) {
        const language = e.changedLanguages[i];
        if (this._embeddedLanguages[language]) {
          isOneOfMyEmbeddedModes = true;
          break;
        }
      }
      if (isOneOfMyEmbeddedModes) {
        emitting = true;
        TokenizationRegistry.handleChange([this._languageId]);
        emitting = false;
      }
    }));
    this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: this._languageId
    });
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("editor.maxTokenizationLineLength")) {
        this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
          overrideIdentifier: this._languageId
        });
      }
    }));
  }
  getLoadStatus() {
    const promises = [];
    for (const nestedLanguageId in this._embeddedLanguages) {
      const tokenizationSupport = TokenizationRegistry.get(nestedLanguageId);
      if (tokenizationSupport) {
        if (tokenizationSupport instanceof MonarchTokenizer_1) {
          const nestedModeStatus = tokenizationSupport.getLoadStatus();
          if (nestedModeStatus.loaded === false) {
            promises.push(nestedModeStatus.promise);
          }
        }
        continue;
      }
      if (!TokenizationRegistry.isResolved(nestedLanguageId)) {
        promises.push(TokenizationRegistry.getOrCreate(nestedLanguageId));
      }
    }
    if (promises.length === 0) {
      return {
        loaded: true
      };
    }
    return {
      loaded: false,
      promise: Promise.all(promises).then((_) => void 0)
    };
  }
  getInitialState() {
    const rootState = MonarchStackElementFactory.create(null, this._lexer.start);
    return MonarchLineStateFactory.create(rootState, null);
  }
  tokenize(line, hasEOL, lineState) {
    if (line.length >= this._maxTokenizationLineLength) {
      return nullTokenize(this._languageId, lineState);
    }
    const tokensCollector = new MonarchClassicTokensCollector();
    const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);
    return tokensCollector.finalize(endLineState);
  }
  tokenizeEncoded(line, hasEOL, lineState) {
    if (line.length >= this._maxTokenizationLineLength) {
      return nullTokenizeEncoded(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), lineState);
    }
    const tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);
    const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);
    return tokensCollector.finalize(endLineState);
  }
  _tokenize(line, hasEOL, lineState, collector) {
    if (lineState.embeddedLanguageData) {
      return this._nestedTokenize(line, hasEOL, lineState, 0, collector);
    } else {
      return this._myTokenize(line, hasEOL, lineState, 0, collector);
    }
  }
  _findLeavingNestedLanguageOffset(line, state) {
    let rules = this._lexer.tokenizer[state.stack.state];
    if (!rules) {
      rules = findRules(this._lexer, state.stack.state);
      if (!rules) {
        throw createError(this._lexer, "tokenizer state is not defined: " + state.stack.state);
      }
    }
    let popOffset = -1;
    let hasEmbeddedPopRule = false;
    for (const rule of rules) {
      if (!isIAction(rule.action) || rule.action.nextEmbedded !== "@pop") {
        continue;
      }
      hasEmbeddedPopRule = true;
      let regex = rule.regex;
      const regexSource = rule.regex.source;
      if (regexSource.substr(0, 4) === "^(?:" && regexSource.substr(regexSource.length - 1, 1) === ")") {
        const flags = (regex.ignoreCase ? "i" : "") + (regex.unicode ? "u" : "");
        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);
      }
      const result = line.search(regex);
      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {
        continue;
      }
      if (popOffset === -1 || result < popOffset) {
        popOffset = result;
      }
    }
    if (!hasEmbeddedPopRule) {
      throw createError(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + state.stack.state);
    }
    return popOffset;
  }
  _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {
    const popOffset = this._findLeavingNestedLanguageOffset(line, lineState);
    if (popOffset === -1) {
      const nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);
      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));
    }
    const nestedLanguageLine = line.substring(0, popOffset);
    if (nestedLanguageLine.length > 0) {
      tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);
    }
    const restOfTheLine = line.substring(popOffset);
    return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);
  }
  _safeRuleName(rule) {
    if (rule) {
      return rule.name;
    }
    return "(unknown)";
  }
  _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {
    tokensCollector.enterLanguage(this._languageId);
    const lineWithoutLFLength = lineWithoutLF.length;
    const line = hasEOL && this._lexer.includeLF ? lineWithoutLF + "\n" : lineWithoutLF;
    const lineLength = line.length;
    let embeddedLanguageData = lineState.embeddedLanguageData;
    let stack = lineState.stack;
    let pos = 0;
    let groupMatching = null;
    let forceEvaluation = true;
    while (forceEvaluation || pos < lineLength) {
      const pos0 = pos;
      const stackLen0 = stack.depth;
      const groupLen0 = groupMatching ? groupMatching.groups.length : 0;
      const state = stack.state;
      let matches = null;
      let matched = null;
      let action = null;
      let rule = null;
      let enteringEmbeddedLanguage = null;
      if (groupMatching) {
        matches = groupMatching.matches;
        const groupEntry = groupMatching.groups.shift();
        matched = groupEntry.matched;
        action = groupEntry.action;
        rule = groupMatching.rule;
        if (groupMatching.groups.length === 0) {
          groupMatching = null;
        }
      } else {
        if (!forceEvaluation && pos >= lineLength) {
          break;
        }
        forceEvaluation = false;
        let rules = this._lexer.tokenizer[state];
        if (!rules) {
          rules = findRules(this._lexer, state);
          if (!rules) {
            throw createError(this._lexer, "tokenizer state is not defined: " + state);
          }
        }
        const restOfLine = line.substr(pos);
        for (const rule2 of rules) {
          if (pos === 0 || !rule2.matchOnlyAtLineStart) {
            matches = restOfLine.match(rule2.regex);
            if (matches) {
              matched = matches[0];
              action = rule2.action;
              break;
            }
          }
        }
      }
      if (!matches) {
        matches = [""];
        matched = "";
      }
      if (!action) {
        if (pos < lineLength) {
          matches = [line.charAt(pos)];
          matched = matches[0];
        }
        action = this._lexer.defaultToken;
      }
      if (matched === null) {
        break;
      }
      pos += matched.length;
      while (isFuzzyAction(action) && isIAction(action) && action.test) {
        action = action.test(matched, matches, state, pos === lineLength);
      }
      let result = null;
      if (typeof action === "string" || Array.isArray(action)) {
        result = action;
      } else if (action.group) {
        result = action.group;
      } else if (action.token !== null && action.token !== void 0) {
        if (action.tokenSubst) {
          result = substituteMatches(this._lexer, action.token, matched, matches, state);
        } else {
          result = action.token;
        }
        if (action.nextEmbedded) {
          if (action.nextEmbedded === "@pop") {
            if (!embeddedLanguageData) {
              throw createError(this._lexer, "cannot pop embedded language if not inside one");
            }
            embeddedLanguageData = null;
          } else if (embeddedLanguageData) {
            throw createError(this._lexer, "cannot enter embedded language from within an embedded language");
          } else {
            enteringEmbeddedLanguage = substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);
          }
        }
        if (action.goBack) {
          pos = Math.max(0, pos - action.goBack);
        }
        if (action.switchTo && typeof action.switchTo === "string") {
          let nextState = substituteMatches(this._lexer, action.switchTo, matched, matches, state);
          if (nextState[0] === "@") {
            nextState = nextState.substr(1);
          }
          if (!findRules(this._lexer, nextState)) {
            throw createError(this._lexer, "trying to switch to a state '" + nextState + "' that is undefined in rule: " + this._safeRuleName(rule));
          } else {
            stack = stack.switchTo(nextState);
          }
        } else if (action.transform && typeof action.transform === "function") {
          throw createError(this._lexer, "action.transform not supported");
        } else if (action.next) {
          if (action.next === "@push") {
            if (stack.depth >= this._lexer.maxStack) {
              throw createError(this._lexer, "maximum tokenizer stack size reached: [" + stack.state + "," + stack.parent.state + ",...]");
            } else {
              stack = stack.push(state);
            }
          } else if (action.next === "@pop") {
            if (stack.depth <= 1) {
              throw createError(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(rule));
            } else {
              stack = stack.pop();
            }
          } else if (action.next === "@popall") {
            stack = stack.popall();
          } else {
            let nextState = substituteMatches(this._lexer, action.next, matched, matches, state);
            if (nextState[0] === "@") {
              nextState = nextState.substr(1);
            }
            if (!findRules(this._lexer, nextState)) {
              throw createError(this._lexer, "trying to set a next state '" + nextState + "' that is undefined in rule: " + this._safeRuleName(rule));
            } else {
              stack = stack.push(nextState);
            }
          }
        }
        if (action.log && typeof action.log === "string") {
          log(this._lexer, this._lexer.languageId + ": " + substituteMatches(this._lexer, action.log, matched, matches, state));
        }
      }
      if (result === null) {
        throw createError(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(rule));
      }
      const computeNewStateForEmbeddedLanguage = (enteringEmbeddedLanguage2) => {
        const languageId = this._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage2) || this._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage2) || enteringEmbeddedLanguage2;
        const embeddedLanguageData2 = this._getNestedEmbeddedLanguageData(languageId);
        if (pos < lineLength) {
          const restOfLine = lineWithoutLF.substr(pos);
          return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData2), offsetDelta + pos, tokensCollector);
        } else {
          return MonarchLineStateFactory.create(stack, embeddedLanguageData2);
        }
      };
      if (Array.isArray(result)) {
        if (groupMatching && groupMatching.groups.length > 0) {
          throw createError(this._lexer, "groups cannot be nested: " + this._safeRuleName(rule));
        }
        if (matches.length !== result.length + 1) {
          throw createError(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(rule));
        }
        let totalLen = 0;
        for (let i = 1; i < matches.length; i++) {
          totalLen += matches[i].length;
        }
        if (totalLen !== matched.length) {
          throw createError(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(rule));
        }
        groupMatching = {
          rule,
          matches,
          groups: []
        };
        for (let i = 0; i < result.length; i++) {
          groupMatching.groups[i] = {
            action: result[i],
            matched: matches[i + 1]
          };
        }
        pos -= matched.length;
        continue;
      } else {
        if (result === "@rematch") {
          pos -= matched.length;
          matched = "";
          matches = null;
          result = "";
          if (enteringEmbeddedLanguage !== null) {
            return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);
          }
        }
        if (matched.length === 0) {
          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {
            continue;
          } else {
            throw createError(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(rule));
          }
        }
        let tokenType = null;
        if (isString(result) && result.indexOf("@brackets") === 0) {
          const rest = result.substr("@brackets".length);
          const bracket = findBracket(this._lexer, matched);
          if (!bracket) {
            throw createError(this._lexer, "@brackets token returned but no bracket defined as: " + matched);
          }
          tokenType = sanitize2(bracket.token + rest);
        } else {
          const token = result === "" ? "" : result + this._lexer.tokenPostfix;
          tokenType = sanitize2(token);
        }
        if (pos0 < lineWithoutLFLength) {
          tokensCollector.emit(pos0 + offsetDelta, tokenType);
        }
      }
      if (enteringEmbeddedLanguage !== null) {
        return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);
      }
    }
    return MonarchLineStateFactory.create(stack, embeddedLanguageData);
  }
  _getNestedEmbeddedLanguageData(languageId) {
    if (!this._languageService.isRegisteredLanguageId(languageId)) {
      return new EmbeddedLanguageData(languageId, NullState);
    }
    if (languageId !== this._languageId) {
      this._languageService.requestBasicLanguageFeatures(languageId);
      TokenizationRegistry.getOrCreate(languageId);
      this._embeddedLanguages[languageId] = true;
    }
    const tokenizationSupport = TokenizationRegistry.get(languageId);
    if (tokenizationSupport) {
      return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());
    }
    return new EmbeddedLanguageData(languageId, NullState);
  }
};
MonarchTokenizer = MonarchTokenizer_1 = __decorate2([
  __param2(4, IConfigurationService)
], MonarchTokenizer);
function findBracket(lexer, matched) {
  if (!matched) {
    return null;
  }
  matched = fixCase(lexer, matched);
  const brackets = lexer.brackets;
  for (const bracket of brackets) {
    if (bracket.open === matched) {
      return {
        token: bracket.token,
        bracketType: 1
        /* monarchCommon.MonarchBracket.Open */
      };
    } else if (bracket.close === matched) {
      return {
        token: bracket.token,
        bracketType: -1
        /* monarchCommon.MonarchBracket.Close */
      };
    }
  }
  return null;
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/colorizer.js
var ttPolicy2 = createTrustedTypesPolicy("standaloneColorizer", { createHTML: (value) => value });
var Colorizer = class {
  static colorizeElement(themeService, languageService, domNode, options) {
    options = options || {};
    const theme = options.theme || "vs";
    const mimeType = options.mimeType || domNode.getAttribute("lang") || domNode.getAttribute("data-lang");
    if (!mimeType) {
      console.error("Mode not detected");
      return Promise.resolve();
    }
    const languageId = languageService.getLanguageIdByMimeType(mimeType) || mimeType;
    themeService.setTheme(theme);
    const text = domNode.firstChild ? domNode.firstChild.nodeValue : "";
    domNode.className += " " + theme;
    const render = (str) => {
      var _a;
      const trustedhtml = (_a = ttPolicy2 === null || ttPolicy2 === void 0 ? void 0 : ttPolicy2.createHTML(str)) !== null && _a !== void 0 ? _a : str;
      domNode.innerHTML = trustedhtml;
    };
    return this.colorize(languageService, text || "", languageId, options).then(render, (err) => console.error(err));
  }
  static async colorize(languageService, text, languageId, options) {
    const languageIdCodec = languageService.languageIdCodec;
    let tabSize = 4;
    if (options && typeof options.tabSize === "number") {
      tabSize = options.tabSize;
    }
    if (startsWithUTF8BOM(text)) {
      text = text.substr(1);
    }
    const lines = splitLines(text);
    if (!languageService.isRegisteredLanguageId(languageId)) {
      return _fakeColorize(lines, tabSize, languageIdCodec);
    }
    const tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);
    if (tokenizationSupport) {
      return _colorize(lines, tabSize, tokenizationSupport, languageIdCodec);
    }
    return _fakeColorize(lines, tabSize, languageIdCodec);
  }
  static colorizeLine(line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize = 4) {
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);
    const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII2, mightContainRTL);
    const renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII2, containsRTL, 0, tokens, [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    return renderResult.html;
  }
  static colorizeModelLine(model, lineNumber, tabSize = 4) {
    const content = model.getLineContent(lineNumber);
    model.tokenization.forceTokenization(lineNumber);
    const tokens = model.tokenization.getLineTokens(lineNumber);
    const inflatedTokens = tokens.inflate();
    return this.colorizeLine(content, model.mightContainNonBasicASCII(), model.mightContainRTL(), inflatedTokens, tabSize);
  }
};
function _colorize(lines, tabSize, tokenizationSupport, languageIdCodec) {
  return new Promise((c, e) => {
    const execute = () => {
      const result = _actualColorize(lines, tabSize, tokenizationSupport, languageIdCodec);
      if (tokenizationSupport instanceof MonarchTokenizer) {
        const status = tokenizationSupport.getLoadStatus();
        if (status.loaded === false) {
          status.promise.then(execute, e);
          return;
        }
      }
      c(result);
    };
    execute();
  });
}
function _fakeColorize(lines, tabSize, languageIdCodec) {
  let html = [];
  const defaultMetadata = (0 << 11 | 1 << 15 | 2 << 24) >>> 0;
  const tokens = new Uint32Array(2);
  tokens[0] = 0;
  tokens[1] = defaultMetadata;
  for (let i = 0, length = lines.length; i < length; i++) {
    const line = lines[i];
    tokens[0] = line.length;
    const lineTokens = new LineTokens(tokens, line, languageIdCodec);
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(
      line,
      /* check for basic ASCII */
      true
    );
    const containsRTL = ViewLineRenderingData.containsRTL(
      line,
      isBasicASCII2,
      /* check for RTL */
      true
    );
    const renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII2, containsRTL, 0, lineTokens, [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    html = html.concat(renderResult.html);
    html.push("<br/>");
  }
  return html.join("");
}
function _actualColorize(lines, tabSize, tokenizationSupport, languageIdCodec) {
  let html = [];
  let state = tokenizationSupport.getInitialState();
  for (let i = 0, length = lines.length; i < length; i++) {
    const line = lines[i];
    const tokenizeResult = tokenizationSupport.tokenizeEncoded(line, true, state);
    LineTokens.convertToEndOffset(tokenizeResult.tokens, line.length);
    const lineTokens = new LineTokens(tokenizeResult.tokens, line, languageIdCodec);
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(
      line,
      /* check for basic ASCII */
      true
    );
    const containsRTL = ViewLineRenderingData.containsRTL(
      line,
      isBasicASCII2,
      /* check for RTL */
      true
    );
    const renderResult = renderViewLine2(new RenderLineInput(false, true, line, false, isBasicASCII2, containsRTL, 0, lineTokens.inflate(), [], tabSize, 0, 0, 0, 0, -1, "none", false, false, null));
    html = html.concat(renderResult.html);
    html.push("<br/>");
    state = tokenizeResult.endState;
  }
  return html.join("");
}

// node_modules/monaco-editor/esm/vs/editor/browser/services/abstractCodeEditorService.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AbstractCodeEditorService = class AbstractCodeEditorService2 extends Disposable {
  constructor(_themeService) {
    super();
    this._themeService = _themeService;
    this._onWillCreateCodeEditor = this._register(new Emitter());
    this._onCodeEditorAdd = this._register(new Emitter());
    this.onCodeEditorAdd = this._onCodeEditorAdd.event;
    this._onCodeEditorRemove = this._register(new Emitter());
    this.onCodeEditorRemove = this._onCodeEditorRemove.event;
    this._onWillCreateDiffEditor = this._register(new Emitter());
    this._onDiffEditorAdd = this._register(new Emitter());
    this.onDiffEditorAdd = this._onDiffEditorAdd.event;
    this._onDiffEditorRemove = this._register(new Emitter());
    this.onDiffEditorRemove = this._onDiffEditorRemove.event;
    this._decorationOptionProviders = /* @__PURE__ */ new Map();
    this._codeEditorOpenHandlers = new LinkedList();
    this._modelProperties = /* @__PURE__ */ new Map();
    this._codeEditors = /* @__PURE__ */ Object.create(null);
    this._diffEditors = /* @__PURE__ */ Object.create(null);
    this._globalStyleSheet = null;
  }
  willCreateCodeEditor() {
    this._onWillCreateCodeEditor.fire();
  }
  addCodeEditor(editor2) {
    this._codeEditors[editor2.getId()] = editor2;
    this._onCodeEditorAdd.fire(editor2);
  }
  removeCodeEditor(editor2) {
    if (delete this._codeEditors[editor2.getId()]) {
      this._onCodeEditorRemove.fire(editor2);
    }
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((id) => this._codeEditors[id]);
  }
  willCreateDiffEditor() {
    this._onWillCreateDiffEditor.fire();
  }
  addDiffEditor(editor2) {
    this._diffEditors[editor2.getId()] = editor2;
    this._onDiffEditorAdd.fire(editor2);
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((id) => this._diffEditors[id]);
  }
  getFocusedCodeEditor() {
    let editorWithWidgetFocus = null;
    const editors = this.listCodeEditors();
    for (const editor2 of editors) {
      if (editor2.hasTextFocus()) {
        return editor2;
      }
      if (editor2.hasWidgetFocus()) {
        editorWithWidgetFocus = editor2;
      }
    }
    return editorWithWidgetFocus;
  }
  removeDecorationType(key) {
    const provider = this._decorationOptionProviders.get(key);
    if (provider) {
      provider.refCount--;
      if (provider.refCount <= 0) {
        this._decorationOptionProviders.delete(key);
        provider.dispose();
        this.listCodeEditors().forEach((ed) => ed.removeDecorationsByType(key));
      }
    }
  }
  setModelProperty(resource, key, value) {
    const key1 = resource.toString();
    let dest;
    if (this._modelProperties.has(key1)) {
      dest = this._modelProperties.get(key1);
    } else {
      dest = /* @__PURE__ */ new Map();
      this._modelProperties.set(key1, dest);
    }
    dest.set(key, value);
  }
  getModelProperty(resource, key) {
    const key1 = resource.toString();
    if (this._modelProperties.has(key1)) {
      const innerMap = this._modelProperties.get(key1);
      return innerMap.get(key);
    }
    return void 0;
  }
  async openCodeEditor(input, source, sideBySide) {
    for (const handler of this._codeEditorOpenHandlers) {
      const candidate = await handler(input, source, sideBySide);
      if (candidate !== null) {
        return candidate;
      }
    }
    return null;
  }
  registerCodeEditorOpenHandler(handler) {
    const rm = this._codeEditorOpenHandlers.unshift(handler);
    return toDisposable(rm);
  }
};
AbstractCodeEditorService = __decorate3([
  __param3(0, IThemeService)
], AbstractCodeEditorService);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditorService.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneCodeEditorService = class StandaloneCodeEditorService2 extends AbstractCodeEditorService {
  constructor(contextKeyService, themeService) {
    super(themeService);
    this._register(this.onCodeEditorAdd(() => this._checkContextKey()));
    this._register(this.onCodeEditorRemove(() => this._checkContextKey()));
    this._editorIsOpen = contextKeyService.createKey("editorIsOpen", false);
    this._activeCodeEditor = null;
    this._register(this.registerCodeEditorOpenHandler(async (input, source, sideBySide) => {
      if (!source) {
        return null;
      }
      return this.doOpenEditor(source, input);
    }));
  }
  _checkContextKey() {
    let hasCodeEditor = false;
    for (const editor2 of this.listCodeEditors()) {
      if (!editor2.isSimpleWidget) {
        hasCodeEditor = true;
        break;
      }
    }
    this._editorIsOpen.set(hasCodeEditor);
  }
  setActiveCodeEditor(activeCodeEditor) {
    this._activeCodeEditor = activeCodeEditor;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  doOpenEditor(editor2, input) {
    const model = this.findModel(editor2, input.resource);
    if (!model) {
      if (input.resource) {
        const schema = input.resource.scheme;
        if (schema === Schemas.http || schema === Schemas.https) {
          windowOpenNoOpener(input.resource.toString());
          return editor2;
        }
      }
      return null;
    }
    const selection = input.options ? input.options.selection : null;
    if (selection) {
      if (typeof selection.endLineNumber === "number" && typeof selection.endColumn === "number") {
        editor2.setSelection(selection);
        editor2.revealRangeInCenter(
          selection,
          1
          /* ScrollType.Immediate */
        );
      } else {
        const pos = {
          lineNumber: selection.startLineNumber,
          column: selection.startColumn
        };
        editor2.setPosition(pos);
        editor2.revealPositionInCenter(
          pos,
          1
          /* ScrollType.Immediate */
        );
      }
    }
    return editor2;
  }
  findModel(editor2, resource) {
    const model = editor2.getModel();
    if (model && model.uri.toString() !== resource.toString()) {
      return null;
    }
    return model;
  }
};
StandaloneCodeEditorService = __decorate4([
  __param4(0, IContextKeyService),
  __param4(1, IThemeService)
], StandaloneCodeEditorService);
registerSingleton(
  ICodeEditorService,
  StandaloneCodeEditorService,
  0
  /* InstantiationType.Eager */
);

// node_modules/monaco-editor/esm/vs/platform/layout/browser/layoutService.js
var ILayoutService = createDecorator("layoutService");

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneLayoutService.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneLayoutService = class StandaloneLayoutService2 {
  get mainContainer() {
    var _a, _b;
    return (_b = (_a = firstOrDefault(this._codeEditorService.listCodeEditors())) === null || _a === void 0 ? void 0 : _a.getContainerDomNode()) !== null && _b !== void 0 ? _b : mainWindow.document.body;
  }
  get activeContainer() {
    var _a, _b;
    const activeCodeEditor = (_a = this._codeEditorService.getFocusedCodeEditor()) !== null && _a !== void 0 ? _a : this._codeEditorService.getActiveCodeEditor();
    return (_b = activeCodeEditor === null || activeCodeEditor === void 0 ? void 0 : activeCodeEditor.getContainerDomNode()) !== null && _b !== void 0 ? _b : this.mainContainer;
  }
  get mainContainerDimension() {
    return getClientArea(this.mainContainer);
  }
  get activeContainerDimension() {
    return getClientArea(this.activeContainer);
  }
  get containers() {
    return coalesce(this._codeEditorService.listCodeEditors().map((codeEditor) => codeEditor.getContainerDomNode()));
  }
  getContainer() {
    return this.activeContainer;
  }
  focus() {
    var _a;
    (_a = this._codeEditorService.getFocusedCodeEditor()) === null || _a === void 0 ? void 0 : _a.focus();
  }
  constructor(_codeEditorService) {
    this._codeEditorService = _codeEditorService;
    this.onDidLayoutMainContainer = Event.None;
    this.onDidLayoutActiveContainer = Event.None;
    this.onDidLayoutContainer = Event.None;
    this.onDidChangeActiveContainer = Event.None;
    this.onDidAddContainer = Event.None;
    this.mainContainerOffset = { top: 0, quickPickTop: 0 };
    this.activeContainerOffset = { top: 0, quickPickTop: 0 };
  }
};
StandaloneLayoutService = __decorate5([
  __param5(0, ICodeEditorService)
], StandaloneLayoutService);
var EditorScopedLayoutService = class EditorScopedLayoutService2 extends StandaloneLayoutService {
  get mainContainer() {
    return this._container;
  }
  constructor(_container, codeEditorService) {
    super(codeEditorService);
    this._container = _container;
  }
};
EditorScopedLayoutService = __decorate5([
  __param5(1, ICodeEditorService)
], EditorScopedLayoutService);
registerSingleton(
  ILayoutService,
  StandaloneLayoutService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/platform/dialogs/common/dialogs.js
var IDialogService = createDecorator("dialogService");

// node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DEBUG = false;
function getResourceLabel(resource) {
  return resource.scheme === Schemas.file ? resource.fsPath : resource.path;
}
var stackElementCounter = 0;
var ResourceStackElement = class {
  constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {
    this.id = ++stackElementCounter;
    this.type = 0;
    this.actual = actual;
    this.label = actual.label;
    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;
    this.resourceLabel = resourceLabel;
    this.strResource = strResource;
    this.resourceLabels = [this.resourceLabel];
    this.strResources = [this.strResource];
    this.groupId = groupId;
    this.groupOrder = groupOrder;
    this.sourceId = sourceId;
    this.sourceOrder = sourceOrder;
    this.isValid = true;
  }
  setValid(isValid) {
    this.isValid = isValid;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
};
var ResourceReasonPair = class {
  constructor(resourceLabel, reason) {
    this.resourceLabel = resourceLabel;
    this.reason = reason;
  }
};
var RemovedResources = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  createMessage() {
    const externalRemoval = [];
    const noParallelUniverses = [];
    for (const [, element] of this.elements) {
      const dest = element.reason === 0 ? externalRemoval : noParallelUniverses;
      dest.push(element.resourceLabel);
    }
    const messages = [];
    if (externalRemoval.length > 0) {
      messages.push(localize({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", externalRemoval.join(", ")));
    }
    if (noParallelUniverses.length > 0) {
      messages.push(localize({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", noParallelUniverses.join(", ")));
    }
    return messages.join("\n");
  }
  get size() {
    return this.elements.size;
  }
  has(strResource) {
    return this.elements.has(strResource);
  }
  set(strResource, value) {
    this.elements.set(strResource, value);
  }
  delete(strResource) {
    return this.elements.delete(strResource);
  }
};
var WorkspaceStackElement = class {
  constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {
    this.id = ++stackElementCounter;
    this.type = 1;
    this.actual = actual;
    this.label = actual.label;
    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;
    this.resourceLabels = resourceLabels;
    this.strResources = strResources;
    this.groupId = groupId;
    this.groupOrder = groupOrder;
    this.sourceId = sourceId;
    this.sourceOrder = sourceOrder;
    this.removedResources = null;
    this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split === "function";
  }
  removeResource(resourceLabel, strResource, reason) {
    if (!this.removedResources) {
      this.removedResources = new RemovedResources();
    }
    if (!this.removedResources.has(strResource)) {
      this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));
    }
  }
  setValid(resourceLabel, strResource, isValid) {
    if (isValid) {
      if (this.invalidatedResources) {
        this.invalidatedResources.delete(strResource);
        if (this.invalidatedResources.size === 0) {
          this.invalidatedResources = null;
        }
      }
    } else {
      if (!this.invalidatedResources) {
        this.invalidatedResources = new RemovedResources();
      }
      if (!this.invalidatedResources.has(strResource)) {
        this.invalidatedResources.set(strResource, new ResourceReasonPair(
          resourceLabel,
          0
          /* RemovedResourceReason.ExternalRemoval */
        ));
      }
    }
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
};
var ResourceEditStack = class {
  constructor(resourceLabel, strResource) {
    this.resourceLabel = resourceLabel;
    this.strResource = strResource;
    this._past = [];
    this._future = [];
    this.locked = false;
    this.versionId = 1;
  }
  dispose() {
    for (const element of this._past) {
      if (element.type === 1) {
        element.removeResource(
          this.resourceLabel,
          this.strResource,
          0
          /* RemovedResourceReason.ExternalRemoval */
        );
      }
    }
    for (const element of this._future) {
      if (element.type === 1) {
        element.removeResource(
          this.resourceLabel,
          this.strResource,
          0
          /* RemovedResourceReason.ExternalRemoval */
        );
      }
    }
    this.versionId++;
  }
  toString() {
    const result = [];
    result.push(`* ${this.strResource}:`);
    for (let i = 0; i < this._past.length; i++) {
      result.push(`   * [UNDO] ${this._past[i]}`);
    }
    for (let i = this._future.length - 1; i >= 0; i--) {
      result.push(`   * [REDO] ${this._future[i]}`);
    }
    return result.join("\n");
  }
  flushAllElements() {
    this._past = [];
    this._future = [];
    this.versionId++;
  }
  _setElementValidFlag(element, isValid) {
    if (element.type === 1) {
      element.setValid(this.resourceLabel, this.strResource, isValid);
    } else {
      element.setValid(isValid);
    }
  }
  setElementsValidFlag(isValid, filter) {
    for (const element of this._past) {
      if (filter(element.actual)) {
        this._setElementValidFlag(element, isValid);
      }
    }
    for (const element of this._future) {
      if (filter(element.actual)) {
        this._setElementValidFlag(element, isValid);
      }
    }
  }
  pushElement(element) {
    for (const futureElement of this._future) {
      if (futureElement.type === 1) {
        futureElement.removeResource(
          this.resourceLabel,
          this.strResource,
          1
          /* RemovedResourceReason.NoParallelUniverses */
        );
      }
    }
    this._future = [];
    this._past.push(element);
    this.versionId++;
  }
  createSnapshot(resource) {
    const elements = [];
    for (let i = 0, len = this._past.length; i < len; i++) {
      elements.push(this._past[i].id);
    }
    for (let i = this._future.length - 1; i >= 0; i--) {
      elements.push(this._future[i].id);
    }
    return new ResourceEditStackSnapshot(resource, elements);
  }
  restoreSnapshot(snapshot) {
    const snapshotLength = snapshot.elements.length;
    let isOK = true;
    let snapshotIndex = 0;
    let removePastAfter = -1;
    for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {
      const element = this._past[i];
      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {
        isOK = false;
        removePastAfter = 0;
      }
      if (!isOK && element.type === 1) {
        element.removeResource(
          this.resourceLabel,
          this.strResource,
          0
          /* RemovedResourceReason.ExternalRemoval */
        );
      }
    }
    let removeFutureBefore = -1;
    for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {
      const element = this._future[i];
      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {
        isOK = false;
        removeFutureBefore = i;
      }
      if (!isOK && element.type === 1) {
        element.removeResource(
          this.resourceLabel,
          this.strResource,
          0
          /* RemovedResourceReason.ExternalRemoval */
        );
      }
    }
    if (removePastAfter !== -1) {
      this._past = this._past.slice(0, removePastAfter);
    }
    if (removeFutureBefore !== -1) {
      this._future = this._future.slice(removeFutureBefore + 1);
    }
    this.versionId++;
  }
  getElements() {
    const past = [];
    const future = [];
    for (const element of this._past) {
      past.push(element.actual);
    }
    for (const element of this._future) {
      future.push(element.actual);
    }
    return { past, future };
  }
  getClosestPastElement() {
    if (this._past.length === 0) {
      return null;
    }
    return this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    if (this._past.length < 2) {
      return null;
    }
    return this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    if (this._future.length === 0) {
      return null;
    }
    return this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(toRemove, individualMap) {
    for (let j = this._past.length - 1; j >= 0; j--) {
      if (this._past[j] === toRemove) {
        if (individualMap.has(this.strResource)) {
          this._past[j] = individualMap.get(this.strResource);
        } else {
          this._past.splice(j, 1);
        }
        break;
      }
    }
    this.versionId++;
  }
  splitFutureWorkspaceElement(toRemove, individualMap) {
    for (let j = this._future.length - 1; j >= 0; j--) {
      if (this._future[j] === toRemove) {
        if (individualMap.has(this.strResource)) {
          this._future[j] = individualMap.get(this.strResource);
        } else {
          this._future.splice(j, 1);
        }
        break;
      }
    }
    this.versionId++;
  }
  moveBackward(element) {
    this._past.pop();
    this._future.push(element);
    this.versionId++;
  }
  moveForward(element) {
    this._future.pop();
    this._past.push(element);
    this.versionId++;
  }
};
var EditStackSnapshot = class {
  constructor(editStacks) {
    this.editStacks = editStacks;
    this._versionIds = [];
    for (let i = 0, len = this.editStacks.length; i < len; i++) {
      this._versionIds[i] = this.editStacks[i].versionId;
    }
  }
  isValid() {
    for (let i = 0, len = this.editStacks.length; i < len; i++) {
      if (this._versionIds[i] !== this.editStacks[i].versionId) {
        return false;
      }
    }
    return true;
  }
};
var missingEditStack = new ResourceEditStack("", "");
missingEditStack.locked = true;
var UndoRedoService = class UndoRedoService2 {
  constructor(_dialogService, _notificationService) {
    this._dialogService = _dialogService;
    this._notificationService = _notificationService;
    this._editStacks = /* @__PURE__ */ new Map();
    this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(resource) {
    for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {
      if (uriComparisonKeyComputer[0] === resource.scheme) {
        return uriComparisonKeyComputer[1].getComparisonKey(resource);
      }
    }
    return resource.toString();
  }
  _print(label) {
    console.log(`------------------------------------`);
    console.log(`AFTER ${label}: `);
    const str = [];
    for (const element of this._editStacks) {
      str.push(element[1].toString());
    }
    console.log(str.join("\n"));
  }
  pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {
    if (element.type === 0) {
      const resourceLabel = getResourceLabel(element.resource);
      const strResource = this.getUriComparisonKey(element.resource);
      this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));
    } else {
      const seen = /* @__PURE__ */ new Set();
      const resourceLabels = [];
      const strResources = [];
      for (const resource of element.resources) {
        const resourceLabel = getResourceLabel(resource);
        const strResource = this.getUriComparisonKey(resource);
        if (seen.has(strResource)) {
          continue;
        }
        seen.add(strResource);
        resourceLabels.push(resourceLabel);
        strResources.push(strResource);
      }
      if (resourceLabels.length === 1) {
        this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));
      } else {
        this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));
      }
    }
    if (DEBUG) {
      this._print("pushElement");
    }
  }
  _pushElement(element) {
    for (let i = 0, len = element.strResources.length; i < len; i++) {
      const resourceLabel = element.resourceLabels[i];
      const strResource = element.strResources[i];
      let editStack;
      if (this._editStacks.has(strResource)) {
        editStack = this._editStacks.get(strResource);
      } else {
        editStack = new ResourceEditStack(resourceLabel, strResource);
        this._editStacks.set(strResource, editStack);
      }
      editStack.pushElement(element);
    }
  }
  getLastElement(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      if (editStack.hasFutureElements()) {
        return null;
      }
      const closestPastElement = editStack.getClosestPastElement();
      return closestPastElement ? closestPastElement.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(toRemove, ignoreResources) {
    const individualArr = toRemove.actual.split();
    const individualMap = /* @__PURE__ */ new Map();
    for (const _element of individualArr) {
      const resourceLabel = getResourceLabel(_element.resource);
      const strResource = this.getUriComparisonKey(_element.resource);
      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);
      individualMap.set(element.strResource, element);
    }
    for (const strResource of toRemove.strResources) {
      if (ignoreResources && ignoreResources.has(strResource)) {
        continue;
      }
      const editStack = this._editStacks.get(strResource);
      editStack.splitPastWorkspaceElement(toRemove, individualMap);
    }
  }
  _splitFutureWorkspaceElement(toRemove, ignoreResources) {
    const individualArr = toRemove.actual.split();
    const individualMap = /* @__PURE__ */ new Map();
    for (const _element of individualArr) {
      const resourceLabel = getResourceLabel(_element.resource);
      const strResource = this.getUriComparisonKey(_element.resource);
      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);
      individualMap.set(element.strResource, element);
    }
    for (const strResource of toRemove.strResources) {
      if (ignoreResources && ignoreResources.has(strResource)) {
        continue;
      }
      const editStack = this._editStacks.get(strResource);
      editStack.splitFutureWorkspaceElement(toRemove, individualMap);
    }
  }
  removeElements(resource) {
    const strResource = typeof resource === "string" ? resource : this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.dispose();
      this._editStacks.delete(strResource);
    }
    if (DEBUG) {
      this._print("removeElements");
    }
  }
  setElementsValidFlag(resource, isValid, filter) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.setElementsValidFlag(isValid, filter);
    }
    if (DEBUG) {
      this._print("setElementsValidFlag");
    }
  }
  createSnapshot(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.createSnapshot(resource);
    }
    return new ResourceEditStackSnapshot(resource, []);
  }
  restoreSnapshot(snapshot) {
    const strResource = this.getUriComparisonKey(snapshot.resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      editStack.restoreSnapshot(snapshot);
      if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {
        editStack.dispose();
        this._editStacks.delete(strResource);
      }
    }
    if (DEBUG) {
      this._print("restoreSnapshot");
    }
  }
  getElements(resource) {
    const strResource = this.getUriComparisonKey(resource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.getElements();
    }
    return { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(sourceId) {
    if (!sourceId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestPastElement();
      if (!candidate) {
        continue;
      }
      if (candidate.sourceId === sourceId) {
        if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  canUndo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? true : false;
    }
    const strResource = this.getUriComparisonKey(resourceOrSource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.hasPastElements();
    }
    return false;
  }
  _onError(err, element) {
    onUnexpectedError(err);
    for (const strResource of element.strResources) {
      this.removeElements(strResource);
    }
    this._notificationService.error(err);
  }
  _acquireLocks(editStackSnapshot) {
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        throw new Error("Cannot acquire edit stack lock");
      }
    }
    for (const editStack of editStackSnapshot.editStacks) {
      editStack.locked = true;
    }
    return () => {
      for (const editStack of editStackSnapshot.editStacks) {
        editStack.locked = false;
      }
    };
  }
  _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {
    const releaseLocks = this._acquireLocks(editStackSnapshot);
    let result;
    try {
      result = invoke();
    } catch (err) {
      releaseLocks();
      cleanup.dispose();
      return this._onError(err, element);
    }
    if (result) {
      return result.then(() => {
        releaseLocks();
        cleanup.dispose();
        return continuation();
      }, (err) => {
        releaseLocks();
        cleanup.dispose();
        return this._onError(err, element);
      });
    } else {
      releaseLocks();
      cleanup.dispose();
      return continuation();
    }
  }
  async _invokeWorkspacePrepare(element) {
    if (typeof element.actual.prepareUndoRedo === "undefined") {
      return Disposable.None;
    }
    const result = element.actual.prepareUndoRedo();
    if (typeof result === "undefined") {
      return Disposable.None;
    }
    return result;
  }
  _invokeResourcePrepare(element, callback) {
    if (element.actual.type !== 1 || typeof element.actual.prepareUndoRedo === "undefined") {
      return callback(Disposable.None);
    }
    const r = element.actual.prepareUndoRedo();
    if (!r) {
      return callback(Disposable.None);
    }
    if (isDisposable(r)) {
      return callback(r);
    }
    return r.then((disposable) => {
      return callback(disposable);
    });
  }
  _getAffectedEditStacks(element) {
    const affectedEditStacks = [];
    for (const strResource of element.strResources) {
      affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);
    }
    return new EditStackSnapshot(affectedEditStacks);
  }
  _tryToSplitAndUndo(strResource, element, ignoreResources, message) {
    if (element.canSplit()) {
      this._splitPastWorkspaceElement(element, ignoreResources);
      this._notificationService.warn(message);
      return new WorkspaceVerificationError(this._undo(strResource, 0, true));
    } else {
      for (const strResource2 of element.strResources) {
        this.removeElements(strResource2);
      }
      this._notificationService.warn(message);
      return new WorkspaceVerificationError();
    }
  }
  _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
    if (element.removedResources) {
      return this._tryToSplitAndUndo(strResource, element, element.removedResources, localize({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
    }
    if (checkInvalidatedResources && element.invalidatedResources) {
      return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, localize({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
    }
    const cannotUndoDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.getClosestPastElement() !== element) {
        cannotUndoDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotUndoDueToResources.length > 0) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", element.label, cannotUndoDueToResources.join(", ")));
    }
    const cannotLockDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        cannotLockDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotLockDueToResources.length > 0) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(", ")));
    }
    if (!editStackSnapshot.isValid()) {
      return this._tryToSplitAndUndo(strResource, element, null, localize({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    return null;
  }
  _workspaceUndo(strResource, element, undoConfirmed) {
    const affectedEditStacks = this._getAffectedEditStacks(element);
    const verificationError = this._checkWorkspaceUndo(
      strResource,
      element,
      affectedEditStacks,
      /*invalidated resources will be checked after the prepare call*/
      false
    );
    if (verificationError) {
      return verificationError.returnValue;
    }
    return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);
  }
  _isPartOfUndoGroup(element) {
    if (!element.groupId) {
      return false;
    }
    for (const [, editStack] of this._editStacks) {
      const pastElement = editStack.getClosestPastElement();
      if (!pastElement) {
        continue;
      }
      if (pastElement === element) {
        const secondPastElement = editStack.getSecondClosestPastElement();
        if (secondPastElement && secondPastElement.groupId === element.groupId) {
          return true;
        }
      }
      if (pastElement.groupId === element.groupId) {
        return true;
      }
    }
    return false;
  }
  async _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {
    if (element.canSplit() && !this._isPartOfUndoGroup(element)) {
      let UndoChoice;
      (function(UndoChoice2) {
        UndoChoice2[UndoChoice2["All"] = 0] = "All";
        UndoChoice2[UndoChoice2["This"] = 1] = "This";
        UndoChoice2[UndoChoice2["Cancel"] = 2] = "Cancel";
      })(UndoChoice || (UndoChoice = {}));
      const { result } = await this._dialogService.prompt({
        type: severity_default.Info,
        message: localize("confirmWorkspace", "Would you like to undo '{0}' across all files?", element.label),
        buttons: [
          {
            label: localize({ key: "ok", comment: ["{0} denotes a number that is > 1, && denotes a mnemonic"] }, "&&Undo in {0} Files", editStackSnapshot.editStacks.length),
            run: () => UndoChoice.All
          },
          {
            label: localize({ key: "nok", comment: ["&& denotes a mnemonic"] }, "Undo this &&File"),
            run: () => UndoChoice.This
          }
        ],
        cancelButton: {
          run: () => UndoChoice.Cancel
        }
      });
      if (result === UndoChoice.Cancel) {
        return;
      }
      if (result === UndoChoice.This) {
        this._splitPastWorkspaceElement(element, null);
        return this._undo(strResource, 0, true);
      }
      const verificationError1 = this._checkWorkspaceUndo(
        strResource,
        element,
        editStackSnapshot,
        /*invalidated resources will be checked after the prepare call*/
        false
      );
      if (verificationError1) {
        return verificationError1.returnValue;
      }
      undoConfirmed = true;
    }
    let cleanup;
    try {
      cleanup = await this._invokeWorkspacePrepare(element);
    } catch (err) {
      return this._onError(err, element);
    }
    const verificationError2 = this._checkWorkspaceUndo(
      strResource,
      element,
      editStackSnapshot,
      /*now also check that there are no more invalidated resources*/
      true
    );
    if (verificationError2) {
      cleanup.dispose();
      return verificationError2.returnValue;
    }
    for (const editStack of editStackSnapshot.editStacks) {
      editStack.moveBackward(element);
    }
    return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
  }
  _resourceUndo(editStack, element, undoConfirmed) {
    if (!element.isValid) {
      editStack.flushAllElements();
      return;
    }
    if (editStack.locked) {
      const message = localize({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", element.label);
      this._notificationService.warn(message);
      return;
    }
    return this._invokeResourcePrepare(element, (cleanup) => {
      editStack.moveBackward(element);
      return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));
    });
  }
  _findClosestUndoElementInGroup(groupId) {
    if (!groupId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestPastElement();
      if (!candidate) {
        continue;
      }
      if (candidate.groupId === groupId) {
        if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  _continueUndoInGroup(groupId, undoConfirmed) {
    if (!groupId) {
      return;
    }
    const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);
    if (matchedStrResource) {
      return this._undo(matchedStrResource, 0, undoConfirmed);
    }
  }
  undo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : void 0;
    }
    if (typeof resourceOrSource === "string") {
      return this._undo(resourceOrSource, 0, false);
    }
    return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);
  }
  _undo(strResource, sourceId = 0, undoConfirmed) {
    if (!this._editStacks.has(strResource)) {
      return;
    }
    const editStack = this._editStacks.get(strResource);
    const element = editStack.getClosestPastElement();
    if (!element) {
      return;
    }
    if (element.groupId) {
      const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);
      if (element !== matchedElement && matchedStrResource) {
        return this._undo(matchedStrResource, sourceId, undoConfirmed);
      }
    }
    const shouldPromptForConfirmation = element.sourceId !== sourceId || element.confirmBeforeUndo;
    if (shouldPromptForConfirmation && !undoConfirmed) {
      return this._confirmAndContinueUndo(strResource, sourceId, element);
    }
    try {
      if (element.type === 1) {
        return this._workspaceUndo(strResource, element, undoConfirmed);
      } else {
        return this._resourceUndo(editStack, element, undoConfirmed);
      }
    } finally {
      if (DEBUG) {
        this._print("undo");
      }
    }
  }
  async _confirmAndContinueUndo(strResource, sourceId, element) {
    const result = await this._dialogService.confirm({
      message: localize("confirmDifferentSource", "Would you like to undo '{0}'?", element.label),
      primaryButton: localize({ key: "confirmDifferentSource.yes", comment: ["&& denotes a mnemonic"] }, "&&Yes"),
      cancelButton: localize("confirmDifferentSource.no", "No")
    });
    if (!result.confirmed) {
      return;
    }
    return this._undo(strResource, sourceId, true);
  }
  _findClosestRedoElementWithSource(sourceId) {
    if (!sourceId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestFutureElement();
      if (!candidate) {
        continue;
      }
      if (candidate.sourceId === sourceId) {
        if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  canRedo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? true : false;
    }
    const strResource = this.getUriComparisonKey(resourceOrSource);
    if (this._editStacks.has(strResource)) {
      const editStack = this._editStacks.get(strResource);
      return editStack.hasFutureElements();
    }
    return false;
  }
  _tryToSplitAndRedo(strResource, element, ignoreResources, message) {
    if (element.canSplit()) {
      this._splitFutureWorkspaceElement(element, ignoreResources);
      this._notificationService.warn(message);
      return new WorkspaceVerificationError(this._redo(strResource));
    } else {
      for (const strResource2 of element.strResources) {
        this.removeElements(strResource2);
      }
      this._notificationService.warn(message);
      return new WorkspaceVerificationError();
    }
  }
  _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {
    if (element.removedResources) {
      return this._tryToSplitAndRedo(strResource, element, element.removedResources, localize({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", element.label, element.removedResources.createMessage()));
    }
    if (checkInvalidatedResources && element.invalidatedResources) {
      return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, localize({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", element.label, element.invalidatedResources.createMessage()));
    }
    const cannotRedoDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.getClosestFutureElement() !== element) {
        cannotRedoDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotRedoDueToResources.length > 0) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", element.label, cannotRedoDueToResources.join(", ")));
    }
    const cannotLockDueToResources = [];
    for (const editStack of editStackSnapshot.editStacks) {
      if (editStack.locked) {
        cannotLockDueToResources.push(editStack.resourceLabel);
      }
    }
    if (cannotLockDueToResources.length > 0) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", element.label, cannotLockDueToResources.join(", ")));
    }
    if (!editStackSnapshot.isValid()) {
      return this._tryToSplitAndRedo(strResource, element, null, localize({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", element.label));
    }
    return null;
  }
  _workspaceRedo(strResource, element) {
    const affectedEditStacks = this._getAffectedEditStacks(element);
    const verificationError = this._checkWorkspaceRedo(
      strResource,
      element,
      affectedEditStacks,
      /*invalidated resources will be checked after the prepare call*/
      false
    );
    if (verificationError) {
      return verificationError.returnValue;
    }
    return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);
  }
  async _executeWorkspaceRedo(strResource, element, editStackSnapshot) {
    let cleanup;
    try {
      cleanup = await this._invokeWorkspacePrepare(element);
    } catch (err) {
      return this._onError(err, element);
    }
    const verificationError = this._checkWorkspaceRedo(
      strResource,
      element,
      editStackSnapshot,
      /*now also check that there are no more invalidated resources*/
      true
    );
    if (verificationError) {
      cleanup.dispose();
      return verificationError.returnValue;
    }
    for (const editStack of editStackSnapshot.editStacks) {
      editStack.moveForward(element);
    }
    return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));
  }
  _resourceRedo(editStack, element) {
    if (!element.isValid) {
      editStack.flushAllElements();
      return;
    }
    if (editStack.locked) {
      const message = localize({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", element.label);
      this._notificationService.warn(message);
      return;
    }
    return this._invokeResourcePrepare(element, (cleanup) => {
      editStack.moveForward(element);
      return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));
    });
  }
  _findClosestRedoElementInGroup(groupId) {
    if (!groupId) {
      return [null, null];
    }
    let matchedElement = null;
    let matchedStrResource = null;
    for (const [strResource, editStack] of this._editStacks) {
      const candidate = editStack.getClosestFutureElement();
      if (!candidate) {
        continue;
      }
      if (candidate.groupId === groupId) {
        if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {
          matchedElement = candidate;
          matchedStrResource = strResource;
        }
      }
    }
    return [matchedElement, matchedStrResource];
  }
  _continueRedoInGroup(groupId) {
    if (!groupId) {
      return;
    }
    const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);
    if (matchedStrResource) {
      return this._redo(matchedStrResource);
    }
  }
  redo(resourceOrSource) {
    if (resourceOrSource instanceof UndoRedoSource) {
      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);
      return matchedStrResource ? this._redo(matchedStrResource) : void 0;
    }
    if (typeof resourceOrSource === "string") {
      return this._redo(resourceOrSource);
    }
    return this._redo(this.getUriComparisonKey(resourceOrSource));
  }
  _redo(strResource) {
    if (!this._editStacks.has(strResource)) {
      return;
    }
    const editStack = this._editStacks.get(strResource);
    const element = editStack.getClosestFutureElement();
    if (!element) {
      return;
    }
    if (element.groupId) {
      const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);
      if (element !== matchedElement && matchedStrResource) {
        return this._redo(matchedStrResource);
      }
    }
    try {
      if (element.type === 1) {
        return this._workspaceRedo(strResource, element);
      } else {
        return this._resourceRedo(editStack, element);
      }
    } finally {
      if (DEBUG) {
        this._print("redo");
      }
    }
  }
};
UndoRedoService = __decorate6([
  __param6(0, IDialogService),
  __param6(1, INotificationService)
], UndoRedoService);
var WorkspaceVerificationError = class {
  constructor(returnValue) {
    this.returnValue = returnValue;
  }
};
registerSingleton(
  IUndoRedoService,
  UndoRedoService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SemanticTokensProviderStyling = class SemanticTokensProviderStyling2 {
  constructor(_legend, _themeService, _languageService, _logService) {
    this._legend = _legend;
    this._themeService = _themeService;
    this._languageService = _languageService;
    this._logService = _logService;
    this._hasWarnedOverlappingTokens = false;
    this._hasWarnedInvalidLengthTokens = false;
    this._hasWarnedInvalidEditStart = false;
    this._hashTable = new HashTable();
  }
  getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {
    const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);
    const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);
    let metadata;
    if (entry) {
      metadata = entry.metadata;
      if (this._logService.getLevel() === LogLevel.Trace) {
        this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);
      }
    } else {
      let tokenType = this._legend.tokenTypes[tokenTypeIndex];
      const tokenModifiers = [];
      if (tokenType) {
        let modifierSet = tokenModifierSet;
        for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {
          if (modifierSet & 1) {
            tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);
          }
          modifierSet = modifierSet >> 1;
        }
        if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {
          this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);
          tokenModifiers.push("not-in-legend");
        }
        const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);
        if (typeof tokenStyle === "undefined") {
          metadata = 2147483647;
        } else {
          metadata = 0;
          if (typeof tokenStyle.italic !== "undefined") {
            const italicBit = (tokenStyle.italic ? 1 : 0) << 11;
            metadata |= italicBit | 1;
          }
          if (typeof tokenStyle.bold !== "undefined") {
            const boldBit = (tokenStyle.bold ? 2 : 0) << 11;
            metadata |= boldBit | 2;
          }
          if (typeof tokenStyle.underline !== "undefined") {
            const underlineBit = (tokenStyle.underline ? 4 : 0) << 11;
            metadata |= underlineBit | 4;
          }
          if (typeof tokenStyle.strikethrough !== "undefined") {
            const strikethroughBit = (tokenStyle.strikethrough ? 8 : 0) << 11;
            metadata |= strikethroughBit | 8;
          }
          if (tokenStyle.foreground) {
            const foregroundBits = tokenStyle.foreground << 15;
            metadata |= foregroundBits | 16;
          }
          if (metadata === 0) {
            metadata = 2147483647;
          }
        }
      } else {
        if (this._logService.getLevel() === LogLevel.Trace) {
          this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);
        }
        metadata = 2147483647;
        tokenType = "not-in-legend";
      }
      this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);
      if (this._logService.getLevel() === LogLevel.Trace) {
        this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(" ")}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);
      }
    }
    return metadata;
  }
  warnOverlappingSemanticTokens(lineNumber, startColumn) {
    if (!this._hasWarnedOverlappingTokens) {
      this._hasWarnedOverlappingTokens = true;
      console.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);
    }
  }
  warnInvalidLengthSemanticTokens(lineNumber, startColumn) {
    if (!this._hasWarnedInvalidLengthTokens) {
      this._hasWarnedInvalidLengthTokens = true;
      console.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`);
    }
  }
  warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {
    if (!this._hasWarnedInvalidEditStart) {
      this._hasWarnedInvalidEditStart = true;
      console.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`);
    }
  }
};
SemanticTokensProviderStyling = __decorate7([
  __param7(1, IThemeService),
  __param7(2, ILanguageService),
  __param7(3, ILogService)
], SemanticTokensProviderStyling);
var HashTableEntry = class {
  constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
    this.tokenTypeIndex = tokenTypeIndex;
    this.tokenModifierSet = tokenModifierSet;
    this.languageId = languageId;
    this.metadata = metadata;
    this.next = null;
  }
};
var HashTable = class _HashTable {
  constructor() {
    this._elementsCount = 0;
    this._currentLengthIndex = 0;
    this._currentLength = _HashTable._SIZES[this._currentLengthIndex];
    this._growCount = Math.round(this._currentLengthIndex + 1 < _HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
    this._elements = [];
    _HashTable._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(entries, length) {
    for (let i = 0; i < length; i++) {
      entries[i] = null;
    }
  }
  _hash2(n1, n2) {
    return (n1 << 5) - n1 + n2 | 0;
  }
  _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {
    return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;
  }
  get(tokenTypeIndex, tokenModifierSet, languageId) {
    const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);
    let p = this._elements[hash];
    while (p) {
      if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {
        return p;
      }
      p = p.next;
    }
    return null;
  }
  add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {
    this._elementsCount++;
    if (this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const oldElements = this._elements;
      this._currentLengthIndex++;
      this._currentLength = _HashTable._SIZES[this._currentLengthIndex];
      this._growCount = Math.round(this._currentLengthIndex + 1 < _HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);
      this._elements = [];
      _HashTable._nullOutEntries(this._elements, this._currentLength);
      for (const first of oldElements) {
        let p = first;
        while (p) {
          const oldNext = p.next;
          p.next = null;
          this._add(p);
          p = oldNext;
        }
      }
    }
    this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));
  }
  _add(element) {
    const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);
    element.next = this._elements[hash];
    this._elements[hash] = element;
  }
};
HashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStyling.js
var ISemanticTokensStylingService = createDecorator("semanticTokensStylingService");

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SemanticTokensStylingService = class SemanticTokensStylingService2 extends Disposable {
  constructor(_themeService, _logService, _languageService) {
    super();
    this._themeService = _themeService;
    this._logService = _logService;
    this._languageService = _languageService;
    this._caches = /* @__PURE__ */ new WeakMap();
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = /* @__PURE__ */ new WeakMap();
    }));
  }
  getStyling(provider) {
    if (!this._caches.has(provider)) {
      this._caches.set(provider, new SemanticTokensProviderStyling(provider.getLegend(), this._themeService, this._languageService, this._logService));
    }
    return this._caches.get(provider);
  }
};
SemanticTokensStylingService = __decorate8([
  __param8(0, IThemeService),
  __param8(1, ILogService),
  __param8(2, ILanguageService)
], SemanticTokensStylingService);
registerSingleton(
  ISemanticTokensStylingService,
  SemanticTokensStylingService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/base/common/glob.js
var GLOBSTAR = "**";
var GLOB_SPLIT = "/";
var PATH_REGEX = "[/\\\\]";
var NO_PATH_REGEX = "[^/\\\\]";
var ALL_FORWARD_SLASHES = /\//g;
function starsToRegExp(starCount, isLastPattern) {
  switch (starCount) {
    case 0:
      return "";
    case 1:
      return `${NO_PATH_REGEX}*?`;
    default:
      return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ""})*?`;
  }
}
function splitGlobAware(pattern, splitChar) {
  if (!pattern) {
    return [];
  }
  const segments = [];
  let inBraces = false;
  let inBrackets = false;
  let curVal = "";
  for (const char of pattern) {
    switch (char) {
      case splitChar:
        if (!inBraces && !inBrackets) {
          segments.push(curVal);
          curVal = "";
          continue;
        }
        break;
      case "{":
        inBraces = true;
        break;
      case "}":
        inBraces = false;
        break;
      case "[":
        inBrackets = true;
        break;
      case "]":
        inBrackets = false;
        break;
    }
    curVal += char;
  }
  if (curVal) {
    segments.push(curVal);
  }
  return segments;
}
function parseRegExp(pattern) {
  if (!pattern) {
    return "";
  }
  let regEx = "";
  const segments = splitGlobAware(pattern, GLOB_SPLIT);
  if (segments.every((segment) => segment === GLOBSTAR)) {
    regEx = ".*";
  } else {
    let previousSegmentWasGlobStar = false;
    segments.forEach((segment, index) => {
      if (segment === GLOBSTAR) {
        if (previousSegmentWasGlobStar) {
          return;
        }
        regEx += starsToRegExp(2, index === segments.length - 1);
      } else {
        let inBraces = false;
        let braceVal = "";
        let inBrackets = false;
        let bracketVal = "";
        for (const char of segment) {
          if (char !== "}" && inBraces) {
            braceVal += char;
            continue;
          }
          if (inBrackets && (char !== "]" || !bracketVal)) {
            let res;
            if (char === "-") {
              res = char;
            } else if ((char === "^" || char === "!") && !bracketVal) {
              res = "^";
            } else if (char === GLOB_SPLIT) {
              res = "";
            } else {
              res = escapeRegExpCharacters(char);
            }
            bracketVal += res;
            continue;
          }
          switch (char) {
            case "{":
              inBraces = true;
              continue;
            case "[":
              inBrackets = true;
              continue;
            case "}": {
              const choices = splitGlobAware(braceVal, ",");
              const braceRegExp = `(?:${choices.map((choice) => parseRegExp(choice)).join("|")})`;
              regEx += braceRegExp;
              inBraces = false;
              braceVal = "";
              break;
            }
            case "]": {
              regEx += "[" + bracketVal + "]";
              inBrackets = false;
              bracketVal = "";
              break;
            }
            case "?":
              regEx += NO_PATH_REGEX;
              continue;
            case "*":
              regEx += starsToRegExp(1);
              continue;
            default:
              regEx += escapeRegExpCharacters(char);
          }
        }
        if (index < segments.length - 1 && // more segments to come after this
        (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...
        index + 2 < segments.length)) {
          regEx += PATH_REGEX;
        }
      }
      previousSegmentWasGlobStar = segment === GLOBSTAR;
    });
  }
  return regEx;
}
var T1 = /^\*\*\/\*\.[\w\.-]+$/;
var T2 = /^\*\*\/([\w\.-]+)\/?$/;
var T3 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/;
var T3_2 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/;
var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/;
var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/;
var CACHE = new LRUCache(1e4);
var FALSE = function() {
  return false;
};
var NULL = function() {
  return null;
};
function parsePattern(arg1, options) {
  if (!arg1) {
    return NULL;
  }
  let pattern;
  if (typeof arg1 !== "string") {
    pattern = arg1.pattern;
  } else {
    pattern = arg1;
  }
  pattern = pattern.trim();
  const patternKey = `${pattern}_${!!options.trimForExclusions}`;
  let parsedPattern = CACHE.get(patternKey);
  if (parsedPattern) {
    return wrapRelativePattern(parsedPattern, arg1);
  }
  let match2;
  if (T1.test(pattern)) {
    parsedPattern = trivia1(pattern.substr(4), pattern);
  } else if (match2 = T2.exec(trimForExclusions(pattern, options))) {
    parsedPattern = trivia2(match2[1], pattern);
  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {
    parsedPattern = trivia3(pattern, options);
  } else if (match2 = T4.exec(trimForExclusions(pattern, options))) {
    parsedPattern = trivia4and5(match2[1].substr(1), pattern, true);
  } else if (match2 = T5.exec(trimForExclusions(pattern, options))) {
    parsedPattern = trivia4and5(match2[1], pattern, false);
  } else {
    parsedPattern = toRegExp(pattern);
  }
  CACHE.set(patternKey, parsedPattern);
  return wrapRelativePattern(parsedPattern, arg1);
}
function wrapRelativePattern(parsedPattern, arg2) {
  if (typeof arg2 === "string") {
    return parsedPattern;
  }
  const wrappedPattern = function(path, basename3) {
    if (!isEqualOrParent(path, arg2.base, !isLinux)) {
      return null;
    }
    return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename3);
  };
  wrappedPattern.allBasenames = parsedPattern.allBasenames;
  wrappedPattern.allPaths = parsedPattern.allPaths;
  wrappedPattern.basenames = parsedPattern.basenames;
  wrappedPattern.patterns = parsedPattern.patterns;
  return wrappedPattern;
}
function trimForExclusions(pattern, options) {
  return options.trimForExclusions && pattern.endsWith("/**") ? pattern.substr(0, pattern.length - 2) : pattern;
}
function trivia1(base, pattern) {
  return function(path, basename3) {
    return typeof path === "string" && path.endsWith(base) ? pattern : null;
  };
}
function trivia2(base, pattern) {
  const slashBase = `/${base}`;
  const backslashBase = `\\${base}`;
  const parsedPattern = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (basename3) {
      return basename3 === base ? pattern : null;
    }
    return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;
  };
  const basenames = [base];
  parsedPattern.basenames = basenames;
  parsedPattern.patterns = [pattern];
  parsedPattern.allBasenames = basenames;
  return parsedPattern;
}
function trivia3(pattern, options) {
  const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(",").map((pattern2) => parsePattern(pattern2, options)).filter((pattern2) => pattern2 !== NULL), pattern);
  const patternsLength = parsedPatterns.length;
  if (!patternsLength) {
    return NULL;
  }
  if (patternsLength === 1) {
    return parsedPatterns[0];
  }
  const parsedPattern = function(path, basename3) {
    for (let i = 0, n = parsedPatterns.length; i < n; i++) {
      if (parsedPatterns[i](path, basename3)) {
        return pattern;
      }
    }
    return null;
  };
  const withBasenames = parsedPatterns.find((pattern2) => !!pattern2.allBasenames);
  if (withBasenames) {
    parsedPattern.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    parsedPattern.allPaths = allPaths;
  }
  return parsedPattern;
}
function trivia4and5(targetPath, pattern, matchPathEnds) {
  const usingPosixSep = sep === posix.sep;
  const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);
  const nativePathEnd = sep + nativePath;
  const targetPathEnd = posix.sep + targetPath;
  let parsedPattern;
  if (matchPathEnds) {
    parsedPattern = function(path, basename3) {
      return typeof path === "string" && (path === nativePath || path.endsWith(nativePathEnd) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;
    };
  } else {
    parsedPattern = function(path, basename3) {
      return typeof path === "string" && (path === nativePath || !usingPosixSep && path === targetPath) ? pattern : null;
    };
  }
  parsedPattern.allPaths = [(matchPathEnds ? "*/" : "./") + targetPath];
  return parsedPattern;
}
function toRegExp(pattern) {
  try {
    const regExp = new RegExp(`^${parseRegExp(pattern)}$`);
    return function(path) {
      regExp.lastIndex = 0;
      return typeof path === "string" && regExp.test(path) ? pattern : null;
    };
  } catch (error) {
    return NULL;
  }
}
function match(arg1, path, hasSibling) {
  if (!arg1 || typeof path !== "string") {
    return false;
  }
  return parse2(arg1)(path, void 0, hasSibling);
}
function parse2(arg1, options = {}) {
  if (!arg1) {
    return FALSE;
  }
  if (typeof arg1 === "string" || isRelativePattern(arg1)) {
    const parsedPattern = parsePattern(arg1, options);
    if (parsedPattern === NULL) {
      return FALSE;
    }
    const resultPattern = function(path, basename3) {
      return !!parsedPattern(path, basename3);
    };
    if (parsedPattern.allBasenames) {
      resultPattern.allBasenames = parsedPattern.allBasenames;
    }
    if (parsedPattern.allPaths) {
      resultPattern.allPaths = parsedPattern.allPaths;
    }
    return resultPattern;
  }
  return parsedExpression(arg1, options);
}
function isRelativePattern(obj) {
  const rp = obj;
  if (!rp) {
    return false;
  }
  return typeof rp.base === "string" && typeof rp.pattern === "string";
}
function parsedExpression(expression, options) {
  const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map((pattern) => parseExpressionPattern(pattern, expression[pattern], options)).filter((pattern) => pattern !== NULL));
  const patternsLength = parsedPatterns.length;
  if (!patternsLength) {
    return NULL;
  }
  if (!parsedPatterns.some((parsedPattern) => !!parsedPattern.requiresSiblings)) {
    if (patternsLength === 1) {
      return parsedPatterns[0];
    }
    const resultExpression2 = function(path, basename3) {
      let resultPromises = void 0;
      for (let i = 0, n = parsedPatterns.length; i < n; i++) {
        const result = parsedPatterns[i](path, basename3);
        if (typeof result === "string") {
          return result;
        }
        if (isThenable(result)) {
          if (!resultPromises) {
            resultPromises = [];
          }
          resultPromises.push(result);
        }
      }
      if (resultPromises) {
        return (async () => {
          for (const resultPromise of resultPromises) {
            const result = await resultPromise;
            if (typeof result === "string") {
              return result;
            }
          }
          return null;
        })();
      }
      return null;
    };
    const withBasenames2 = parsedPatterns.find((pattern) => !!pattern.allBasenames);
    if (withBasenames2) {
      resultExpression2.allBasenames = withBasenames2.allBasenames;
    }
    const allPaths2 = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
    if (allPaths2.length) {
      resultExpression2.allPaths = allPaths2;
    }
    return resultExpression2;
  }
  const resultExpression = function(path, base, hasSibling) {
    let name = void 0;
    let resultPromises = void 0;
    for (let i = 0, n = parsedPatterns.length; i < n; i++) {
      const parsedPattern = parsedPatterns[i];
      if (parsedPattern.requiresSiblings && hasSibling) {
        if (!base) {
          base = basename(path);
        }
        if (!name) {
          name = base.substr(0, base.length - extname(path).length);
        }
      }
      const result = parsedPattern(path, base, name, hasSibling);
      if (typeof result === "string") {
        return result;
      }
      if (isThenable(result)) {
        if (!resultPromises) {
          resultPromises = [];
        }
        resultPromises.push(result);
      }
    }
    if (resultPromises) {
      return (async () => {
        for (const resultPromise of resultPromises) {
          const result = await resultPromise;
          if (typeof result === "string") {
            return result;
          }
        }
        return null;
      })();
    }
    return null;
  };
  const withBasenames = parsedPatterns.find((pattern) => !!pattern.allBasenames);
  if (withBasenames) {
    resultExpression.allBasenames = withBasenames.allBasenames;
  }
  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
  if (allPaths.length) {
    resultExpression.allPaths = allPaths;
  }
  return resultExpression;
}
function parseExpressionPattern(pattern, value, options) {
  if (value === false) {
    return NULL;
  }
  const parsedPattern = parsePattern(pattern, options);
  if (parsedPattern === NULL) {
    return NULL;
  }
  if (typeof value === "boolean") {
    return parsedPattern;
  }
  if (value) {
    const when = value.when;
    if (typeof when === "string") {
      const result = (path, basename3, name, hasSibling) => {
        if (!hasSibling || !parsedPattern(path, basename3)) {
          return null;
        }
        const clausePattern = when.replace("$(basename)", () => name);
        const matched = hasSibling(clausePattern);
        return isThenable(matched) ? matched.then((match2) => match2 ? pattern : null) : matched ? pattern : null;
      };
      result.requiresSiblings = true;
      return result;
    }
  }
  return parsedPattern;
}
function aggregateBasenameMatches(parsedPatterns, result) {
  const basenamePatterns = parsedPatterns.filter((parsedPattern) => !!parsedPattern.basenames);
  if (basenamePatterns.length < 2) {
    return parsedPatterns;
  }
  const basenames = basenamePatterns.reduce((all, current) => {
    const basenames2 = current.basenames;
    return basenames2 ? all.concat(basenames2) : all;
  }, []);
  let patterns;
  if (result) {
    patterns = [];
    for (let i = 0, n = basenames.length; i < n; i++) {
      patterns.push(result);
    }
  } else {
    patterns = basenamePatterns.reduce((all, current) => {
      const patterns2 = current.patterns;
      return patterns2 ? all.concat(patterns2) : all;
    }, []);
  }
  const aggregate = function(path, basename3) {
    if (typeof path !== "string") {
      return null;
    }
    if (!basename3) {
      let i;
      for (i = path.length; i > 0; i--) {
        const ch = path.charCodeAt(i - 1);
        if (ch === 47 || ch === 92) {
          break;
        }
      }
      basename3 = path.substr(i);
    }
    const index = basenames.indexOf(basename3);
    return index !== -1 ? patterns[index] : null;
  };
  aggregate.basenames = basenames;
  aggregate.patterns = patterns;
  aggregate.allBasenames = basenames;
  const aggregatedPatterns = parsedPatterns.filter((parsedPattern) => !parsedPattern.basenames);
  aggregatedPatterns.push(aggregate);
  return aggregatedPatterns;
}

// node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js
function score2(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter of selector) {
      const value = score2(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (!candidateIsSynchronized) {
      return 0;
    }
    if (selector === "*") {
      return 5;
    } else if (selector === candidateLanguage) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector) {
    const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector;
    if (!candidateIsSynchronized && !hasAccessToAllModels) {
      return 0;
    }
    if (notebookType && candidateNotebookUri) {
      candidateUri = candidateNotebookUri;
    }
    let ret = 0;
    if (scheme) {
      if (scheme === candidateUri.scheme) {
        ret = 10;
      } else if (scheme === "*") {
        ret = 5;
      } else {
        return 0;
      }
    }
    if (language) {
      if (language === candidateLanguage) {
        ret = 10;
      } else if (language === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (notebookType) {
      if (notebookType === candidateNotebookType) {
        ret = 10;
      } else if (notebookType === "*" && candidateNotebookType !== void 0) {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let normalizedPattern;
      if (typeof pattern === "string") {
        normalizedPattern = pattern;
      } else {
        normalizedPattern = { ...pattern, base: normalize(pattern.base) };
      }
      if (normalizedPattern === candidateUri.fsPath || match(normalizedPattern, candidateUri.fsPath)) {
        ret = 10;
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}

// node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js
function isExclusive(selector) {
  if (typeof selector === "string") {
    return false;
  } else if (Array.isArray(selector)) {
    return selector.every(isExclusive);
  } else {
    return !!selector.exclusive;
  }
}
var MatchCandidate = class {
  constructor(uri, languageId, notebookUri, notebookType) {
    this.uri = uri;
    this.languageId = languageId;
    this.notebookUri = notebookUri;
    this.notebookType = notebookType;
  }
  equals(other) {
    var _a, _b;
    return this.notebookType === other.notebookType && this.languageId === other.languageId && this.uri.toString() === other.uri.toString() && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());
  }
};
var LanguageFeatureRegistry = class _LanguageFeatureRegistry {
  constructor(_notebookInfoResolver) {
    this._notebookInfoResolver = _notebookInfoResolver;
    this._clock = 0;
    this._entries = [];
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
  }
  register(selector, provider) {
    let entry = {
      selector,
      provider,
      _score: -1,
      _time: this._clock++
    };
    this._entries.push(entry);
    this._lastCandidate = void 0;
    this._onDidChange.fire(this._entries.length);
    return toDisposable(() => {
      if (entry) {
        const idx = this._entries.indexOf(entry);
        if (idx >= 0) {
          this._entries.splice(idx, 1);
          this._lastCandidate = void 0;
          this._onDidChange.fire(this._entries.length);
          entry = void 0;
        }
      }
    });
  }
  has(model) {
    return this.all(model).length > 0;
  }
  all(model) {
    if (!model) {
      return [];
    }
    this._updateScores(model);
    const result = [];
    for (const entry of this._entries) {
      if (entry._score > 0) {
        result.push(entry.provider);
      }
    }
    return result;
  }
  ordered(model) {
    const result = [];
    this._orderedForEach(model, (entry) => result.push(entry.provider));
    return result;
  }
  orderedGroups(model) {
    const result = [];
    let lastBucket;
    let lastBucketScore;
    this._orderedForEach(model, (entry) => {
      if (lastBucket && lastBucketScore === entry._score) {
        lastBucket.push(entry.provider);
      } else {
        lastBucketScore = entry._score;
        lastBucket = [entry.provider];
        result.push(lastBucket);
      }
    });
    return result;
  }
  _orderedForEach(model, callback) {
    this._updateScores(model);
    for (const entry of this._entries) {
      if (entry._score > 0) {
        callback(entry);
      }
    }
  }
  _updateScores(model) {
    var _a, _b;
    const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);
    const candidate = notebookInfo ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type) : new MatchCandidate(model.uri, model.getLanguageId(), void 0, void 0);
    if ((_b = this._lastCandidate) === null || _b === void 0 ? void 0 : _b.equals(candidate)) {
      return;
    }
    this._lastCandidate = candidate;
    for (const entry of this._entries) {
      entry._score = score2(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);
      if (isExclusive(entry.selector) && entry._score > 0) {
        for (const entry2 of this._entries) {
          entry2._score = 0;
        }
        entry._score = 1e3;
        break;
      }
    }
    this._entries.sort(_LanguageFeatureRegistry._compareByScoreAndTime);
  }
  static _compareByScoreAndTime(a, b) {
    if (a._score < b._score) {
      return 1;
    } else if (a._score > b._score) {
      return -1;
    }
    if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {
      return 1;
    } else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {
      return -1;
    }
    if (a._time < b._time) {
      return 1;
    } else if (a._time > b._time) {
      return -1;
    } else {
      return 0;
    }
  }
};
function isBuiltinSelector(selector) {
  if (typeof selector === "string") {
    return false;
  }
  if (Array.isArray(selector)) {
    return selector.some(isBuiltinSelector);
  }
  return Boolean(selector.isBuiltin);
}

// node_modules/monaco-editor/esm/vs/editor/common/services/languageFeaturesService.js
var LanguageFeaturesService = class {
  constructor() {
    this.referenceProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.renameProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.codeActionProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.definitionProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.typeDefinitionProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.declarationProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.implementationProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentSymbolProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.inlayHintsProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.colorProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.codeLensProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentRangeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.onTypeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.signatureHelpProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.hoverProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentHighlightProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.multiDocumentHighlightProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.selectionRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.foldingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.linkProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.inlineCompletionsProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.completionProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.linkedEditingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentRangeSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentOnDropEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
    this.documentPasteEditProvider = new LanguageFeatureRegistry(this._score.bind(this));
  }
  _score(uri) {
    var _a;
    return (_a = this._notebookTypeResolver) === null || _a === void 0 ? void 0 : _a.call(this, uri);
  }
};
registerSingleton(
  ILanguageFeaturesService,
  LanguageFeaturesService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/common/config/diffEditor.js
var diffEditorDefaultOptions = {
  enableSplitViewResizing: true,
  splitViewDefaultRatio: 0.5,
  renderSideBySide: true,
  renderMarginRevertIcon: true,
  maxComputationTime: 5e3,
  maxFileSize: 50,
  ignoreTrimWhitespace: true,
  renderIndicators: true,
  originalEditable: false,
  diffCodeLens: false,
  renderOverviewRuler: true,
  diffWordWrap: "inherit",
  diffAlgorithm: "advanced",
  accessibilityVerbose: false,
  experimental: {
    showMoves: false,
    showEmptyDecorations: true
  },
  hideUnchangedRegions: {
    enabled: false,
    contextLineCount: 3,
    minimumLineCount: 3,
    revealLineCount: 20
  },
  isInEmbeddedEditor: false,
  onlyShowAccessibleDiffViewer: false,
  renderSideBySideInlineBreakpoint: 900,
  useInlineViewWhenSpaceIsLimited: true
};

// node_modules/monaco-editor/esm/vs/editor/common/config/editorConfigurationSchema.js
var editorConfigurationBaseNode = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: localize("editorConfigurationTitle", "Editor"),
  scope: 5
});
var editorConfiguration = {
  ...editorConfigurationBaseNode,
  properties: {
    "editor.tabSize": {
      type: "number",
      default: EDITOR_MODEL_DEFAULTS.tabSize,
      minimum: 1,
      markdownDescription: localize("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.indentSize": {
      "anyOf": [
        {
          type: "string",
          enum: ["tabSize"]
        },
        {
          type: "number",
          minimum: 1
        }
      ],
      default: "tabSize",
      markdownDescription: localize("indentSize", 'The number of spaces used for indentation or `"tabSize"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.')
    },
    "editor.insertSpaces": {
      type: "boolean",
      default: EDITOR_MODEL_DEFAULTS.insertSpaces,
      markdownDescription: localize("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.detectIndentation": {
      type: "boolean",
      default: EDITOR_MODEL_DEFAULTS.detectIndentation,
      markdownDescription: localize("detectIndentation", "Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.", "`#editor.tabSize#`", "`#editor.insertSpaces#`")
    },
    "editor.trimAutoWhitespace": {
      type: "boolean",
      default: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,
      description: localize("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
    },
    "editor.largeFileOptimizations": {
      type: "boolean",
      default: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,
      description: localize("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
    },
    "editor.wordBasedSuggestions": {
      enum: ["off", "currentDocument", "matchingDocuments", "allDocuments"],
      default: "matchingDocuments",
      enumDescriptions: [
        localize("wordBasedSuggestions.off", "Turn off Word Based Suggestions."),
        localize("wordBasedSuggestions.currentDocument", "Only suggest words from the active document."),
        localize("wordBasedSuggestions.matchingDocuments", "Suggest words from all open documents of the same language."),
        localize("wordBasedSuggestions.allDocuments", "Suggest words from all open documents.")
      ],
      description: localize("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document and from which documents they are computed.")
    },
    "editor.semanticHighlighting.enabled": {
      enum: [true, false, "configuredByTheme"],
      enumDescriptions: [
        localize("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
        localize("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
        localize("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
      ],
      default: "configuredByTheme",
      description: localize("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
    },
    "editor.stablePeek": {
      type: "boolean",
      default: false,
      markdownDescription: localize("stablePeek", "Keep peek editors open even when double-clicking their content or when hitting `Escape`.")
    },
    "editor.maxTokenizationLineLength": {
      type: "integer",
      default: 2e4,
      description: localize("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
    },
    "editor.experimental.asyncTokenization": {
      type: "boolean",
      default: false,
      description: localize("editor.experimental.asyncTokenization", "Controls whether the tokenization should happen asynchronously on a web worker."),
      tags: ["experimental"]
    },
    "editor.experimental.asyncTokenizationLogging": {
      type: "boolean",
      default: false,
      description: localize("editor.experimental.asyncTokenizationLogging", "Controls whether async tokenization should be logged. For debugging only.")
    },
    "editor.experimental.asyncTokenizationVerification": {
      type: "boolean",
      default: false,
      description: localize("editor.experimental.asyncTokenizationVerification", "Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only."),
      tags: ["experimental"]
    },
    "editor.language.brackets": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: localize("schema.brackets", "Defines the bracket symbols that increase or decrease the indentation."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: localize("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: localize("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "editor.language.colorizedBracketPairs": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: localize("schema.colorizedBracketPairs", "Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: localize("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: localize("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "diffEditor.maxComputationTime": {
      type: "number",
      default: diffEditorDefaultOptions.maxComputationTime,
      description: localize("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
    },
    "diffEditor.maxFileSize": {
      type: "number",
      default: diffEditorDefaultOptions.maxFileSize,
      description: localize("maxFileSize", "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
    },
    "diffEditor.renderSideBySide": {
      type: "boolean",
      default: diffEditorDefaultOptions.renderSideBySide,
      description: localize("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
    },
    "diffEditor.renderSideBySideInlineBreakpoint": {
      type: "number",
      default: diffEditorDefaultOptions.renderSideBySideInlineBreakpoint,
      description: localize("renderSideBySideInlineBreakpoint", "If the diff editor width is smaller than this value, the inline view is used.")
    },
    "diffEditor.useInlineViewWhenSpaceIsLimited": {
      type: "boolean",
      default: diffEditorDefaultOptions.useInlineViewWhenSpaceIsLimited,
      description: localize("useInlineViewWhenSpaceIsLimited", "If enabled and the editor width is too small, the inline view is used.")
    },
    "diffEditor.renderMarginRevertIcon": {
      type: "boolean",
      default: diffEditorDefaultOptions.renderMarginRevertIcon,
      description: localize("renderMarginRevertIcon", "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
    },
    "diffEditor.ignoreTrimWhitespace": {
      type: "boolean",
      default: diffEditorDefaultOptions.ignoreTrimWhitespace,
      description: localize("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
    },
    "diffEditor.renderIndicators": {
      type: "boolean",
      default: diffEditorDefaultOptions.renderIndicators,
      description: localize("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
    },
    "diffEditor.codeLens": {
      type: "boolean",
      default: diffEditorDefaultOptions.diffCodeLens,
      description: localize("codeLens", "Controls whether the editor shows CodeLens.")
    },
    "diffEditor.wordWrap": {
      type: "string",
      enum: ["off", "on", "inherit"],
      default: diffEditorDefaultOptions.diffWordWrap,
      markdownEnumDescriptions: [
        localize("wordWrap.off", "Lines will never wrap."),
        localize("wordWrap.on", "Lines will wrap at the viewport width."),
        localize("wordWrap.inherit", "Lines will wrap according to the {0} setting.", "`#editor.wordWrap#`")
      ]
    },
    "diffEditor.diffAlgorithm": {
      type: "string",
      enum: ["legacy", "advanced"],
      default: diffEditorDefaultOptions.diffAlgorithm,
      markdownEnumDescriptions: [
        localize("diffAlgorithm.legacy", "Uses the legacy diffing algorithm."),
        localize("diffAlgorithm.advanced", "Uses the advanced diffing algorithm.")
      ],
      tags: ["experimental"]
    },
    "diffEditor.hideUnchangedRegions.enabled": {
      type: "boolean",
      default: diffEditorDefaultOptions.hideUnchangedRegions.enabled,
      markdownDescription: localize("hideUnchangedRegions.enabled", "Controls whether the diff editor shows unchanged regions.")
    },
    "diffEditor.hideUnchangedRegions.revealLineCount": {
      type: "integer",
      default: diffEditorDefaultOptions.hideUnchangedRegions.revealLineCount,
      markdownDescription: localize("hideUnchangedRegions.revealLineCount", "Controls how many lines are used for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.minimumLineCount": {
      type: "integer",
      default: diffEditorDefaultOptions.hideUnchangedRegions.minimumLineCount,
      markdownDescription: localize("hideUnchangedRegions.minimumLineCount", "Controls how many lines are used as a minimum for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.contextLineCount": {
      type: "integer",
      default: diffEditorDefaultOptions.hideUnchangedRegions.contextLineCount,
      markdownDescription: localize("hideUnchangedRegions.contextLineCount", "Controls how many lines are used as context when comparing unchanged regions."),
      minimum: 1
    },
    "diffEditor.experimental.showMoves": {
      type: "boolean",
      default: diffEditorDefaultOptions.experimental.showMoves,
      markdownDescription: localize("showMoves", "Controls whether the diff editor should show detected code moves.")
    },
    "diffEditor.experimental.showEmptyDecorations": {
      type: "boolean",
      default: diffEditorDefaultOptions.experimental.showEmptyDecorations,
      description: localize("showEmptyDecorations", "Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted.")
    }
  }
};
function isConfigurationPropertySchema(x) {
  return typeof x.type !== "undefined" || typeof x.anyOf !== "undefined";
}
for (const editorOption of editorOptionsRegistry) {
  const schema = editorOption.schema;
  if (typeof schema !== "undefined") {
    if (isConfigurationPropertySchema(schema)) {
      editorConfiguration.properties[`editor.${editorOption.name}`] = schema;
    } else {
      for (const key in schema) {
        if (Object.hasOwnProperty.call(schema, key)) {
          editorConfiguration.properties[key] = schema[key];
        }
      }
    }
  }
}
var cachedEditorConfigurationKeys = null;
function getEditorConfigurationKeys() {
  if (cachedEditorConfigurationKeys === null) {
    cachedEditorConfigurationKeys = /* @__PURE__ */ Object.create(null);
    Object.keys(editorConfiguration.properties).forEach((prop) => {
      cachedEditorConfigurationKeys[prop] = true;
    });
  }
  return cachedEditorConfigurationKeys;
}
function isEditorConfigurationKey(key) {
  const editorConfigurationKeys = getEditorConfigurationKeys();
  return editorConfigurationKeys[`editor.${key}`] || false;
}
function isDiffEditorConfigurationKey(key) {
  const editorConfigurationKeys = getEditorConfigurationKeys();
  return editorConfigurationKeys[`diffEditor.${key}`] || false;
}
var configurationRegistry = Registry.as(Extensions.Configuration);
configurationRegistry.registerConfiguration(editorConfiguration);

// node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationModels.js
function freeze(data) {
  return Object.isFrozen(data) ? data : deepFreeze(data);
}
var ConfigurationModel = class _ConfigurationModel {
  constructor(_contents = {}, _keys = [], _overrides = [], raw) {
    this._contents = _contents;
    this._keys = _keys;
    this._overrides = _overrides;
    this.raw = raw;
    this.overrideConfigurations = /* @__PURE__ */ new Map();
  }
  get rawConfiguration() {
    var _a;
    if (!this._rawConfiguration) {
      if ((_a = this.raw) === null || _a === void 0 ? void 0 : _a.length) {
        const rawConfigurationModels = this.raw.map((raw) => {
          if (raw instanceof _ConfigurationModel) {
            return raw;
          }
          const parser = new ConfigurationModelParser("");
          parser.parseRaw(raw);
          return parser.configurationModel;
        });
        this._rawConfiguration = rawConfigurationModels.reduce((previous, current) => current === previous ? current : previous.merge(current), rawConfigurationModels[0]);
      } else {
        this._rawConfiguration = this;
      }
    }
    return this._rawConfiguration;
  }
  get contents() {
    return this._contents;
  }
  get overrides() {
    return this._overrides;
  }
  get keys() {
    return this._keys;
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(section) {
    return section ? getConfigurationValue(this.contents, section) : this.contents;
  }
  inspect(section, overrideIdentifier) {
    const value = this.rawConfiguration.getValue(section);
    const override = overrideIdentifier ? this.rawConfiguration.getOverrideValue(section, overrideIdentifier) : void 0;
    const merged = overrideIdentifier ? this.rawConfiguration.override(overrideIdentifier).getValue(section) : value;
    return { value, override, merged };
  }
  getOverrideValue(section, overrideIdentifier) {
    const overrideContents = this.getContentsForOverrideIdentifer(overrideIdentifier);
    return overrideContents ? section ? getConfigurationValue(overrideContents, section) : overrideContents : void 0;
  }
  override(identifier) {
    let overrideConfigurationModel = this.overrideConfigurations.get(identifier);
    if (!overrideConfigurationModel) {
      overrideConfigurationModel = this.createOverrideConfigurationModel(identifier);
      this.overrideConfigurations.set(identifier, overrideConfigurationModel);
    }
    return overrideConfigurationModel;
  }
  merge(...others) {
    var _a, _b;
    const contents = deepClone(this.contents);
    const overrides = deepClone(this.overrides);
    const keys = [...this.keys];
    const raws = ((_a = this.raw) === null || _a === void 0 ? void 0 : _a.length) ? [...this.raw] : [this];
    for (const other of others) {
      raws.push(...((_b = other.raw) === null || _b === void 0 ? void 0 : _b.length) ? other.raw : [other]);
      if (other.isEmpty()) {
        continue;
      }
      this.mergeContents(contents, other.contents);
      for (const otherOverride of other.overrides) {
        const [override] = overrides.filter((o) => equals(o.identifiers, otherOverride.identifiers));
        if (override) {
          this.mergeContents(override.contents, otherOverride.contents);
          override.keys.push(...otherOverride.keys);
          override.keys = distinct(override.keys);
        } else {
          overrides.push(deepClone(otherOverride));
        }
      }
      for (const key of other.keys) {
        if (keys.indexOf(key) === -1) {
          keys.push(key);
        }
      }
    }
    return new _ConfigurationModel(contents, keys, overrides, raws.every((raw) => raw instanceof _ConfigurationModel) ? void 0 : raws);
  }
  createOverrideConfigurationModel(identifier) {
    const overrideContents = this.getContentsForOverrideIdentifer(identifier);
    if (!overrideContents || typeof overrideContents !== "object" || !Object.keys(overrideContents).length) {
      return this;
    }
    const contents = {};
    for (const key of distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {
      let contentsForKey = this.contents[key];
      const overrideContentsForKey = overrideContents[key];
      if (overrideContentsForKey) {
        if (typeof contentsForKey === "object" && typeof overrideContentsForKey === "object") {
          contentsForKey = deepClone(contentsForKey);
          this.mergeContents(contentsForKey, overrideContentsForKey);
        } else {
          contentsForKey = overrideContentsForKey;
        }
      }
      contents[key] = contentsForKey;
    }
    return new _ConfigurationModel(contents, this.keys, this.overrides);
  }
  mergeContents(source, target) {
    for (const key of Object.keys(target)) {
      if (key in source) {
        if (isObject(source[key]) && isObject(target[key])) {
          this.mergeContents(source[key], target[key]);
          continue;
        }
      }
      source[key] = deepClone(target[key]);
    }
  }
  getContentsForOverrideIdentifer(identifier) {
    let contentsForIdentifierOnly = null;
    let contents = null;
    const mergeContents = (contentsToMerge) => {
      if (contentsToMerge) {
        if (contents) {
          this.mergeContents(contents, contentsToMerge);
        } else {
          contents = deepClone(contentsToMerge);
        }
      }
    };
    for (const override of this.overrides) {
      if (override.identifiers.length === 1 && override.identifiers[0] === identifier) {
        contentsForIdentifierOnly = override.contents;
      } else if (override.identifiers.includes(identifier)) {
        mergeContents(override.contents);
      }
    }
    mergeContents(contentsForIdentifierOnly);
    return contents;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  // Update methods
  addValue(key, value) {
    this.updateValue(key, value, true);
  }
  setValue(key, value) {
    this.updateValue(key, value, false);
  }
  removeValue(key) {
    const index = this.keys.indexOf(key);
    if (index === -1) {
      return;
    }
    this.keys.splice(index, 1);
    removeFromValueTree(this.contents, key);
    if (OVERRIDE_PROPERTY_REGEX.test(key)) {
      this.overrides.splice(this.overrides.findIndex((o) => equals(o.identifiers, overrideIdentifiersFromKey(key))), 1);
    }
  }
  updateValue(key, value, add) {
    addToValueTree(this.contents, key, value, (e) => console.error(e));
    add = add || this.keys.indexOf(key) === -1;
    if (add) {
      this.keys.push(key);
    }
    if (OVERRIDE_PROPERTY_REGEX.test(key)) {
      this.overrides.push({
        identifiers: overrideIdentifiersFromKey(key),
        keys: Object.keys(this.contents[key]),
        contents: toValuesTree(this.contents[key], (message) => console.error(message))
      });
    }
  }
};
var ConfigurationModelParser = class {
  constructor(_name) {
    this._name = _name;
    this._raw = null;
    this._configurationModel = null;
    this._restrictedConfigurations = [];
  }
  get configurationModel() {
    return this._configurationModel || new ConfigurationModel();
  }
  parseRaw(raw, options) {
    this._raw = raw;
    const { contents, keys, overrides, restricted, hasExcludedProperties } = this.doParseRaw(raw, options);
    this._configurationModel = new ConfigurationModel(
      contents,
      keys,
      overrides,
      hasExcludedProperties ? [raw] : void 0
      /* raw has not changed */
    );
    this._restrictedConfigurations = restricted || [];
  }
  doParseRaw(raw, options) {
    const configurationProperties = Registry.as(Extensions.Configuration).getConfigurationProperties();
    const filtered = this.filter(raw, configurationProperties, true, options);
    raw = filtered.raw;
    const contents = toValuesTree(raw, (message) => console.error(`Conflict in settings file ${this._name}: ${message}`));
    const keys = Object.keys(raw);
    const overrides = this.toOverrides(raw, (message) => console.error(`Conflict in settings file ${this._name}: ${message}`));
    return { contents, keys, overrides, restricted: filtered.restricted, hasExcludedProperties: filtered.hasExcludedProperties };
  }
  filter(properties, configurationProperties, filterOverriddenProperties, options) {
    var _a, _b, _c;
    let hasExcludedProperties = false;
    if (!(options === null || options === void 0 ? void 0 : options.scopes) && !(options === null || options === void 0 ? void 0 : options.skipRestricted) && !((_a = options === null || options === void 0 ? void 0 : options.exclude) === null || _a === void 0 ? void 0 : _a.length)) {
      return { raw: properties, restricted: [], hasExcludedProperties };
    }
    const raw = {};
    const restricted = [];
    for (const key in properties) {
      if (OVERRIDE_PROPERTY_REGEX.test(key) && filterOverriddenProperties) {
        const result = this.filter(properties[key], configurationProperties, false, options);
        raw[key] = result.raw;
        hasExcludedProperties = hasExcludedProperties || result.hasExcludedProperties;
        restricted.push(...result.restricted);
      } else {
        const propertySchema = configurationProperties[key];
        const scope = propertySchema ? typeof propertySchema.scope !== "undefined" ? propertySchema.scope : 3 : void 0;
        if (propertySchema === null || propertySchema === void 0 ? void 0 : propertySchema.restricted) {
          restricted.push(key);
        }
        if (!((_b = options.exclude) === null || _b === void 0 ? void 0 : _b.includes(key)) && (((_c = options.include) === null || _c === void 0 ? void 0 : _c.includes(key)) || (scope === void 0 || options.scopes === void 0 || options.scopes.includes(scope)) && !(options.skipRestricted && (propertySchema === null || propertySchema === void 0 ? void 0 : propertySchema.restricted)))) {
          raw[key] = properties[key];
        } else {
          hasExcludedProperties = true;
        }
      }
    }
    return { raw, restricted, hasExcludedProperties };
  }
  toOverrides(raw, conflictReporter) {
    const overrides = [];
    for (const key of Object.keys(raw)) {
      if (OVERRIDE_PROPERTY_REGEX.test(key)) {
        const overrideRaw = {};
        for (const keyInOverrideRaw in raw[key]) {
          overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
        }
        overrides.push({
          identifiers: overrideIdentifiersFromKey(key),
          keys: Object.keys(overrideRaw),
          contents: toValuesTree(overrideRaw, conflictReporter)
        });
      }
    }
    return overrides;
  }
};
var ConfigurationInspectValue = class {
  constructor(key, overrides, _value, overrideIdentifiers, defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, localUserConfiguration, remoteUserConfiguration, workspaceConfiguration, folderConfigurationModel, memoryConfigurationModel) {
    this.key = key;
    this.overrides = overrides;
    this._value = _value;
    this.overrideIdentifiers = overrideIdentifiers;
    this.defaultConfiguration = defaultConfiguration;
    this.policyConfiguration = policyConfiguration;
    this.applicationConfiguration = applicationConfiguration;
    this.userConfiguration = userConfiguration;
    this.localUserConfiguration = localUserConfiguration;
    this.remoteUserConfiguration = remoteUserConfiguration;
    this.workspaceConfiguration = workspaceConfiguration;
    this.folderConfigurationModel = folderConfigurationModel;
    this.memoryConfigurationModel = memoryConfigurationModel;
  }
  inspect(model, section, overrideIdentifier) {
    const inspectValue = model.inspect(section, overrideIdentifier);
    return {
      get value() {
        return freeze(inspectValue.value);
      },
      get override() {
        return freeze(inspectValue.override);
      },
      get merged() {
        return freeze(inspectValue.merged);
      }
    };
  }
  get userInspectValue() {
    if (!this._userInspectValue) {
      this._userInspectValue = this.inspect(this.userConfiguration, this.key, this.overrides.overrideIdentifier);
    }
    return this._userInspectValue;
  }
  get user() {
    return this.userInspectValue.value !== void 0 || this.userInspectValue.override !== void 0 ? { value: this.userInspectValue.value, override: this.userInspectValue.override } : void 0;
  }
};
var Configuration = class _Configuration {
  constructor(_defaultConfiguration, _policyConfiguration, _applicationConfiguration, _localUserConfiguration, _remoteUserConfiguration = new ConfigurationModel(), _workspaceConfiguration = new ConfigurationModel(), _folderConfigurations = new ResourceMap(), _memoryConfiguration = new ConfigurationModel(), _memoryConfigurationByResource = new ResourceMap()) {
    this._defaultConfiguration = _defaultConfiguration;
    this._policyConfiguration = _policyConfiguration;
    this._applicationConfiguration = _applicationConfiguration;
    this._localUserConfiguration = _localUserConfiguration;
    this._remoteUserConfiguration = _remoteUserConfiguration;
    this._workspaceConfiguration = _workspaceConfiguration;
    this._folderConfigurations = _folderConfigurations;
    this._memoryConfiguration = _memoryConfiguration;
    this._memoryConfigurationByResource = _memoryConfigurationByResource;
    this._workspaceConsolidatedConfiguration = null;
    this._foldersConsolidatedConfigurations = new ResourceMap();
    this._userConfiguration = null;
  }
  getValue(section, overrides, workspace) {
    const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(section, overrides, workspace);
    return consolidateConfigurationModel.getValue(section);
  }
  updateValue(key, value, overrides = {}) {
    let memoryConfiguration;
    if (overrides.resource) {
      memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
      if (!memoryConfiguration) {
        memoryConfiguration = new ConfigurationModel();
        this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
      }
    } else {
      memoryConfiguration = this._memoryConfiguration;
    }
    if (value === void 0) {
      memoryConfiguration.removeValue(key);
    } else {
      memoryConfiguration.setValue(key, value);
    }
    if (!overrides.resource) {
      this._workspaceConsolidatedConfiguration = null;
    }
  }
  inspect(key, overrides, workspace) {
    const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(key, overrides, workspace);
    const folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);
    const memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;
    const overrideIdentifiers = /* @__PURE__ */ new Set();
    for (const override of consolidateConfigurationModel.overrides) {
      for (const overrideIdentifier of override.identifiers) {
        if (consolidateConfigurationModel.getOverrideValue(key, overrideIdentifier) !== void 0) {
          overrideIdentifiers.add(overrideIdentifier);
        }
      }
    }
    return new ConfigurationInspectValue(key, overrides, consolidateConfigurationModel.getValue(key), overrideIdentifiers.size ? [...overrideIdentifiers] : void 0, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, workspace ? this._workspaceConfiguration : void 0, folderConfigurationModel ? folderConfigurationModel : void 0, memoryConfigurationModel);
  }
  get applicationConfiguration() {
    return this._applicationConfiguration;
  }
  get userConfiguration() {
    if (!this._userConfiguration) {
      this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration);
    }
    return this._userConfiguration;
  }
  get localUserConfiguration() {
    return this._localUserConfiguration;
  }
  get remoteUserConfiguration() {
    return this._remoteUserConfiguration;
  }
  getConsolidatedConfigurationModel(section, overrides, workspace) {
    let configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
    if (overrides.overrideIdentifier) {
      configurationModel = configurationModel.override(overrides.overrideIdentifier);
    }
    if (!this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(section) !== void 0) {
      configurationModel = configurationModel.merge(this._policyConfiguration);
    }
    return configurationModel;
  }
  getConsolidatedConfigurationModelForResource({ resource }, workspace) {
    let consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
    if (workspace && resource) {
      const root = workspace.getFolder(resource);
      if (root) {
        consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;
      }
      const memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);
      if (memoryConfigurationForResource) {
        consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
      }
    }
    return consolidateConfiguration;
  }
  getWorkspaceConsolidatedConfiguration() {
    if (!this._workspaceConsolidatedConfiguration) {
      this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
    }
    return this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(folder) {
    let folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);
    if (!folderConsolidatedConfiguration) {
      const workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
      const folderConfiguration = this._folderConfigurations.get(folder);
      if (folderConfiguration) {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
        this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);
      } else {
        folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
      }
    }
    return folderConsolidatedConfiguration;
  }
  getFolderConfigurationModelForResource(resource, workspace) {
    if (workspace && resource) {
      const root = workspace.getFolder(resource);
      if (root) {
        return this._folderConfigurations.get(root.uri);
      }
    }
    return void 0;
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      policy: {
        contents: this._policyConfiguration.contents,
        overrides: this._policyConfiguration.overrides,
        keys: this._policyConfiguration.keys
      },
      application: {
        contents: this.applicationConfiguration.contents,
        overrides: this.applicationConfiguration.overrides,
        keys: this.applicationConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((result, folder) => {
        const { contents, overrides, keys } = this._folderConfigurations.get(folder);
        result.push([folder, { contents, overrides, keys }]);
        return result;
      }, [])
    };
  }
  static parse(data) {
    const defaultConfiguration = this.parseConfigurationModel(data.defaults);
    const policyConfiguration = this.parseConfigurationModel(data.policy);
    const applicationConfiguration = this.parseConfigurationModel(data.application);
    const userConfiguration = this.parseConfigurationModel(data.user);
    const workspaceConfiguration = this.parseConfigurationModel(data.workspace);
    const folders = data.folders.reduce((result, value) => {
      result.set(URI.revive(value[0]), this.parseConfigurationModel(value[1]));
      return result;
    }, new ResourceMap());
    return new _Configuration(defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, new ConfigurationModel(), workspaceConfiguration, folders, new ConfigurationModel(), new ResourceMap());
  }
  static parseConfigurationModel(model) {
    return new ConfigurationModel(model.contents, model.keys, model.overrides);
  }
};
var ConfigurationChangeEvent = class {
  constructor(change, previous, currentConfiguraiton, currentWorkspace) {
    this.change = change;
    this.previous = previous;
    this.currentConfiguraiton = currentConfiguraiton;
    this.currentWorkspace = currentWorkspace;
    this._marker = "\n";
    this._markerCode1 = this._marker.charCodeAt(0);
    this._markerCode2 = ".".charCodeAt(0);
    this.affectedKeys = /* @__PURE__ */ new Set();
    this._previousConfiguration = void 0;
    for (const key of change.keys) {
      this.affectedKeys.add(key);
    }
    for (const [, keys] of change.overrides) {
      for (const key of keys) {
        this.affectedKeys.add(key);
      }
    }
    this._affectsConfigStr = this._marker;
    for (const key of this.affectedKeys) {
      this._affectsConfigStr += key + this._marker;
    }
  }
  get previousConfiguration() {
    if (!this._previousConfiguration && this.previous) {
      this._previousConfiguration = Configuration.parse(this.previous.data);
    }
    return this._previousConfiguration;
  }
  affectsConfiguration(section, overrides) {
    var _a;
    const needle = this._marker + section;
    const idx = this._affectsConfigStr.indexOf(needle);
    if (idx < 0) {
      return false;
    }
    const pos = idx + needle.length;
    if (pos >= this._affectsConfigStr.length) {
      return false;
    }
    const code = this._affectsConfigStr.charCodeAt(pos);
    if (code !== this._markerCode1 && code !== this._markerCode2) {
      return false;
    }
    if (overrides) {
      const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, (_a = this.previous) === null || _a === void 0 ? void 0 : _a.workspace) : void 0;
      const value2 = this.currentConfiguraiton.getValue(section, overrides, this.currentWorkspace);
      return !equals2(value1, value2);
    }
    return true;
  }
};

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js
var NoMatchingKb = {
  kind: 0
  /* ResultKind.NoMatchingKb */
};
var MoreChordsNeeded = {
  kind: 1
  /* ResultKind.MoreChordsNeeded */
};
function KbFound(commandId, commandArgs, isBubble) {
  return { kind: 2, commandId, commandArgs, isBubble };
}
var KeybindingResolver = class _KeybindingResolver {
  constructor(defaultKeybindings, overrides, log2) {
    var _a;
    this._log = log2;
    this._defaultKeybindings = defaultKeybindings;
    this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (const defaultKeybinding of defaultKeybindings) {
      const command = defaultKeybinding.command;
      if (command && command.charAt(0) !== "-") {
        this._defaultBoundCommands.set(command, true);
      }
    }
    this._map = /* @__PURE__ */ new Map();
    this._lookupMap = /* @__PURE__ */ new Map();
    this._keybindings = _KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));
    for (let i = 0, len = this._keybindings.length; i < len; i++) {
      const k = this._keybindings[i];
      if (k.chords.length === 0) {
        continue;
      }
      const when = (_a = k.when) === null || _a === void 0 ? void 0 : _a.substituteConstants();
      if (when && when.type === 0) {
        continue;
      }
      this._addKeyPress(k.chords[0], k);
    }
  }
  static _isTargetedForRemoval(defaultKb, keypress, when) {
    if (keypress) {
      for (let i = 0; i < keypress.length; i++) {
        if (keypress[i] !== defaultKb.chords[i]) {
          return false;
        }
      }
    }
    if (when && when.type !== 1) {
      if (!defaultKb.when) {
        return false;
      }
      if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Looks for rules containing "-commandId" and removes them.
   */
  static handleRemovals(rules) {
    const removals = /* @__PURE__ */ new Map();
    for (let i = 0, len = rules.length; i < len; i++) {
      const rule = rules[i];
      if (rule.command && rule.command.charAt(0) === "-") {
        const command = rule.command.substring(1);
        if (!removals.has(command)) {
          removals.set(command, [rule]);
        } else {
          removals.get(command).push(rule);
        }
      }
    }
    if (removals.size === 0) {
      return rules;
    }
    const result = [];
    for (let i = 0, len = rules.length; i < len; i++) {
      const rule = rules[i];
      if (!rule.command || rule.command.length === 0) {
        result.push(rule);
        continue;
      }
      if (rule.command.charAt(0) === "-") {
        continue;
      }
      const commandRemovals = removals.get(rule.command);
      if (!commandRemovals || !rule.isDefault) {
        result.push(rule);
        continue;
      }
      let isRemoved = false;
      for (const commandRemoval of commandRemovals) {
        const when = commandRemoval.when;
        if (this._isTargetedForRemoval(rule, commandRemoval.chords, when)) {
          isRemoved = true;
          break;
        }
      }
      if (!isRemoved) {
        result.push(rule);
        continue;
      }
    }
    return result;
  }
  _addKeyPress(keypress, item) {
    const conflicts = this._map.get(keypress);
    if (typeof conflicts === "undefined") {
      this._map.set(keypress, [item]);
      this._addToLookupMap(item);
      return;
    }
    for (let i = conflicts.length - 1; i >= 0; i--) {
      const conflict = conflicts[i];
      if (conflict.command === item.command) {
        continue;
      }
      let isShorterKbPrefix = true;
      for (let i2 = 1; i2 < conflict.chords.length && i2 < item.chords.length; i2++) {
        if (conflict.chords[i2] !== item.chords[i2]) {
          isShorterKbPrefix = false;
          break;
        }
      }
      if (!isShorterKbPrefix) {
        continue;
      }
      if (_KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {
        this._removeFromLookupMap(conflict);
      }
    }
    conflicts.push(item);
    this._addToLookupMap(item);
  }
  _addToLookupMap(item) {
    if (!item.command) {
      return;
    }
    let arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      arr = [item];
      this._lookupMap.set(item.command, arr);
    } else {
      arr.push(item);
    }
  }
  _removeFromLookupMap(item) {
    if (!item.command) {
      return;
    }
    const arr = this._lookupMap.get(item.command);
    if (typeof arr === "undefined") {
      return;
    }
    for (let i = 0, len = arr.length; i < len; i++) {
      if (arr[i] === item) {
        arr.splice(i, 1);
        return;
      }
    }
  }
  /**
   * Returns true if it is provable `a` implies `b`.
   */
  static whenIsEntirelyIncluded(a, b) {
    if (!b || b.type === 1) {
      return true;
    }
    if (!a || a.type === 1) {
      return false;
    }
    return implies(a, b);
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(commandId, context) {
    const items = this._lookupMap.get(commandId);
    if (typeof items === "undefined" || items.length === 0) {
      return null;
    }
    if (items.length === 1) {
      return items[0];
    }
    for (let i = items.length - 1; i >= 0; i--) {
      const item = items[i];
      if (context.contextMatchesRules(item.when)) {
        return item;
      }
    }
    return items[items.length - 1];
  }
  /**
   * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`
   *
   * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:
   * 	`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord
   */
  resolve(context, currentChords, keypress) {
    const pressedChords = [...currentChords, keypress];
    this._log(`| Resolving ${pressedChords}`);
    const kbCandidates = this._map.get(pressedChords[0]);
    if (kbCandidates === void 0) {
      this._log(`\\ No keybinding entries.`);
      return NoMatchingKb;
    }
    let lookupMap = null;
    if (pressedChords.length < 2) {
      lookupMap = kbCandidates;
    } else {
      lookupMap = [];
      for (let i = 0, len = kbCandidates.length; i < len; i++) {
        const candidate = kbCandidates[i];
        if (pressedChords.length > candidate.chords.length) {
          continue;
        }
        let prefixMatches = true;
        for (let i2 = 1; i2 < pressedChords.length; i2++) {
          if (candidate.chords[i2] !== pressedChords[i2]) {
            prefixMatches = false;
            break;
          }
        }
        if (prefixMatches) {
          lookupMap.push(candidate);
        }
      }
    }
    const result = this._findCommand(context, lookupMap);
    if (!result) {
      this._log(`\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);
      return NoMatchingKb;
    }
    if (pressedChords.length < result.chords.length) {
      this._log(`\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);
      return MoreChordsNeeded;
    }
    this._log(`\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);
    return KbFound(result.command, result.commandArgs, result.bubble);
  }
  _findCommand(context, matches) {
    for (let i = matches.length - 1; i >= 0; i--) {
      const k = matches[i];
      if (!_KeybindingResolver._contextMatchesRules(context, k.when)) {
        continue;
      }
      return k;
    }
    return null;
  }
  static _contextMatchesRules(context, rules) {
    if (!rules) {
      return true;
    }
    return rules.evaluate(context);
  }
};
function printWhenExplanation(when) {
  if (!when) {
    return `no when condition`;
  }
  return `${when.serialize()}`;
}
function printSourceExplanation(kb) {
  return kb.extensionId ? kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}` : kb.isDefault ? `built-in` : `user`;
}

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js
var HIGH_FREQ_COMMANDS = /^(cursor|delete|undo|redo|tab|editor\.action\.clipboard)/;
var AbstractKeybindingService = class extends Disposable {
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None;
  }
  get inChordMode() {
    return this._currentChords.length > 0;
  }
  constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._commandService = _commandService;
    this._telemetryService = _telemetryService;
    this._notificationService = _notificationService;
    this._logService = _logService;
    this._onDidUpdateKeybindings = this._register(new Emitter());
    this._currentChords = [];
    this._currentChordChecker = new IntervalTimer();
    this._currentChordStatusMessage = null;
    this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;
    this._currentSingleModifier = null;
    this._currentSingleModifierClearTimeout = new TimeoutTimer();
    this._logging = false;
  }
  dispose() {
    super.dispose();
  }
  _log(str) {
    if (this._logging) {
      this._logService.info(`[KeybindingService]: ${str}`);
    }
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(commandId, context) {
    const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);
    if (!result) {
      return void 0;
    }
    return result.resolvedKeybinding;
  }
  dispatchEvent(e, target) {
    return this._dispatch(e, target);
  }
  // TODO@ulugbekna: update namings to align with `_doDispatch`
  // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`
  softDispatch(e, target) {
    this._log(`/ Soft dispatching keyboard event`);
    const keybinding = this.resolveKeyboardEvent(e);
    if (keybinding.hasMultipleChords()) {
      console.warn("keyboard event should not be mapped to multiple chords");
      return NoMatchingKb;
    }
    const [firstChord] = keybinding.getDispatchChords();
    if (firstChord === null) {
      this._log(`\\ Keyboard event cannot be dispatched`);
      return NoMatchingKb;
    }
    const contextValue = this._contextKeyService.getContext(target);
    const currentChords = this._currentChords.map(({ keypress }) => keypress);
    return this._getResolver().resolve(contextValue, currentChords, firstChord);
  }
  _scheduleLeaveChordMode() {
    const chordLastInteractedTime = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      if (Date.now() - chordLastInteractedTime > 5e3) {
        this._leaveChordMode();
      }
    }, 500);
  }
  _expectAnotherChord(firstChord, keypressLabel) {
    this._currentChords.push({ keypress: firstChord, label: keypressLabel });
    switch (this._currentChords.length) {
      case 0:
        throw illegalState("impossible");
      case 1:
        this._currentChordStatusMessage = this._notificationService.status(localize("first.chord", "({0}) was pressed. Waiting for second key of chord...", keypressLabel));
        break;
      default: {
        const fullKeypressLabel = this._currentChords.map(({ label }) => label).join(", ");
        this._currentChordStatusMessage = this._notificationService.status(localize("next.chord", "({0}) was pressed. Waiting for next key of chord...", fullKeypressLabel));
      }
    }
    this._scheduleLeaveChordMode();
    if (IME.enabled) {
      IME.disable();
    }
  }
  _leaveChordMode() {
    if (this._currentChordStatusMessage) {
      this._currentChordStatusMessage.dispose();
      this._currentChordStatusMessage = null;
    }
    this._currentChordChecker.cancel();
    this._currentChords = [];
    IME.enable();
  }
  _dispatch(e, target) {
    return this._doDispatch(
      this.resolveKeyboardEvent(e),
      target,
      /*isSingleModiferChord*/
      false
    );
  }
  _singleModifierDispatch(e, target) {
    const keybinding = this.resolveKeyboardEvent(e);
    const [singleModifier] = keybinding.getSingleModifierDispatchChords();
    if (singleModifier) {
      if (this._ignoreSingleModifiers.has(singleModifier)) {
        this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);
        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;
        this._currentSingleModifierClearTimeout.cancel();
        this._currentSingleModifier = null;
        return false;
      }
      this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;
      if (this._currentSingleModifier === null) {
        this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);
        this._currentSingleModifier = singleModifier;
        this._currentSingleModifierClearTimeout.cancelAndSet(() => {
          this._log(`+ Clearing single modifier due to 300ms elapsed.`);
          this._currentSingleModifier = null;
        }, 300);
        return false;
      }
      if (singleModifier === this._currentSingleModifier) {
        this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);
        this._currentSingleModifierClearTimeout.cancel();
        this._currentSingleModifier = null;
        return this._doDispatch(
          keybinding,
          target,
          /*isSingleModiferChord*/
          true
        );
      }
      this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);
      this._currentSingleModifierClearTimeout.cancel();
      this._currentSingleModifier = null;
      return false;
    }
    const [firstChord] = keybinding.getChords();
    this._ignoreSingleModifiers = new KeybindingModifierSet(firstChord);
    if (this._currentSingleModifier !== null) {
      this._log(`+ Clearing single modifier due to other key up.`);
    }
    this._currentSingleModifierClearTimeout.cancel();
    this._currentSingleModifier = null;
    return false;
  }
  _doDispatch(userKeypress, target, isSingleModiferChord = false) {
    var _a;
    let shouldPreventDefault = false;
    if (userKeypress.hasMultipleChords()) {
      console.warn("Unexpected keyboard event mapped to multiple chords");
      return false;
    }
    let userPressedChord = null;
    let currentChords = null;
    if (isSingleModiferChord) {
      const [dispatchKeyname] = userKeypress.getSingleModifierDispatchChords();
      userPressedChord = dispatchKeyname;
      currentChords = dispatchKeyname ? [dispatchKeyname] : [];
    } else {
      [userPressedChord] = userKeypress.getDispatchChords();
      currentChords = this._currentChords.map(({ keypress }) => keypress);
    }
    if (userPressedChord === null) {
      this._log(`\\ Keyboard event cannot be dispatched in keydown phase.`);
      return shouldPreventDefault;
    }
    const contextValue = this._contextKeyService.getContext(target);
    const keypressLabel = userKeypress.getLabel();
    const resolveResult = this._getResolver().resolve(contextValue, currentChords, userPressedChord);
    switch (resolveResult.kind) {
      case 0: {
        this._logService.trace("KeybindingService#dispatch", keypressLabel, `[ No matching keybinding ]`);
        if (this.inChordMode) {
          const currentChordsLabel = this._currentChords.map(({ label }) => label).join(", ");
          this._log(`+ Leaving multi-chord mode: Nothing bound to "${currentChordsLabel}, ${keypressLabel}".`);
          this._notificationService.status(localize("missing.chord", "The key combination ({0}, {1}) is not a command.", currentChordsLabel, keypressLabel), {
            hideAfter: 10 * 1e3
            /* 10s */
          });
          this._leaveChordMode();
          shouldPreventDefault = true;
        }
        return shouldPreventDefault;
      }
      case 1: {
        this._logService.trace("KeybindingService#dispatch", keypressLabel, `[ Several keybindings match - more chords needed ]`);
        shouldPreventDefault = true;
        this._expectAnotherChord(userPressedChord, keypressLabel);
        this._log(this._currentChords.length === 1 ? `+ Entering multi-chord mode...` : `+ Continuing multi-chord mode...`);
        return shouldPreventDefault;
      }
      case 2: {
        this._logService.trace("KeybindingService#dispatch", keypressLabel, `[ Will dispatch command ${resolveResult.commandId} ]`);
        if (resolveResult.commandId === null || resolveResult.commandId === "") {
          if (this.inChordMode) {
            const currentChordsLabel = this._currentChords.map(({ label }) => label).join(", ");
            this._log(`+ Leaving chord mode: Nothing bound to "${currentChordsLabel}, ${keypressLabel}".`);
            this._notificationService.status(localize("missing.chord", "The key combination ({0}, {1}) is not a command.", currentChordsLabel, keypressLabel), {
              hideAfter: 10 * 1e3
              /* 10s */
            });
            this._leaveChordMode();
            shouldPreventDefault = true;
          }
        } else {
          if (this.inChordMode) {
            this._leaveChordMode();
          }
          if (!resolveResult.isBubble) {
            shouldPreventDefault = true;
          }
          this._log(`+ Invoking command ${resolveResult.commandId}.`);
          if (typeof resolveResult.commandArgs === "undefined") {
            this._commandService.executeCommand(resolveResult.commandId).then(void 0, (err) => this._notificationService.warn(err));
          } else {
            this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(void 0, (err) => this._notificationService.warn(err));
          }
          if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {
            this._telemetryService.publicLog2("workbenchActionExecuted", { id: resolveResult.commandId, from: "keybinding", detail: (_a = userKeypress.getUserSettingsLabel()) !== null && _a !== void 0 ? _a : void 0 });
          }
        }
        return shouldPreventDefault;
      }
    }
  }
  mightProducePrintableCharacter(event) {
    if (event.ctrlKey || event.metaKey) {
      return false;
    }
    if (event.keyCode >= 31 && event.keyCode <= 56 || event.keyCode >= 21 && event.keyCode <= 30) {
      return true;
    }
    return false;
  }
};
var KeybindingModifierSet = class {
  constructor(source) {
    this._ctrlKey = source ? source.ctrlKey : false;
    this._shiftKey = source ? source.shiftKey : false;
    this._altKey = source ? source.altKey : false;
    this._metaKey = source ? source.metaKey : false;
  }
  has(modifier) {
    switch (modifier) {
      case "ctrl":
        return this._ctrlKey;
      case "shift":
        return this._shiftKey;
      case "alt":
        return this._altKey;
      case "meta":
        return this._metaKey;
    }
  }
};
KeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/resolvedKeybindingItem.js
var ResolvedKeybindingItem = class {
  constructor(resolvedKeybinding, command, commandArgs, when, isDefault, extensionId, isBuiltinExtension) {
    this._resolvedKeybindingItemBrand = void 0;
    this.resolvedKeybinding = resolvedKeybinding;
    this.chords = resolvedKeybinding ? toEmptyArrayIfContainsNull(resolvedKeybinding.getDispatchChords()) : [];
    if (resolvedKeybinding && this.chords.length === 0) {
      this.chords = toEmptyArrayIfContainsNull(resolvedKeybinding.getSingleModifierDispatchChords());
    }
    this.bubble = command ? command.charCodeAt(0) === 94 : false;
    this.command = this.bubble ? command.substr(1) : command;
    this.commandArgs = commandArgs;
    this.when = when;
    this.isDefault = isDefault;
    this.extensionId = extensionId;
    this.isBuiltinExtension = isBuiltinExtension;
  }
};
function toEmptyArrayIfContainsNull(arr) {
  const result = [];
  for (let i = 0, len = arr.length; i < len; i++) {
    const element = arr[i];
    if (!element) {
      return [];
    }
    result.push(element);
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/baseResolvedKeybinding.js
var BaseResolvedKeybinding = class extends ResolvedKeybinding {
  constructor(os, chords) {
    super();
    if (chords.length === 0) {
      throw illegalArgument(`chords`);
    }
    this._os = os;
    this._chords = chords;
  }
  getLabel() {
    return UILabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getLabel(keybinding));
  }
  getAriaLabel() {
    return AriaLabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getAriaLabel(keybinding));
  }
  getElectronAccelerator() {
    if (this._chords.length > 1) {
      return null;
    }
    if (this._chords[0].isDuplicateModifierCase()) {
      return null;
    }
    return ElectronAcceleratorLabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getElectronAccelerator(keybinding));
  }
  getUserSettingsLabel() {
    return UserSettingsLabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getUserSettingsLabel(keybinding));
  }
  hasMultipleChords() {
    return this._chords.length > 1;
  }
  getChords() {
    return this._chords.map((keybinding) => this._getChord(keybinding));
  }
  _getChord(keybinding) {
    return new ResolvedChord(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, this._getLabel(keybinding), this._getAriaLabel(keybinding));
  }
  getDispatchChords() {
    return this._chords.map((keybinding) => this._getChordDispatch(keybinding));
  }
  getSingleModifierDispatchChords() {
    return this._chords.map((keybinding) => this._getSingleModifierChordDispatch(keybinding));
  }
};

// node_modules/monaco-editor/esm/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js
var USLayoutResolvedKeybinding = class _USLayoutResolvedKeybinding extends BaseResolvedKeybinding {
  constructor(chords, os) {
    super(os, chords);
  }
  _keyCodeToUILabel(keyCode) {
    if (this._os === 2) {
      switch (keyCode) {
        case 15:
          return "←";
        case 16:
          return "↑";
        case 17:
          return "→";
        case 18:
          return "↓";
      }
    }
    return KeyCodeUtils.toString(keyCode);
  }
  _getLabel(chord) {
    if (chord.isDuplicateModifierCase()) {
      return "";
    }
    return this._keyCodeToUILabel(chord.keyCode);
  }
  _getAriaLabel(chord) {
    if (chord.isDuplicateModifierCase()) {
      return "";
    }
    return KeyCodeUtils.toString(chord.keyCode);
  }
  _getElectronAccelerator(chord) {
    return KeyCodeUtils.toElectronAccelerator(chord.keyCode);
  }
  _getUserSettingsLabel(chord) {
    if (chord.isDuplicateModifierCase()) {
      return "";
    }
    const result = KeyCodeUtils.toUserSettingsUS(chord.keyCode);
    return result ? result.toLowerCase() : result;
  }
  _getChordDispatch(chord) {
    return _USLayoutResolvedKeybinding.getDispatchStr(chord);
  }
  static getDispatchStr(chord) {
    if (chord.isModifierKey()) {
      return null;
    }
    let result = "";
    if (chord.ctrlKey) {
      result += "ctrl+";
    }
    if (chord.shiftKey) {
      result += "shift+";
    }
    if (chord.altKey) {
      result += "alt+";
    }
    if (chord.metaKey) {
      result += "meta+";
    }
    result += KeyCodeUtils.toString(chord.keyCode);
    return result;
  }
  _getSingleModifierChordDispatch(keybinding) {
    if (keybinding.keyCode === 5 && !keybinding.shiftKey && !keybinding.altKey && !keybinding.metaKey) {
      return "ctrl";
    }
    if (keybinding.keyCode === 4 && !keybinding.ctrlKey && !keybinding.altKey && !keybinding.metaKey) {
      return "shift";
    }
    if (keybinding.keyCode === 6 && !keybinding.ctrlKey && !keybinding.shiftKey && !keybinding.metaKey) {
      return "alt";
    }
    if (keybinding.keyCode === 57 && !keybinding.ctrlKey && !keybinding.shiftKey && !keybinding.altKey) {
      return "meta";
    }
    return null;
  }
  /**
   * *NOTE*: Check return value for `KeyCode.Unknown`.
   */
  static _scanCodeToKeyCode(scanCode) {
    const immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[scanCode];
    if (immutableKeyCode !== -1) {
      return immutableKeyCode;
    }
    switch (scanCode) {
      case 10:
        return 31;
      case 11:
        return 32;
      case 12:
        return 33;
      case 13:
        return 34;
      case 14:
        return 35;
      case 15:
        return 36;
      case 16:
        return 37;
      case 17:
        return 38;
      case 18:
        return 39;
      case 19:
        return 40;
      case 20:
        return 41;
      case 21:
        return 42;
      case 22:
        return 43;
      case 23:
        return 44;
      case 24:
        return 45;
      case 25:
        return 46;
      case 26:
        return 47;
      case 27:
        return 48;
      case 28:
        return 49;
      case 29:
        return 50;
      case 30:
        return 51;
      case 31:
        return 52;
      case 32:
        return 53;
      case 33:
        return 54;
      case 34:
        return 55;
      case 35:
        return 56;
      case 36:
        return 22;
      case 37:
        return 23;
      case 38:
        return 24;
      case 39:
        return 25;
      case 40:
        return 26;
      case 41:
        return 27;
      case 42:
        return 28;
      case 43:
        return 29;
      case 44:
        return 30;
      case 45:
        return 21;
      case 51:
        return 88;
      case 52:
        return 86;
      case 53:
        return 92;
      case 54:
        return 94;
      case 55:
        return 93;
      case 56:
        return 0;
      case 57:
        return 85;
      case 58:
        return 95;
      case 59:
        return 91;
      case 60:
        return 87;
      case 61:
        return 89;
      case 62:
        return 90;
      case 106:
        return 97;
    }
    return 0;
  }
  static _toKeyCodeChord(chord) {
    if (!chord) {
      return null;
    }
    if (chord instanceof KeyCodeChord) {
      return chord;
    }
    const keyCode = this._scanCodeToKeyCode(chord.scanCode);
    if (keyCode === 0) {
      return null;
    }
    return new KeyCodeChord(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.metaKey, keyCode);
  }
  static resolveKeybinding(keybinding, os) {
    const chords = toEmptyArrayIfContainsNull(keybinding.chords.map((chord) => this._toKeyCodeChord(chord)));
    if (chords.length > 0) {
      return [new _USLayoutResolvedKeybinding(chords, os)];
    }
    return [];
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/standaloneStrings.js
var InspectTokensNLS;
(function(InspectTokensNLS2) {
  InspectTokensNLS2.inspectTokensAction = localize("inspectTokens", "Developer: Inspect Tokens");
})(InspectTokensNLS || (InspectTokensNLS = {}));
var GoToLineNLS;
(function(GoToLineNLS2) {
  GoToLineNLS2.gotoLineActionLabel = localize("gotoLineActionLabel", "Go to Line/Column...");
})(GoToLineNLS || (GoToLineNLS = {}));
var QuickHelpNLS;
(function(QuickHelpNLS2) {
  QuickHelpNLS2.helpQuickAccessActionLabel = localize("helpQuickAccess", "Show all Quick Access Providers");
})(QuickHelpNLS || (QuickHelpNLS = {}));
var QuickCommandNLS;
(function(QuickCommandNLS2) {
  QuickCommandNLS2.quickCommandActionLabel = localize("quickCommandActionLabel", "Command Palette");
  QuickCommandNLS2.quickCommandHelp = localize("quickCommandActionHelp", "Show And Run Commands");
})(QuickCommandNLS || (QuickCommandNLS = {}));
var QuickOutlineNLS;
(function(QuickOutlineNLS2) {
  QuickOutlineNLS2.quickOutlineActionLabel = localize("quickOutlineActionLabel", "Go to Symbol...");
  QuickOutlineNLS2.quickOutlineByCategoryActionLabel = localize("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(QuickOutlineNLS || (QuickOutlineNLS = {}));
var StandaloneCodeEditorNLS;
(function(StandaloneCodeEditorNLS2) {
  StandaloneCodeEditorNLS2.editorViewAccessibleLabel = localize("editorViewAccessibleLabel", "Editor content");
  StandaloneCodeEditorNLS2.accessibilityHelpMessage = localize("accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options.");
})(StandaloneCodeEditorNLS || (StandaloneCodeEditorNLS = {}));
var ToggleHighContrastNLS;
(function(ToggleHighContrastNLS2) {
  ToggleHighContrastNLS2.toggleHighContrast = localize("toggleHighContrast", "Toggle High Contrast Theme");
})(ToggleHighContrastNLS || (ToggleHighContrastNLS = {}));
var StandaloneServicesNLS;
(function(StandaloneServicesNLS2) {
  StandaloneServicesNLS2.bulkEditServiceSummary = localize("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(StandaloneServicesNLS || (StandaloneServicesNLS = {}));

// node_modules/monaco-editor/esm/vs/platform/workspace/common/workspaceTrust.js
var IWorkspaceTrustManagementService = createDecorator("workspaceTrustManagementService");

// node_modules/monaco-editor/esm/vs/base/browser/ui/contextview/contextview.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/base/browser/ui/contextview/contextview.css";
function isAnchor(obj) {
  const anchor = obj;
  return !!anchor && typeof anchor.x === "number" && typeof anchor.y === "number";
}
var LayoutAnchorMode;
(function(LayoutAnchorMode2) {
  LayoutAnchorMode2[LayoutAnchorMode2["AVOID"] = 0] = "AVOID";
  LayoutAnchorMode2[LayoutAnchorMode2["ALIGN"] = 1] = "ALIGN";
})(LayoutAnchorMode || (LayoutAnchorMode = {}));
function layout(viewportSize, viewSize, anchor) {
  const layoutAfterAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset : anchor.offset + anchor.size;
  const layoutBeforeAnchorBoundary = anchor.mode === LayoutAnchorMode.ALIGN ? anchor.offset + anchor.size : anchor.offset;
  if (anchor.position === 0) {
    if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {
      return layoutAfterAnchorBoundary;
    }
    if (viewSize <= layoutBeforeAnchorBoundary) {
      return layoutBeforeAnchorBoundary - viewSize;
    }
    return Math.max(viewportSize - viewSize, 0);
  } else {
    if (viewSize <= layoutBeforeAnchorBoundary) {
      return layoutBeforeAnchorBoundary - viewSize;
    }
    if (viewSize <= viewportSize - layoutAfterAnchorBoundary) {
      return layoutAfterAnchorBoundary;
    }
    return 0;
  }
}
var ContextView = class _ContextView extends Disposable {
  constructor(container, domPosition) {
    super();
    this.container = null;
    this.useFixedPosition = false;
    this.useShadowDOM = false;
    this.delegate = null;
    this.toDisposeOnClean = Disposable.None;
    this.toDisposeOnSetContainer = Disposable.None;
    this.shadowRoot = null;
    this.shadowRootHostElement = null;
    this.view = $(".context-view");
    hide(this.view);
    this.setContainer(container, domPosition);
    this._register(toDisposable(() => this.setContainer(
      null,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    )));
  }
  setContainer(container, domPosition) {
    var _a;
    this.useFixedPosition = domPosition !== 1;
    const usedShadowDOM = this.useShadowDOM;
    this.useShadowDOM = domPosition === 3;
    if (container === this.container && usedShadowDOM !== this.useShadowDOM) {
      return;
    }
    if (this.container) {
      this.toDisposeOnSetContainer.dispose();
      if (this.shadowRoot) {
        this.shadowRoot.removeChild(this.view);
        this.shadowRoot = null;
        (_a = this.shadowRootHostElement) === null || _a === void 0 ? void 0 : _a.remove();
        this.shadowRootHostElement = null;
      } else {
        this.container.removeChild(this.view);
      }
      this.container = null;
    }
    if (container) {
      this.container = container;
      if (this.useShadowDOM) {
        this.shadowRootHostElement = $(".shadow-root-host");
        this.container.appendChild(this.shadowRootHostElement);
        this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
        const style = document.createElement("style");
        style.textContent = SHADOW_ROOT_CSS;
        this.shadowRoot.appendChild(style);
        this.shadowRoot.appendChild(this.view);
        this.shadowRoot.appendChild($("slot"));
      } else {
        this.container.appendChild(this.view);
      }
      const toDisposeOnSetContainer = new DisposableStore();
      _ContextView.BUBBLE_UP_EVENTS.forEach((event) => {
        toDisposeOnSetContainer.add(addStandardDisposableListener(this.container, event, (e) => {
          this.onDOMEvent(e, false);
        }));
      });
      _ContextView.BUBBLE_DOWN_EVENTS.forEach((event) => {
        toDisposeOnSetContainer.add(addStandardDisposableListener(this.container, event, (e) => {
          this.onDOMEvent(e, true);
        }, true));
      });
      this.toDisposeOnSetContainer = toDisposeOnSetContainer;
    }
  }
  show(delegate) {
    var _a, _b;
    if (this.isVisible()) {
      this.hide();
    }
    clearNode(this.view);
    this.view.className = "context-view";
    this.view.style.top = "0px";
    this.view.style.left = "0px";
    this.view.style.zIndex = "2575";
    this.view.style.position = this.useFixedPosition ? "fixed" : "absolute";
    show(this.view);
    this.toDisposeOnClean = delegate.render(this.view) || Disposable.None;
    this.delegate = delegate;
    this.doLayout();
    (_b = (_a = this.delegate).focus) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    if (!this.isVisible()) {
      return;
    }
    if (this.delegate.canRelayout === false && !(isIOS && BrowserFeatures.pointerEvents)) {
      this.hide();
      return;
    }
    if (this.delegate.layout) {
      this.delegate.layout();
    }
    this.doLayout();
  }
  doLayout() {
    if (!this.isVisible()) {
      return;
    }
    const anchor = this.delegate.getAnchor();
    let around;
    if (anchor instanceof HTMLElement) {
      const elementPosition = getDomNodePagePosition(anchor);
      const zoom = getDomNodeZoomLevel(anchor);
      around = {
        top: elementPosition.top * zoom,
        left: elementPosition.left * zoom,
        width: elementPosition.width * zoom,
        height: elementPosition.height * zoom
      };
    } else if (isAnchor(anchor)) {
      around = {
        top: anchor.y,
        left: anchor.x,
        width: anchor.width || 1,
        height: anchor.height || 2
      };
    } else {
      around = {
        top: anchor.posy,
        left: anchor.posx,
        // We are about to position the context view where the mouse
        // cursor is. To prevent the view being exactly under the mouse
        // when showing and thus potentially triggering an action within,
        // we treat the mouse location like a small sized block element.
        width: 2,
        height: 2
      };
    }
    const viewSizeWidth = getTotalWidth(this.view);
    const viewSizeHeight = getTotalHeight(this.view);
    const anchorPosition = this.delegate.anchorPosition || 0;
    const anchorAlignment = this.delegate.anchorAlignment || 0;
    const anchorAxisAlignment = this.delegate.anchorAxisAlignment || 0;
    let top;
    let left;
    const activeWindow = getActiveWindow();
    if (anchorAxisAlignment === 0) {
      const verticalAnchor = {
        offset: around.top - activeWindow.pageYOffset,
        size: around.height,
        position: anchorPosition === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      };
      const horizontalAnchor = { offset: around.left, size: around.width, position: anchorAlignment === 0 ? 0 : 1, mode: LayoutAnchorMode.ALIGN };
      top = layout(activeWindow.innerHeight, viewSizeHeight, verticalAnchor) + activeWindow.pageYOffset;
      if (Range2.intersects({ start: top, end: top + viewSizeHeight }, { start: verticalAnchor.offset, end: verticalAnchor.offset + verticalAnchor.size })) {
        horizontalAnchor.mode = LayoutAnchorMode.AVOID;
      }
      left = layout(activeWindow.innerWidth, viewSizeWidth, horizontalAnchor);
    } else {
      const horizontalAnchor = {
        offset: around.left,
        size: around.width,
        position: anchorAlignment === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      };
      const verticalAnchor = { offset: around.top, size: around.height, position: anchorPosition === 0 ? 0 : 1, mode: LayoutAnchorMode.ALIGN };
      left = layout(activeWindow.innerWidth, viewSizeWidth, horizontalAnchor);
      if (Range2.intersects({ start: left, end: left + viewSizeWidth }, { start: horizontalAnchor.offset, end: horizontalAnchor.offset + horizontalAnchor.size })) {
        verticalAnchor.mode = LayoutAnchorMode.AVOID;
      }
      top = layout(activeWindow.innerHeight, viewSizeHeight, verticalAnchor) + activeWindow.pageYOffset;
    }
    this.view.classList.remove("top", "bottom", "left", "right");
    this.view.classList.add(anchorPosition === 0 ? "bottom" : "top");
    this.view.classList.add(anchorAlignment === 0 ? "left" : "right");
    this.view.classList.toggle("fixed", this.useFixedPosition);
    const containerPosition = getDomNodePagePosition(this.container);
    this.view.style.top = `${top - (this.useFixedPosition ? getDomNodePagePosition(this.view).top : containerPosition.top)}px`;
    this.view.style.left = `${left - (this.useFixedPosition ? getDomNodePagePosition(this.view).left : containerPosition.left)}px`;
    this.view.style.width = "initial";
  }
  hide(data) {
    const delegate = this.delegate;
    this.delegate = null;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.onHide) {
      delegate.onHide(data);
    }
    this.toDisposeOnClean.dispose();
    hide(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, onCapture) {
    if (this.delegate) {
      if (this.delegate.onDOMEvent) {
        this.delegate.onDOMEvent(e, getWindow(e).document.activeElement);
      } else if (onCapture && !isAncestor(e.target, this.container)) {
        this.hide();
      }
    }
  }
  dispose() {
    this.hide();
    super.dispose();
  }
};
ContextView.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"];
ContextView.BUBBLE_DOWN_EVENTS = ["click"];
var SHADOW_ROOT_CSS = (
  /* css */
  `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`
);

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextViewService.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextViewService = class ContextViewService2 extends Disposable {
  constructor(layoutService) {
    super();
    this.layoutService = layoutService;
    this.currentViewDisposable = Disposable.None;
    this.contextView = this._register(new ContextView(
      this.layoutService.mainContainer,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    ));
    this.layout();
    this._register(layoutService.onDidLayoutContainer(() => this.layout()));
  }
  // ContextView
  showContextView(delegate, container, shadowRoot) {
    let domPosition;
    if (container) {
      if (container === this.layoutService.getContainer(getWindow(container))) {
        domPosition = 1;
      } else if (shadowRoot) {
        domPosition = 3;
      } else {
        domPosition = 2;
      }
    } else {
      domPosition = 1;
    }
    this.contextView.setContainer(container !== null && container !== void 0 ? container : this.layoutService.activeContainer, domPosition);
    this.contextView.show(delegate);
    const disposable = toDisposable(() => {
      if (this.currentViewDisposable === disposable) {
        this.hideContextView();
      }
    });
    this.currentViewDisposable = disposable;
    return disposable;
  }
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(data) {
    this.contextView.hide(data);
  }
  dispose() {
    super.dispose();
    this.currentViewDisposable.dispose();
    this.currentViewDisposable = Disposable.None;
  }
};
ContextViewService = __decorate9([
  __param9(0, ILayoutService)
], ContextViewService);

// node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js
var registeredAssociations = [];
var nonUserRegisteredAssociations = [];
var userRegisteredAssociations = [];
function registerPlatformLanguageAssociation(association, warnOnOverwrite = false) {
  _registerLanguageAssociation(association, false, warnOnOverwrite);
}
function _registerLanguageAssociation(association, userConfigured, warnOnOverwrite) {
  const associationItem = toLanguageAssociationItem(association, userConfigured);
  registeredAssociations.push(associationItem);
  if (!associationItem.userConfigured) {
    nonUserRegisteredAssociations.push(associationItem);
  } else {
    userRegisteredAssociations.push(associationItem);
  }
  if (warnOnOverwrite && !associationItem.userConfigured) {
    registeredAssociations.forEach((a) => {
      if (a.mime === associationItem.mime || a.userConfigured) {
        return;
      }
      if (associationItem.extension && a.extension === associationItem.extension) {
        console.warn(`Overwriting extension <<${associationItem.extension}>> to now point to mime <<${associationItem.mime}>>`);
      }
      if (associationItem.filename && a.filename === associationItem.filename) {
        console.warn(`Overwriting filename <<${associationItem.filename}>> to now point to mime <<${associationItem.mime}>>`);
      }
      if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {
        console.warn(`Overwriting filepattern <<${associationItem.filepattern}>> to now point to mime <<${associationItem.mime}>>`);
      }
      if (associationItem.firstline && a.firstline === associationItem.firstline) {
        console.warn(`Overwriting firstline <<${associationItem.firstline}>> to now point to mime <<${associationItem.mime}>>`);
      }
    });
  }
}
function toLanguageAssociationItem(association, userConfigured) {
  return {
    id: association.id,
    mime: association.mime,
    filename: association.filename,
    extension: association.extension,
    filepattern: association.filepattern,
    firstline: association.firstline,
    userConfigured,
    filenameLowercase: association.filename ? association.filename.toLowerCase() : void 0,
    extensionLowercase: association.extension ? association.extension.toLowerCase() : void 0,
    filepatternLowercase: association.filepattern ? parse2(association.filepattern.toLowerCase()) : void 0,
    filepatternOnPath: association.filepattern ? association.filepattern.indexOf(posix.sep) >= 0 : false
  };
}
function clearPlatformLanguageAssociations() {
  registeredAssociations = registeredAssociations.filter((a) => a.userConfigured);
  nonUserRegisteredAssociations = [];
}
function getLanguageIds(resource, firstLine) {
  return getAssociations(resource, firstLine).map((item) => item.id);
}
function getAssociations(resource, firstLine) {
  let path;
  if (resource) {
    switch (resource.scheme) {
      case Schemas.file:
        path = resource.fsPath;
        break;
      case Schemas.data: {
        const metadata = DataUri.parseMetaData(resource);
        path = metadata.get(DataUri.META_DATA_LABEL);
        break;
      }
      case Schemas.vscodeNotebookCell:
        path = void 0;
        break;
      default:
        path = resource.path;
    }
  }
  if (!path) {
    return [{ id: "unknown", mime: Mimes.unknown }];
  }
  path = path.toLowerCase();
  const filename = basename(path);
  const configuredLanguage = getAssociationByPath(path, filename, userRegisteredAssociations);
  if (configuredLanguage) {
    return [configuredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];
  }
  const registeredLanguage = getAssociationByPath(path, filename, nonUserRegisteredAssociations);
  if (registeredLanguage) {
    return [registeredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];
  }
  if (firstLine) {
    const firstlineLanguage = getAssociationByFirstline(firstLine);
    if (firstlineLanguage) {
      return [firstlineLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];
    }
  }
  return [{ id: "unknown", mime: Mimes.unknown }];
}
function getAssociationByPath(path, filename, associations) {
  var _a;
  let filenameMatch = void 0;
  let patternMatch = void 0;
  let extensionMatch = void 0;
  for (let i = associations.length - 1; i >= 0; i--) {
    const association = associations[i];
    if (filename === association.filenameLowercase) {
      filenameMatch = association;
      break;
    }
    if (association.filepattern) {
      if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
        const target = association.filepatternOnPath ? path : filename;
        if ((_a = association.filepatternLowercase) === null || _a === void 0 ? void 0 : _a.call(association, target)) {
          patternMatch = association;
        }
      }
    }
    if (association.extension) {
      if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
        if (filename.endsWith(association.extensionLowercase)) {
          extensionMatch = association;
        }
      }
    }
  }
  if (filenameMatch) {
    return filenameMatch;
  }
  if (patternMatch) {
    return patternMatch;
  }
  if (extensionMatch) {
    return extensionMatch;
  }
  return void 0;
}
function getAssociationByFirstline(firstLine) {
  if (startsWithUTF8BOM(firstLine)) {
    firstLine = firstLine.substr(1);
  }
  if (firstLine.length > 0) {
    for (let i = registeredAssociations.length - 1; i >= 0; i--) {
      const association = registeredAssociations[i];
      if (!association.firstline) {
        continue;
      }
      const matches = firstLine.match(association.firstline);
      if (matches && matches.length > 0) {
        return association;
      }
    }
  }
  return void 0;
}

// node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var NULL_LANGUAGE_ID = "vs.editor.nullLanguage";
var LanguageIdCodec = class {
  constructor() {
    this._languageIdToLanguage = [];
    this._languageToLanguageId = /* @__PURE__ */ new Map();
    this._register(
      NULL_LANGUAGE_ID,
      0
      /* LanguageId.Null */
    );
    this._register(
      PLAINTEXT_LANGUAGE_ID,
      1
      /* LanguageId.PlainText */
    );
    this._nextLanguageId = 2;
  }
  _register(language, languageId) {
    this._languageIdToLanguage[languageId] = language;
    this._languageToLanguageId.set(language, languageId);
  }
  register(language) {
    if (this._languageToLanguageId.has(language)) {
      return;
    }
    const languageId = this._nextLanguageId++;
    this._register(language, languageId);
  }
  encodeLanguageId(languageId) {
    return this._languageToLanguageId.get(languageId) || 0;
  }
  decodeLanguageId(languageId) {
    return this._languageIdToLanguage[languageId] || NULL_LANGUAGE_ID;
  }
};
var LanguagesRegistry = class _LanguagesRegistry extends Disposable {
  constructor(useModesRegistry = true, warnOnOverwrite = false) {
    super();
    this._onDidChange = this._register(new Emitter());
    this.onDidChange = this._onDidChange.event;
    _LanguagesRegistry.instanceCount++;
    this._warnOnOverwrite = warnOnOverwrite;
    this.languageIdCodec = new LanguageIdCodec();
    this._dynamicLanguages = [];
    this._languages = {};
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    if (useModesRegistry) {
      this._initializeFromRegistry();
      this._register(ModesRegistry.onDidChangeLanguages((m) => {
        this._initializeFromRegistry();
      }));
    }
  }
  dispose() {
    _LanguagesRegistry.instanceCount--;
    super.dispose();
  }
  _initializeFromRegistry() {
    this._languages = {};
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    clearPlatformLanguageAssociations();
    const desc = [].concat(ModesRegistry.getLanguages()).concat(this._dynamicLanguages);
    this._registerLanguages(desc);
  }
  _registerLanguages(desc) {
    for (const d of desc) {
      this._registerLanguage(d);
    }
    this._mimeTypesMap = {};
    this._nameMap = {};
    this._lowercaseNameMap = {};
    Object.keys(this._languages).forEach((langId) => {
      const language = this._languages[langId];
      if (language.name) {
        this._nameMap[language.name] = language.identifier;
      }
      language.aliases.forEach((alias) => {
        this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;
      });
      language.mimetypes.forEach((mimetype) => {
        this._mimeTypesMap[mimetype] = language.identifier;
      });
    });
    Registry.as(Extensions.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds());
    this._onDidChange.fire();
  }
  _registerLanguage(lang) {
    const langId = lang.id;
    let resolvedLanguage;
    if (hasOwnProperty.call(this._languages, langId)) {
      resolvedLanguage = this._languages[langId];
    } else {
      this.languageIdCodec.register(langId);
      resolvedLanguage = {
        identifier: langId,
        name: null,
        mimetypes: [],
        aliases: [],
        extensions: [],
        filenames: [],
        configurationFiles: [],
        icons: []
      };
      this._languages[langId] = resolvedLanguage;
    }
    this._mergeLanguage(resolvedLanguage, lang);
  }
  _mergeLanguage(resolvedLanguage, lang) {
    const langId = lang.id;
    let primaryMime = null;
    if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {
      resolvedLanguage.mimetypes.push(...lang.mimetypes);
      primaryMime = lang.mimetypes[0];
    }
    if (!primaryMime) {
      primaryMime = `text/x-${langId}`;
      resolvedLanguage.mimetypes.push(primaryMime);
    }
    if (Array.isArray(lang.extensions)) {
      if (lang.configuration) {
        resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);
      } else {
        resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);
      }
      for (const extension of lang.extensions) {
        registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, extension }, this._warnOnOverwrite);
      }
    }
    if (Array.isArray(lang.filenames)) {
      for (const filename of lang.filenames) {
        registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filename }, this._warnOnOverwrite);
        resolvedLanguage.filenames.push(filename);
      }
    }
    if (Array.isArray(lang.filenamePatterns)) {
      for (const filenamePattern of lang.filenamePatterns) {
        registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filepattern: filenamePattern }, this._warnOnOverwrite);
      }
    }
    if (typeof lang.firstLine === "string" && lang.firstLine.length > 0) {
      let firstLineRegexStr = lang.firstLine;
      if (firstLineRegexStr.charAt(0) !== "^") {
        firstLineRegexStr = "^" + firstLineRegexStr;
      }
      try {
        const firstLineRegex = new RegExp(firstLineRegexStr);
        if (!regExpLeadsToEndlessLoop(firstLineRegex)) {
          registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, firstline: firstLineRegex }, this._warnOnOverwrite);
        }
      } catch (err) {
        console.warn(`[${lang.id}]: Invalid regular expression \`${firstLineRegexStr}\`: `, err);
      }
    }
    resolvedLanguage.aliases.push(langId);
    let langAliases = null;
    if (typeof lang.aliases !== "undefined" && Array.isArray(lang.aliases)) {
      if (lang.aliases.length === 0) {
        langAliases = [null];
      } else {
        langAliases = lang.aliases;
      }
    }
    if (langAliases !== null) {
      for (const langAlias of langAliases) {
        if (!langAlias || langAlias.length === 0) {
          continue;
        }
        resolvedLanguage.aliases.push(langAlias);
      }
    }
    const containsAliases = langAliases !== null && langAliases.length > 0;
    if (containsAliases && langAliases[0] === null) {
    } else {
      const bestName = (containsAliases ? langAliases[0] : null) || langId;
      if (containsAliases || !resolvedLanguage.name) {
        resolvedLanguage.name = bestName;
      }
    }
    if (lang.configuration) {
      resolvedLanguage.configurationFiles.push(lang.configuration);
    }
    if (lang.icon) {
      resolvedLanguage.icons.push(lang.icon);
    }
  }
  isRegisteredLanguageId(languageId) {
    if (!languageId) {
      return false;
    }
    return hasOwnProperty.call(this._languages, languageId);
  }
  getRegisteredLanguageIds() {
    return Object.keys(this._languages);
  }
  getLanguageIdByLanguageName(languageName) {
    const languageNameLower = languageName.toLowerCase();
    if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {
      return null;
    }
    return this._lowercaseNameMap[languageNameLower];
  }
  getLanguageIdByMimeType(mimeType) {
    if (!mimeType) {
      return null;
    }
    if (hasOwnProperty.call(this._mimeTypesMap, mimeType)) {
      return this._mimeTypesMap[mimeType];
    }
    return null;
  }
  guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {
    if (!resource && !firstLine) {
      return [];
    }
    return getLanguageIds(resource, firstLine);
  }
};
LanguagesRegistry.instanceCount = 0;

// node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js
var LanguageService = class _LanguageService extends Disposable {
  constructor(warnOnOverwrite = false) {
    super();
    this._onDidRequestBasicLanguageFeatures = this._register(new Emitter());
    this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event;
    this._onDidRequestRichLanguageFeatures = this._register(new Emitter());
    this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event;
    this._onDidChange = this._register(new Emitter({
      leakWarningThreshold: 200
      /* https://github.com/microsoft/vscode/issues/119968 */
    }));
    this.onDidChange = this._onDidChange.event;
    this._requestedBasicLanguages = /* @__PURE__ */ new Set();
    this._requestedRichLanguages = /* @__PURE__ */ new Set();
    _LanguageService.instanceCount++;
    this._registry = this._register(new LanguagesRegistry(true, warnOnOverwrite));
    this.languageIdCodec = this._registry.languageIdCodec;
    this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
  }
  dispose() {
    _LanguageService.instanceCount--;
    super.dispose();
  }
  isRegisteredLanguageId(languageId) {
    return this._registry.isRegisteredLanguageId(languageId);
  }
  getLanguageIdByLanguageName(languageName) {
    return this._registry.getLanguageIdByLanguageName(languageName);
  }
  getLanguageIdByMimeType(mimeType) {
    return this._registry.getLanguageIdByMimeType(mimeType);
  }
  guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {
    const languageIds = this._registry.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);
    return firstOrDefault(languageIds, null);
  }
  createById(languageId) {
    return new LanguageSelection(this.onDidChange, () => {
      return this._createAndGetLanguageIdentifier(languageId);
    });
  }
  createByFilepathOrFirstLine(resource, firstLine) {
    return new LanguageSelection(this.onDidChange, () => {
      const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);
      return this._createAndGetLanguageIdentifier(languageId);
    });
  }
  _createAndGetLanguageIdentifier(languageId) {
    if (!languageId || !this.isRegisteredLanguageId(languageId)) {
      languageId = PLAINTEXT_LANGUAGE_ID;
    }
    return languageId;
  }
  requestBasicLanguageFeatures(languageId) {
    if (!this._requestedBasicLanguages.has(languageId)) {
      this._requestedBasicLanguages.add(languageId);
      this._onDidRequestBasicLanguageFeatures.fire(languageId);
    }
  }
  requestRichLanguageFeatures(languageId) {
    if (!this._requestedRichLanguages.has(languageId)) {
      this._requestedRichLanguages.add(languageId);
      this.requestBasicLanguageFeatures(languageId);
      TokenizationRegistry.getOrCreate(languageId);
      this._onDidRequestRichLanguageFeatures.fire(languageId);
    }
  }
};
LanguageService.instanceCount = 0;
var LanguageSelection = class {
  constructor(_onDidChangeLanguages, _selector) {
    this._onDidChangeLanguages = _onDidChangeLanguages;
    this._selector = _selector;
    this._listener = null;
    this._emitter = null;
    this.languageId = this._selector();
  }
  _dispose() {
    if (this._listener) {
      this._listener.dispose();
      this._listener = null;
    }
    if (this._emitter) {
      this._emitter.dispose();
      this._emitter = null;
    }
  }
  get onDidChange() {
    if (!this._listener) {
      this._listener = this._onDidChangeLanguages(() => this._evaluate());
    }
    if (!this._emitter) {
      this._emitter = new Emitter({
        onDidRemoveLastListener: () => {
          this._dispose();
        }
      });
    }
    return this._emitter.event;
  }
  _evaluate() {
    var _a;
    const languageId = this._selector();
    if (languageId === this.languageId) {
      return;
    }
    this.languageId = languageId;
    (_a = this._emitter) === null || _a === void 0 ? void 0 : _a.fire(this.languageId);
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/menu/menu.js
var MENU_MNEMONIC_REGEX = /\(&([^\s&])\)|(^|[^&])&([^\s&])/;
var MENU_ESCAPED_MNEMONIC_REGEX = /(&amp;)?(&amp;)([^\s&])/g;
var Direction;
(function(Direction2) {
  Direction2[Direction2["Right"] = 0] = "Right";
  Direction2[Direction2["Left"] = 1] = "Left";
})(Direction || (Direction = {}));
var Menu = class _Menu extends ActionBar {
  constructor(container, actions, options, menuStyles) {
    container.classList.add("monaco-menu-container");
    container.setAttribute("role", "presentation");
    const menuElement = document.createElement("div");
    menuElement.classList.add("monaco-menu");
    menuElement.setAttribute("role", "presentation");
    super(menuElement, {
      orientation: 1,
      actionViewItemProvider: (action) => this.doGetActionViewItem(action, options, parentData),
      context: options.context,
      actionRunner: options.actionRunner,
      ariaLabel: options.ariaLabel,
      ariaRole: "menu",
      focusOnlyEnabledItems: true,
      triggerKeys: { keys: [3, ...isMacintosh || isLinux ? [
        10
        /* KeyCode.Space */
      ] : []], keyDown: true }
    });
    this.menuStyles = menuStyles;
    this.menuElement = menuElement;
    this.actionsList.tabIndex = 0;
    this.initializeOrUpdateStyleSheet(container, menuStyles);
    this._register(Gesture.addTarget(menuElement));
    this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        2
        /* KeyCode.Tab */
      )) {
        e.preventDefault();
      }
    }));
    if (options.enableMnemonics) {
      this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
        const key = e.key.toLocaleLowerCase();
        if (this.mnemonics.has(key)) {
          EventHelper.stop(e, true);
          const actions2 = this.mnemonics.get(key);
          if (actions2.length === 1) {
            if (actions2[0] instanceof SubmenuMenuActionViewItem && actions2[0].container) {
              this.focusItemByElement(actions2[0].container);
            }
            actions2[0].onClick(e);
          }
          if (actions2.length > 1) {
            const action = actions2.shift();
            if (action && action.container) {
              this.focusItemByElement(action.container);
              actions2.push(action);
            }
            this.mnemonics.set(key, actions2);
          }
        }
      }));
    }
    if (isLinux) {
      this._register(addDisposableListener(menuElement, EventType.KEY_DOWN, (e) => {
        const event = new StandardKeyboardEvent(e);
        if (event.equals(
          14
          /* KeyCode.Home */
        ) || event.equals(
          11
          /* KeyCode.PageUp */
        )) {
          this.focusedItem = this.viewItems.length - 1;
          this.focusNext();
          EventHelper.stop(e, true);
        } else if (event.equals(
          13
          /* KeyCode.End */
        ) || event.equals(
          12
          /* KeyCode.PageDown */
        )) {
          this.focusedItem = 0;
          this.focusPrevious();
          EventHelper.stop(e, true);
        }
      }));
    }
    this._register(addDisposableListener(this.domNode, EventType.MOUSE_OUT, (e) => {
      const relatedTarget = e.relatedTarget;
      if (!isAncestor(relatedTarget, this.domNode)) {
        this.focusedItem = void 0;
        this.updateFocus();
        e.stopPropagation();
      }
    }));
    this._register(addDisposableListener(this.actionsList, EventType.MOUSE_OVER, (e) => {
      let target = e.target;
      if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {
        return;
      }
      while (target.parentElement !== this.actionsList && target.parentElement !== null) {
        target = target.parentElement;
      }
      if (target.classList.contains("action-item")) {
        const lastFocusedItem = this.focusedItem;
        this.setFocusedItem(target);
        if (lastFocusedItem !== this.focusedItem) {
          this.updateFocus();
        }
      }
    }));
    this._register(Gesture.addTarget(this.actionsList));
    this._register(addDisposableListener(this.actionsList, EventType2.Tap, (e) => {
      let target = e.initialTarget;
      if (!target || !isAncestor(target, this.actionsList) || target === this.actionsList) {
        return;
      }
      while (target.parentElement !== this.actionsList && target.parentElement !== null) {
        target = target.parentElement;
      }
      if (target.classList.contains("action-item")) {
        const lastFocusedItem = this.focusedItem;
        this.setFocusedItem(target);
        if (lastFocusedItem !== this.focusedItem) {
          this.updateFocus();
        }
      }
    }));
    const parentData = {
      parent: this
    };
    this.mnemonics = /* @__PURE__ */ new Map();
    this.scrollableElement = this._register(new DomScrollableElement(menuElement, {
      alwaysConsumeMouseWheel: true,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: true,
      useShadows: true
    }));
    const scrollElement = this.scrollableElement.getDomNode();
    scrollElement.style.position = "";
    this.styleScrollElement(scrollElement, menuStyles);
    this._register(addDisposableListener(menuElement, EventType2.Change, (e) => {
      EventHelper.stop(e, true);
      const scrollTop = this.scrollableElement.getScrollPosition().scrollTop;
      this.scrollableElement.setScrollPosition({ scrollTop: scrollTop - e.translationY });
    }));
    this._register(addDisposableListener(scrollElement, EventType.MOUSE_UP, (e) => {
      e.preventDefault();
    }));
    const window = getWindow(container);
    menuElement.style.maxHeight = `${Math.max(10, window.innerHeight - container.getBoundingClientRect().top - 35)}px`;
    actions = actions.filter((a) => {
      var _a;
      if ((_a = options.submenuIds) === null || _a === void 0 ? void 0 : _a.has(a.id)) {
        console.warn(`Found submenu cycle: ${a.id}`);
        return false;
      }
      return true;
    });
    this.push(actions, { icon: true, label: true, isMenu: true });
    container.appendChild(this.scrollableElement.getDomNode());
    this.scrollableElement.scanDomNode();
    this.viewItems.filter((item) => !(item instanceof MenuSeparatorActionViewItem)).forEach((item, index, array) => {
      item.updatePositionInSet(index + 1, array.length);
    });
  }
  initializeOrUpdateStyleSheet(container, style) {
    if (!this.styleSheet) {
      if (isInShadowDOM(container)) {
        this.styleSheet = createStyleSheet(container);
      } else {
        if (!_Menu.globalStyleSheet) {
          _Menu.globalStyleSheet = createStyleSheet();
        }
        this.styleSheet = _Menu.globalStyleSheet;
      }
    }
    this.styleSheet.textContent = getMenuWidgetCSS(style, isInShadowDOM(container));
  }
  styleScrollElement(scrollElement, style) {
    var _a, _b;
    const fgColor = (_a = style.foregroundColor) !== null && _a !== void 0 ? _a : "";
    const bgColor = (_b = style.backgroundColor) !== null && _b !== void 0 ? _b : "";
    const border = style.borderColor ? `1px solid ${style.borderColor}` : "";
    const borderRadius = "5px";
    const shadow = style.shadowColor ? `0 2px 8px ${style.shadowColor}` : "";
    scrollElement.style.outline = border;
    scrollElement.style.borderRadius = borderRadius;
    scrollElement.style.color = fgColor;
    scrollElement.style.backgroundColor = bgColor;
    scrollElement.style.boxShadow = shadow;
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(element) {
    const lastFocusedItem = this.focusedItem;
    this.setFocusedItem(element);
    if (lastFocusedItem !== this.focusedItem) {
      this.updateFocus();
    }
  }
  setFocusedItem(element) {
    for (let i = 0; i < this.actionsList.children.length; i++) {
      const elem = this.actionsList.children[i];
      if (element === elem) {
        this.focusedItem = i;
        break;
      }
    }
  }
  updateFocus(fromRight) {
    super.updateFocus(fromRight, true, true);
    if (typeof this.focusedItem !== "undefined") {
      this.scrollableElement.setScrollPosition({
        scrollTop: Math.round(this.menuElement.scrollTop)
      });
    }
  }
  doGetActionViewItem(action, options, parentData) {
    if (action instanceof Separator) {
      return new MenuSeparatorActionViewItem(options.context, action, { icon: true }, this.menuStyles);
    } else if (action instanceof SubmenuAction) {
      const menuActionViewItem = new SubmenuMenuActionViewItem(action, action.actions, parentData, { ...options, submenuIds: /* @__PURE__ */ new Set([...options.submenuIds || [], action.id]) }, this.menuStyles);
      if (options.enableMnemonics) {
        const mnemonic = menuActionViewItem.getMnemonic();
        if (mnemonic && menuActionViewItem.isEnabled()) {
          let actionViewItems = [];
          if (this.mnemonics.has(mnemonic)) {
            actionViewItems = this.mnemonics.get(mnemonic);
          }
          actionViewItems.push(menuActionViewItem);
          this.mnemonics.set(mnemonic, actionViewItems);
        }
      }
      return menuActionViewItem;
    } else {
      const menuItemOptions = { enableMnemonics: options.enableMnemonics, useEventAsContext: options.useEventAsContext };
      if (options.getKeyBinding) {
        const keybinding = options.getKeyBinding(action);
        if (keybinding) {
          const keybindingLabel = keybinding.getLabel();
          if (keybindingLabel) {
            menuItemOptions.keybinding = keybindingLabel;
          }
        }
      }
      const menuActionViewItem = new BaseMenuActionViewItem(options.context, action, menuItemOptions, this.menuStyles);
      if (options.enableMnemonics) {
        const mnemonic = menuActionViewItem.getMnemonic();
        if (mnemonic && menuActionViewItem.isEnabled()) {
          let actionViewItems = [];
          if (this.mnemonics.has(mnemonic)) {
            actionViewItems = this.mnemonics.get(mnemonic);
          }
          actionViewItems.push(menuActionViewItem);
          this.mnemonics.set(mnemonic, actionViewItems);
        }
      }
      return menuActionViewItem;
    }
  }
};
var BaseMenuActionViewItem = class extends BaseActionViewItem {
  constructor(ctx, action, options, menuStyle) {
    options.isMenu = true;
    super(action, action, options);
    this.menuStyle = menuStyle;
    this.options = options;
    this.options.icon = options.icon !== void 0 ? options.icon : false;
    this.options.label = options.label !== void 0 ? options.label : true;
    this.cssClass = "";
    if (this.options.label && options.enableMnemonics) {
      const label = this.action.label;
      if (label) {
        const matches = MENU_MNEMONIC_REGEX.exec(label);
        if (matches) {
          this.mnemonic = (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase();
        }
      }
    }
    this.runOnceToEnableMouseUp = new RunOnceScheduler(() => {
      if (!this.element) {
        return;
      }
      this._register(addDisposableListener(this.element, EventType.MOUSE_UP, (e) => {
        EventHelper.stop(e, true);
        if (isFirefox) {
          const mouseEvent = new StandardMouseEvent(getWindow(this.element), e);
          if (mouseEvent.rightButton) {
            return;
          }
          this.onClick(e);
        } else {
          setTimeout(() => {
            this.onClick(e);
          }, 0);
        }
      }));
      this._register(addDisposableListener(this.element, EventType.CONTEXT_MENU, (e) => {
        EventHelper.stop(e, true);
      }));
    }, 100);
    this._register(this.runOnceToEnableMouseUp);
  }
  render(container) {
    super.render(container);
    if (!this.element) {
      return;
    }
    this.container = container;
    this.item = append(this.element, $("a.action-menu-item"));
    if (this._action.id === Separator.ID) {
      this.item.setAttribute("role", "presentation");
    } else {
      this.item.setAttribute("role", "menuitem");
      if (this.mnemonic) {
        this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`);
      }
    }
    this.check = append(this.item, $("span.menu-item-check" + ThemeIcon.asCSSSelector(Codicon.menuSelection)));
    this.check.setAttribute("role", "none");
    this.label = append(this.item, $("span.action-label"));
    if (this.options.label && this.options.keybinding) {
      append(this.item, $("span.keybinding")).textContent = this.options.keybinding;
    }
    this.runOnceToEnableMouseUp.schedule();
    this.updateClass();
    this.updateLabel();
    this.updateTooltip();
    this.updateEnabled();
    this.updateChecked();
    this.applyStyle();
  }
  blur() {
    super.blur();
    this.applyStyle();
  }
  focus() {
    var _a;
    super.focus();
    (_a = this.item) === null || _a === void 0 ? void 0 : _a.focus();
    this.applyStyle();
  }
  updatePositionInSet(pos, setSize) {
    if (this.item) {
      this.item.setAttribute("aria-posinset", `${pos}`);
      this.item.setAttribute("aria-setsize", `${setSize}`);
    }
  }
  updateLabel() {
    var _a;
    if (!this.label) {
      return;
    }
    if (this.options.label) {
      clearNode(this.label);
      let label = stripIcons(this.action.label);
      if (label) {
        const cleanLabel = cleanMnemonic(label);
        if (!this.options.enableMnemonics) {
          label = cleanLabel;
        }
        this.label.setAttribute("aria-label", cleanLabel.replace(/&&/g, "&"));
        const matches = MENU_MNEMONIC_REGEX.exec(label);
        if (matches) {
          label = escape(label);
          MENU_ESCAPED_MNEMONIC_REGEX.lastIndex = 0;
          let escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);
          while (escMatch && escMatch[1]) {
            escMatch = MENU_ESCAPED_MNEMONIC_REGEX.exec(label);
          }
          const replaceDoubleEscapes = (str) => str.replace(/&amp;&amp;/g, "&amp;");
          if (escMatch) {
            this.label.append(ltrim(replaceDoubleEscapes(label.substr(0, escMatch.index)), " "), $("u", { "aria-hidden": "true" }, escMatch[3]), rtrim(replaceDoubleEscapes(label.substr(escMatch.index + escMatch[0].length)), " "));
          } else {
            this.label.innerText = replaceDoubleEscapes(label).trim();
          }
          (_a = this.item) === null || _a === void 0 ? void 0 : _a.setAttribute("aria-keyshortcuts", (!!matches[1] ? matches[1] : matches[3]).toLocaleLowerCase());
        } else {
          this.label.innerText = label.replace(/&&/g, "&").trim();
        }
      }
    }
  }
  updateTooltip() {
  }
  updateClass() {
    if (this.cssClass && this.item) {
      this.item.classList.remove(...this.cssClass.split(" "));
    }
    if (this.options.icon && this.label) {
      this.cssClass = this.action.class || "";
      this.label.classList.add("icon");
      if (this.cssClass) {
        this.label.classList.add(...this.cssClass.split(" "));
      }
      this.updateEnabled();
    } else if (this.label) {
      this.label.classList.remove("icon");
    }
  }
  updateEnabled() {
    if (this.action.enabled) {
      if (this.element) {
        this.element.classList.remove("disabled");
        this.element.removeAttribute("aria-disabled");
      }
      if (this.item) {
        this.item.classList.remove("disabled");
        this.item.removeAttribute("aria-disabled");
        this.item.tabIndex = 0;
      }
    } else {
      if (this.element) {
        this.element.classList.add("disabled");
        this.element.setAttribute("aria-disabled", "true");
      }
      if (this.item) {
        this.item.classList.add("disabled");
        this.item.setAttribute("aria-disabled", "true");
      }
    }
  }
  updateChecked() {
    if (!this.item) {
      return;
    }
    const checked = this.action.checked;
    this.item.classList.toggle("checked", !!checked);
    if (checked !== void 0) {
      this.item.setAttribute("role", "menuitemcheckbox");
      this.item.setAttribute("aria-checked", checked ? "true" : "false");
    } else {
      this.item.setAttribute("role", "menuitem");
      this.item.setAttribute("aria-checked", "");
    }
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    const isSelected = this.element && this.element.classList.contains("focused");
    const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    const bgColor = isSelected && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0;
    const outline = isSelected && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : "";
    const outlineOffset = isSelected && this.menuStyle.selectionBorderColor ? `-1px` : "";
    if (this.item) {
      this.item.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : "";
      this.item.style.backgroundColor = bgColor !== null && bgColor !== void 0 ? bgColor : "";
      this.item.style.outline = outline;
      this.item.style.outlineOffset = outlineOffset;
    }
    if (this.check) {
      this.check.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : "";
    }
  }
};
var SubmenuMenuActionViewItem = class extends BaseMenuActionViewItem {
  constructor(action, submenuActions, parentData, submenuOptions, menuStyles) {
    super(action, action, submenuOptions, menuStyles);
    this.submenuActions = submenuActions;
    this.parentData = parentData;
    this.submenuOptions = submenuOptions;
    this.mysubmenu = null;
    this.submenuDisposables = this._register(new DisposableStore());
    this.mouseOver = false;
    this.expandDirection = submenuOptions && submenuOptions.expandDirection !== void 0 ? submenuOptions.expandDirection : Direction.Right;
    this.showScheduler = new RunOnceScheduler(() => {
      if (this.mouseOver) {
        this.cleanupExistingSubmenu(false);
        this.createSubmenu(false);
      }
    }, 250);
    this.hideScheduler = new RunOnceScheduler(() => {
      if (this.element && (!isAncestor(getActiveElement(), this.element) && this.parentData.submenu === this.mysubmenu)) {
        this.parentData.parent.focus(false);
        this.cleanupExistingSubmenu(true);
      }
    }, 750);
  }
  render(container) {
    super.render(container);
    if (!this.element) {
      return;
    }
    if (this.item) {
      this.item.classList.add("monaco-submenu-item");
      this.item.tabIndex = 0;
      this.item.setAttribute("aria-haspopup", "true");
      this.updateAriaExpanded("false");
      this.submenuIndicator = append(this.item, $("span.submenu-indicator" + ThemeIcon.asCSSSelector(Codicon.menuSubmenu)));
      this.submenuIndicator.setAttribute("aria-hidden", "true");
    }
    this._register(addDisposableListener(this.element, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(
        17
        /* KeyCode.RightArrow */
      ) || event.equals(
        3
        /* KeyCode.Enter */
      )) {
        EventHelper.stop(e, true);
        this.createSubmenu(true);
      }
    }));
    this._register(addDisposableListener(this.element, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (getActiveElement() === this.item) {
        if (event.equals(
          17
          /* KeyCode.RightArrow */
        ) || event.equals(
          3
          /* KeyCode.Enter */
        )) {
          EventHelper.stop(e, true);
        }
      }
    }));
    this._register(addDisposableListener(this.element, EventType.MOUSE_OVER, (e) => {
      if (!this.mouseOver) {
        this.mouseOver = true;
        this.showScheduler.schedule();
      }
    }));
    this._register(addDisposableListener(this.element, EventType.MOUSE_LEAVE, (e) => {
      this.mouseOver = false;
    }));
    this._register(addDisposableListener(this.element, EventType.FOCUS_OUT, (e) => {
      if (this.element && !isAncestor(getActiveElement(), this.element)) {
        this.hideScheduler.schedule();
      }
    }));
    this._register(this.parentData.parent.onScroll(() => {
      if (this.parentData.submenu === this.mysubmenu) {
        this.parentData.parent.focus(false);
        this.cleanupExistingSubmenu(true);
      }
    }));
  }
  updateEnabled() {
  }
  onClick(e) {
    EventHelper.stop(e, true);
    this.cleanupExistingSubmenu(false);
    this.createSubmenu(true);
  }
  cleanupExistingSubmenu(force) {
    if (this.parentData.submenu && (force || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch (_a) {
      }
      this.parentData.submenu = void 0;
      this.updateAriaExpanded("false");
      if (this.submenuContainer) {
        this.submenuDisposables.clear();
        this.submenuContainer = void 0;
      }
    }
  }
  calculateSubmenuMenuLayout(windowDimensions, submenu, entry, expandDirection) {
    const ret = { top: 0, left: 0 };
    ret.left = layout(windowDimensions.width, submenu.width, { position: expandDirection === Direction.Right ? 0 : 1, offset: entry.left, size: entry.width });
    if (ret.left >= entry.left && ret.left < entry.left + entry.width) {
      if (entry.left + 10 + submenu.width <= windowDimensions.width) {
        ret.left = entry.left + 10;
      }
      entry.top += 10;
      entry.height = 0;
    }
    ret.top = layout(windowDimensions.height, submenu.height, { position: 0, offset: entry.top, size: 0 });
    if (ret.top + submenu.height === entry.top && ret.top + entry.height + submenu.height <= windowDimensions.height) {
      ret.top += entry.height;
    }
    return ret;
  }
  createSubmenu(selectFirstItem = true) {
    if (!this.element) {
      return;
    }
    if (!this.parentData.submenu) {
      this.updateAriaExpanded("true");
      this.submenuContainer = append(this.element, $("div.monaco-submenu"));
      this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
      const computedStyles = getWindow(this.parentData.parent.domNode).getComputedStyle(this.parentData.parent.domNode);
      const paddingTop = parseFloat(computedStyles.paddingTop || "0") || 0;
      this.submenuContainer.style.zIndex = "1";
      this.submenuContainer.style.position = "fixed";
      this.submenuContainer.style.top = "0";
      this.submenuContainer.style.left = "0";
      this.parentData.submenu = new Menu(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new EmptySubmenuAction()], this.submenuOptions, this.menuStyle);
      const entryBox = this.element.getBoundingClientRect();
      const entryBoxUpdated = {
        top: entryBox.top - paddingTop,
        left: entryBox.left,
        height: entryBox.height + 2 * paddingTop,
        width: entryBox.width
      };
      const viewBox = this.submenuContainer.getBoundingClientRect();
      const window = getWindow(this.element);
      const { top, left } = this.calculateSubmenuMenuLayout(new Dimension(window.innerWidth, window.innerHeight), Dimension.lift(viewBox), entryBoxUpdated, this.expandDirection);
      this.submenuContainer.style.left = `${left - viewBox.left}px`;
      this.submenuContainer.style.top = `${top - viewBox.top}px`;
      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_UP, (e) => {
        const event = new StandardKeyboardEvent(e);
        if (event.equals(
          15
          /* KeyCode.LeftArrow */
        )) {
          EventHelper.stop(e, true);
          this.parentData.parent.focus();
          this.cleanupExistingSubmenu(true);
        }
      }));
      this.submenuDisposables.add(addDisposableListener(this.submenuContainer, EventType.KEY_DOWN, (e) => {
        const event = new StandardKeyboardEvent(e);
        if (event.equals(
          15
          /* KeyCode.LeftArrow */
        )) {
          EventHelper.stop(e, true);
        }
      }));
      this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
        this.parentData.parent.focus();
        this.cleanupExistingSubmenu(true);
      }));
      this.parentData.submenu.focus(selectFirstItem);
      this.mysubmenu = this.parentData.submenu;
    } else {
      this.parentData.submenu.focus(false);
    }
  }
  updateAriaExpanded(value) {
    var _a;
    if (this.item) {
      (_a = this.item) === null || _a === void 0 ? void 0 : _a.setAttribute("aria-expanded", value);
    }
  }
  applyStyle() {
    super.applyStyle();
    const isSelected = this.element && this.element.classList.contains("focused");
    const fgColor = isSelected && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    if (this.submenuIndicator) {
      this.submenuIndicator.style.color = fgColor !== null && fgColor !== void 0 ? fgColor : "";
    }
  }
  dispose() {
    super.dispose();
    this.hideScheduler.dispose();
    if (this.mysubmenu) {
      this.mysubmenu.dispose();
      this.mysubmenu = null;
    }
    if (this.submenuContainer) {
      this.submenuContainer = void 0;
    }
  }
};
var MenuSeparatorActionViewItem = class extends ActionViewItem {
  constructor(context, action, options, menuStyles) {
    super(context, action, options);
    this.menuStyles = menuStyles;
  }
  render(container) {
    super.render(container);
    if (this.label) {
      this.label.style.borderBottomColor = this.menuStyles.separatorColor ? `${this.menuStyles.separatorColor}` : "";
    }
  }
};
function cleanMnemonic(label) {
  const regex = MENU_MNEMONIC_REGEX;
  const matches = regex.exec(label);
  if (!matches) {
    return label;
  }
  const mnemonicInText = !matches[1];
  return label.replace(regex, mnemonicInText ? "$2$3" : "").trim();
}
function formatRule(c) {
  const fontCharacter = getCodiconFontCharacters()[c.id];
  return `.codicon-${c.id}:before { content: '\\${fontCharacter.toString(16)}'; }`;
}
function getMenuWidgetCSS(style, isForShadowDom) {
  let result = (
    /* css */
    `
.monaco-menu {
	font-size: 13px;
	border-radius: 5px;
	min-width: 160px;
}

${formatRule(Codicon.menuSelection)}
${formatRule(Codicon.menuSubmenu)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar.animated .action-item.active {
	transform: scale(1.272019649, 1.272019649); /* 1.272019649 = √φ */
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	color: var(--vscode-disabledForeground);
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid var(--vscode-menu-separatorBackground);
	padding-top: 1px;
	padding: 30px;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
	margin: 0 4px;
	border-radius: 4px;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {
	opacity: unset;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	width: 100%;
	height: 0px !important;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.hc-black .context-view.monaco-menu-container,
.hc-light .context-view.monaco-menu-container,
:host-context(.hc-black) .context-view.monaco-menu-container,
:host-context(.hc-light) .context-view.monaco-menu-container {
	box-shadow: none;
}

.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,
.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: 4px 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	margin: 5px 0 !important;
	padding: 0;
	border-radius: 0;
}

.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}`
  );
  if (isForShadowDom) {
    result += `
			/* Arrows */
			.monaco-scrollable-element > .scrollbar > .scra {
				cursor: pointer;
				font-size: 11px !important;
			}

			.monaco-scrollable-element > .visible {
				opacity: 1;

				/* Background rule added for IE9 - to allow clicks on dom node */
				background:rgba(0,0,0,0);

				transition: opacity 100ms linear;
			}
			.monaco-scrollable-element > .invisible {
				opacity: 0;
				pointer-events: none;
			}
			.monaco-scrollable-element > .invisible.fade {
				transition: opacity 800ms linear;
			}

			/* Scrollable Content Inset Shadow */
			.monaco-scrollable-element > .shadow {
				position: absolute;
				display: none;
			}
			.monaco-scrollable-element > .shadow.top {
				display: block;
				top: 0;
				left: 3px;
				height: 3px;
				width: 100%;
			}
			.monaco-scrollable-element > .shadow.left {
				display: block;
				top: 3px;
				left: 0;
				height: 100%;
				width: 3px;
			}
			.monaco-scrollable-element > .shadow.top-left-corner {
				display: block;
				top: 0;
				left: 0;
				height: 3px;
				width: 3px;
			}
		`;
    const scrollbarShadowColor = style.scrollbarShadow;
    if (scrollbarShadowColor) {
      result += `
				.monaco-scrollable-element > .shadow.top {
					box-shadow: ${scrollbarShadowColor} 0 6px 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.left {
					box-shadow: ${scrollbarShadowColor} 6px 0 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.top.left {
					box-shadow: ${scrollbarShadowColor} 6px 6px 6px -6px inset;
				}
			`;
    }
    const scrollbarSliderBackgroundColor = style.scrollbarSliderBackground;
    if (scrollbarSliderBackgroundColor) {
      result += `
				.monaco-scrollable-element > .scrollbar > .slider {
					background: ${scrollbarSliderBackgroundColor};
				}
			`;
    }
    const scrollbarSliderHoverBackgroundColor = style.scrollbarSliderHoverBackground;
    if (scrollbarSliderHoverBackgroundColor) {
      result += `
				.monaco-scrollable-element > .scrollbar > .slider:hover {
					background: ${scrollbarSliderHoverBackgroundColor};
				}
			`;
    }
    const scrollbarSliderActiveBackgroundColor = style.scrollbarSliderActiveBackground;
    if (scrollbarSliderActiveBackgroundColor) {
      result += `
				.monaco-scrollable-element > .scrollbar > .slider.active {
					background: ${scrollbarSliderActiveBackgroundColor};
				}
			`;
    }
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuHandler.js
var ContextMenuHandler = class {
  constructor(contextViewService, telemetryService, notificationService, keybindingService) {
    this.contextViewService = contextViewService;
    this.telemetryService = telemetryService;
    this.notificationService = notificationService;
    this.keybindingService = keybindingService;
    this.focusToReturn = null;
    this.lastContainer = null;
    this.block = null;
    this.blockDisposable = null;
    this.options = { blockMouse: true };
  }
  configure(options) {
    this.options = options;
  }
  showContextMenu(delegate) {
    const actions = delegate.getActions();
    if (!actions.length) {
      return;
    }
    this.focusToReturn = getActiveElement();
    let menu;
    const shadowRootElement = delegate.domForShadowRoot instanceof HTMLElement ? delegate.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => delegate.getAnchor(),
      canRelayout: false,
      anchorAlignment: delegate.anchorAlignment,
      anchorAxisAlignment: delegate.anchorAxisAlignment,
      render: (container) => {
        var _a;
        this.lastContainer = container;
        const className = delegate.getMenuClassName ? delegate.getMenuClassName() : "";
        if (className) {
          container.className += " " + className;
        }
        if (this.options.blockMouse) {
          this.block = container.appendChild($(".context-view-block"));
          this.block.style.position = "fixed";
          this.block.style.cursor = "initial";
          this.block.style.left = "0";
          this.block.style.top = "0";
          this.block.style.width = "100%";
          this.block.style.height = "100%";
          this.block.style.zIndex = "-1";
          (_a = this.blockDisposable) === null || _a === void 0 ? void 0 : _a.dispose();
          this.blockDisposable = addDisposableListener(this.block, EventType.MOUSE_DOWN, (e) => e.stopPropagation());
        }
        const menuDisposables = new DisposableStore();
        const actionRunner = delegate.actionRunner || new ActionRunner();
        actionRunner.onWillRun((evt) => this.onActionRun(evt, !delegate.skipTelemetry), this, menuDisposables);
        actionRunner.onDidRun(this.onDidActionRun, this, menuDisposables);
        menu = new Menu(container, actions, {
          actionViewItemProvider: delegate.getActionViewItem,
          context: delegate.getActionsContext ? delegate.getActionsContext() : null,
          actionRunner,
          getKeyBinding: delegate.getKeyBinding ? delegate.getKeyBinding : (action) => this.keybindingService.lookupKeybinding(action.id)
        }, defaultMenuStyles);
        menu.onDidCancel(() => this.contextViewService.hideContextView(true), null, menuDisposables);
        menu.onDidBlur(() => this.contextViewService.hideContextView(true), null, menuDisposables);
        const targetWindow = getWindow(container);
        menuDisposables.add(addDisposableListener(targetWindow, EventType.BLUR, () => this.contextViewService.hideContextView(true)));
        menuDisposables.add(addDisposableListener(targetWindow, EventType.MOUSE_DOWN, (e) => {
          if (e.defaultPrevented) {
            return;
          }
          const event = new StandardMouseEvent(targetWindow, e);
          let element = event.target;
          if (event.rightButton) {
            return;
          }
          while (element) {
            if (element === container) {
              return;
            }
            element = element.parentElement;
          }
          this.contextViewService.hideContextView(true);
        }));
        return combinedDisposable(menuDisposables, menu);
      },
      focus: () => {
        menu === null || menu === void 0 ? void 0 : menu.focus(!!delegate.autoSelectFirstItem);
      },
      onHide: (didCancel) => {
        var _a, _b, _c;
        (_a = delegate.onHide) === null || _a === void 0 ? void 0 : _a.call(delegate, !!didCancel);
        if (this.block) {
          this.block.remove();
          this.block = null;
        }
        (_b = this.blockDisposable) === null || _b === void 0 ? void 0 : _b.dispose();
        this.blockDisposable = null;
        if (!!this.lastContainer && (getActiveElement() === this.lastContainer || isAncestor(getActiveElement(), this.lastContainer))) {
          (_c = this.focusToReturn) === null || _c === void 0 ? void 0 : _c.focus();
        }
        this.lastContainer = null;
      }
    }, shadowRootElement, !!shadowRootElement);
  }
  onActionRun(e, logTelemetry) {
    if (logTelemetry) {
      this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" });
    }
    this.contextViewService.hideContextView(false);
  }
  onDidActionRun(e) {
    if (e.error && !isCancellationError(e.error)) {
      this.notificationService.error(e.error);
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextMenuService.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextMenuService = class ContextMenuService2 extends Disposable {
  get contextMenuHandler() {
    if (!this._contextMenuHandler) {
      this._contextMenuHandler = new ContextMenuHandler(this.contextViewService, this.telemetryService, this.notificationService, this.keybindingService);
    }
    return this._contextMenuHandler;
  }
  constructor(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService) {
    super();
    this.telemetryService = telemetryService;
    this.notificationService = notificationService;
    this.contextViewService = contextViewService;
    this.keybindingService = keybindingService;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this._contextMenuHandler = void 0;
    this._onDidShowContextMenu = this._store.add(new Emitter());
    this._onDidHideContextMenu = this._store.add(new Emitter());
  }
  configure(options) {
    this.contextMenuHandler.configure(options);
  }
  // ContextMenu
  showContextMenu(delegate) {
    delegate = ContextMenuMenuDelegate.transform(delegate, this.menuService, this.contextKeyService);
    this.contextMenuHandler.showContextMenu({
      ...delegate,
      onHide: (didCancel) => {
        var _a;
        (_a = delegate.onHide) === null || _a === void 0 ? void 0 : _a.call(delegate, didCancel);
        this._onDidHideContextMenu.fire();
      }
    });
    ModifierKeyEmitter.getInstance().resetKeyStatus();
    this._onDidShowContextMenu.fire();
  }
};
ContextMenuService = __decorate10([
  __param10(0, ITelemetryService),
  __param10(1, INotificationService),
  __param10(2, IContextViewService),
  __param10(3, IKeybindingService),
  __param10(4, IMenuService),
  __param10(5, IContextKeyService)
], ContextMenuService);
var ContextMenuMenuDelegate;
(function(ContextMenuMenuDelegate2) {
  function is(thing) {
    return thing && thing.menuId instanceof MenuId;
  }
  function transform(delegate, menuService, globalContextKeyService) {
    if (!is(delegate)) {
      return delegate;
    }
    const { menuId, menuActionOptions, contextKeyService } = delegate;
    return {
      ...delegate,
      getActions: () => {
        const target = [];
        if (menuId) {
          const menu = menuService.createMenu(menuId, contextKeyService !== null && contextKeyService !== void 0 ? contextKeyService : globalContextKeyService);
          createAndFillInContextMenuActions(menu, menuActionOptions, target);
          menu.dispose();
        }
        if (!delegate.getActions) {
          return target;
        } else {
          return Separator.join(delegate.getActions(), target);
        }
      }
    };
  }
  ContextMenuMenuDelegate2.transform = transform;
})(ContextMenuMenuDelegate || (ContextMenuMenuDelegate = {}));

// node_modules/monaco-editor/esm/vs/platform/editor/common/editor.js
var EditorOpenSource;
(function(EditorOpenSource2) {
  EditorOpenSource2[EditorOpenSource2["API"] = 0] = "API";
  EditorOpenSource2[EditorOpenSource2["USER"] = 1] = "USER";
})(EditorOpenSource || (EditorOpenSource = {}));

// node_modules/monaco-editor/esm/vs/editor/browser/services/openerService.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CommandOpener = class CommandOpener2 {
  constructor(_commandService) {
    this._commandService = _commandService;
  }
  async open(target, options) {
    if (!matchesScheme(target, Schemas.command)) {
      return false;
    }
    if (!(options === null || options === void 0 ? void 0 : options.allowCommands)) {
      return true;
    }
    if (typeof target === "string") {
      target = URI.parse(target);
    }
    if (Array.isArray(options.allowCommands)) {
      if (!options.allowCommands.includes(target.path)) {
        return true;
      }
    }
    let args = [];
    try {
      args = parse(decodeURIComponent(target.query));
    } catch (_a) {
      try {
        args = parse(target.query);
      } catch (_b) {
      }
    }
    if (!Array.isArray(args)) {
      args = [args];
    }
    await this._commandService.executeCommand(target.path, ...args);
    return true;
  }
};
CommandOpener = __decorate11([
  __param11(0, ICommandService)
], CommandOpener);
var EditorOpener = class EditorOpener2 {
  constructor(_editorService) {
    this._editorService = _editorService;
  }
  async open(target, options) {
    if (typeof target === "string") {
      target = URI.parse(target);
    }
    const { selection, uri } = extractSelection(target);
    target = uri;
    if (target.scheme === Schemas.file) {
      target = normalizePath(target);
    }
    await this._editorService.openCodeEditor({
      resource: target,
      options: {
        selection,
        source: (options === null || options === void 0 ? void 0 : options.fromUserGesture) ? EditorOpenSource.USER : EditorOpenSource.API,
        ...options === null || options === void 0 ? void 0 : options.editorOptions
      }
    }, this._editorService.getFocusedCodeEditor(), options === null || options === void 0 ? void 0 : options.openToSide);
    return true;
  }
};
EditorOpener = __decorate11([
  __param11(0, ICodeEditorService)
], EditorOpener);
var OpenerService = class OpenerService2 {
  constructor(editorService, commandService) {
    this._openers = new LinkedList();
    this._validators = new LinkedList();
    this._resolvers = new LinkedList();
    this._resolvedUriTargets = new ResourceMap((uri) => uri.with({ path: null, fragment: null, query: null }).toString());
    this._externalOpeners = new LinkedList();
    this._defaultExternalOpener = {
      openExternal: async (href) => {
        if (matchesSomeScheme(href, Schemas.http, Schemas.https)) {
          windowOpenNoOpener(href);
        } else {
          mainWindow.location.href = href;
        }
        return true;
      }
    };
    this._openers.push({
      open: async (target, options) => {
        if ((options === null || options === void 0 ? void 0 : options.openExternal) || matchesSomeScheme(target, Schemas.mailto, Schemas.http, Schemas.https, Schemas.vsls)) {
          await this._doOpenExternal(target, options);
          return true;
        }
        return false;
      }
    });
    this._openers.push(new CommandOpener(commandService));
    this._openers.push(new EditorOpener(editorService));
  }
  registerOpener(opener) {
    const remove = this._openers.unshift(opener);
    return { dispose: remove };
  }
  async open(target, options) {
    var _a;
    const targetURI = typeof target === "string" ? URI.parse(target) : target;
    const validationTarget = (_a = this._resolvedUriTargets.get(targetURI)) !== null && _a !== void 0 ? _a : target;
    for (const validator of this._validators) {
      if (!await validator.shouldOpen(validationTarget, options)) {
        return false;
      }
    }
    for (const opener of this._openers) {
      const handled = await opener.open(target, options);
      if (handled) {
        return true;
      }
    }
    return false;
  }
  async resolveExternalUri(resource, options) {
    for (const resolver of this._resolvers) {
      try {
        const result = await resolver.resolveExternalUri(resource, options);
        if (result) {
          if (!this._resolvedUriTargets.has(result.resolved)) {
            this._resolvedUriTargets.set(result.resolved, resource);
          }
          return result;
        }
      } catch (_a) {
      }
    }
    throw new Error("Could not resolve external URI: " + resource.toString());
  }
  async _doOpenExternal(resource, options) {
    const uri = typeof resource === "string" ? URI.parse(resource) : resource;
    let externalUri;
    try {
      externalUri = (await this.resolveExternalUri(uri, options)).resolved;
    } catch (_a) {
      externalUri = uri;
    }
    let href;
    if (typeof resource === "string" && uri.toString() === externalUri.toString()) {
      href = resource;
    } else {
      href = encodeURI(externalUri.toString(true));
    }
    if (options === null || options === void 0 ? void 0 : options.allowContributedOpeners) {
      const preferredOpenerId = typeof (options === null || options === void 0 ? void 0 : options.allowContributedOpeners) === "string" ? options === null || options === void 0 ? void 0 : options.allowContributedOpeners : void 0;
      for (const opener of this._externalOpeners) {
        const didOpen = await opener.openExternal(href, {
          sourceUri: uri,
          preferredOpenerId
        }, CancellationToken.None);
        if (didOpen) {
          return true;
        }
      }
    }
    return this._defaultExternalOpener.openExternal(href, { sourceUri: uri }, CancellationToken.None);
  }
  dispose() {
    this._validators.clear();
  }
};
OpenerService = __decorate11([
  __param11(0, ICodeEditorService),
  __param11(1, ICommandService)
], OpenerService);

// node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerDecorationsService = class MarkerDecorationsService2 extends Disposable {
  constructor(modelService, _markerService) {
    super();
    this._markerService = _markerService;
    this._onDidChangeMarker = this._register(new Emitter());
    this._markerDecorations = new ResourceMap();
    modelService.getModels().forEach((model) => this._onModelAdded(model));
    this._register(modelService.onModelAdded(this._onModelAdded, this));
    this._register(modelService.onModelRemoved(this._onModelRemoved, this));
    this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose();
    this._markerDecorations.forEach((value) => value.dispose());
    this._markerDecorations.clear();
  }
  getMarker(uri, decoration) {
    const markerDecorations = this._markerDecorations.get(uri);
    return markerDecorations ? markerDecorations.getMarker(decoration) || null : null;
  }
  _handleMarkerChange(changedResources) {
    changedResources.forEach((resource) => {
      const markerDecorations = this._markerDecorations.get(resource);
      if (markerDecorations) {
        this._updateDecorations(markerDecorations);
      }
    });
  }
  _onModelAdded(model) {
    const markerDecorations = new MarkerDecorations(model);
    this._markerDecorations.set(model.uri, markerDecorations);
    this._updateDecorations(markerDecorations);
  }
  _onModelRemoved(model) {
    var _a;
    const markerDecorations = this._markerDecorations.get(model.uri);
    if (markerDecorations) {
      markerDecorations.dispose();
      this._markerDecorations.delete(model.uri);
    }
    if (model.uri.scheme === Schemas.inMemory || model.uri.scheme === Schemas.internal || model.uri.scheme === Schemas.vscode) {
      (_a = this._markerService) === null || _a === void 0 ? void 0 : _a.read({ resource: model.uri }).map((marker) => marker.owner).forEach((owner) => this._markerService.remove(owner, [model.uri]));
    }
  }
  _updateDecorations(markerDecorations) {
    const markers = this._markerService.read({ resource: markerDecorations.model.uri, take: 500 });
    if (markerDecorations.update(markers)) {
      this._onDidChangeMarker.fire(markerDecorations.model);
    }
  }
};
MarkerDecorationsService = __decorate12([
  __param12(0, IModelService),
  __param12(1, IMarkerService)
], MarkerDecorationsService);
var MarkerDecorations = class extends Disposable {
  constructor(model) {
    super();
    this.model = model;
    this._map = new BidirectionalMap();
    this._register(toDisposable(() => {
      this.model.deltaDecorations([...this._map.values()], []);
      this._map.clear();
    }));
  }
  update(markers) {
    const { added, removed } = diffSets(new Set(this._map.keys()), new Set(markers));
    if (added.length === 0 && removed.length === 0) {
      return false;
    }
    const oldIds = removed.map((marker) => this._map.get(marker));
    const newDecorations = added.map((marker) => {
      return {
        range: this._createDecorationRange(this.model, marker),
        options: this._createDecorationOption(marker)
      };
    });
    const ids = this.model.deltaDecorations(oldIds, newDecorations);
    for (const removedMarker of removed) {
      this._map.delete(removedMarker);
    }
    for (let index = 0; index < ids.length; index++) {
      this._map.set(added[index], ids[index]);
    }
    return true;
  }
  getMarker(decoration) {
    return this._map.getKey(decoration.id);
  }
  _createDecorationRange(model, rawMarker) {
    let ret = Range.lift(rawMarker);
    if (rawMarker.severity === MarkerSeverity.Hint && !this._hasMarkerTag(
      rawMarker,
      1
      /* MarkerTag.Unnecessary */
    ) && !this._hasMarkerTag(
      rawMarker,
      2
      /* MarkerTag.Deprecated */
    )) {
      ret = ret.setEndPosition(ret.startLineNumber, ret.startColumn + 2);
    }
    ret = model.validateRange(ret);
    if (ret.isEmpty()) {
      const maxColumn = model.getLineLastNonWhitespaceColumn(ret.startLineNumber) || model.getLineMaxColumn(ret.startLineNumber);
      if (maxColumn === 1 || ret.endColumn >= maxColumn) {
        return ret;
      }
      const word = model.getWordAtPosition(ret.getStartPosition());
      if (word) {
        ret = new Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);
      }
    } else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {
      const minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);
      if (minColumn < ret.endColumn) {
        ret = new Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);
        rawMarker.startColumn = minColumn;
      }
    }
    return ret;
  }
  _createDecorationOption(marker) {
    let className;
    let color = void 0;
    let zIndex;
    let inlineClassName = void 0;
    let minimap;
    switch (marker.severity) {
      case MarkerSeverity.Hint:
        if (this._hasMarkerTag(
          marker,
          2
          /* MarkerTag.Deprecated */
        )) {
          className = void 0;
        } else if (this._hasMarkerTag(
          marker,
          1
          /* MarkerTag.Unnecessary */
        )) {
          className = "squiggly-unnecessary";
        } else {
          className = "squiggly-hint";
        }
        zIndex = 0;
        break;
      case MarkerSeverity.Info:
        className = "squiggly-info";
        color = themeColorFromId(overviewRulerInfo);
        zIndex = 10;
        minimap = {
          color: themeColorFromId(minimapInfo),
          position: MinimapPosition.Inline
        };
        break;
      case MarkerSeverity.Warning:
        className = "squiggly-warning";
        color = themeColorFromId(overviewRulerWarning);
        zIndex = 20;
        minimap = {
          color: themeColorFromId(minimapWarning),
          position: MinimapPosition.Inline
        };
        break;
      case MarkerSeverity.Error:
      default:
        className = "squiggly-error";
        color = themeColorFromId(overviewRulerError);
        zIndex = 30;
        minimap = {
          color: themeColorFromId(minimapError),
          position: MinimapPosition.Inline
        };
        break;
    }
    if (marker.tags) {
      if (marker.tags.indexOf(
        1
        /* MarkerTag.Unnecessary */
      ) !== -1) {
        inlineClassName = "squiggly-inline-unnecessary";
      }
      if (marker.tags.indexOf(
        2
        /* MarkerTag.Deprecated */
      ) !== -1) {
        inlineClassName = "squiggly-inline-deprecated";
      }
    }
    return {
      description: "marker-decoration",
      stickiness: 1,
      className,
      showIfCollapsed: true,
      overviewRuler: {
        color,
        position: OverviewRulerLane.Right
      },
      minimap,
      zIndex,
      inlineClassName
    };
  }
  _hasMarkerTag(marker, tag) {
    if (marker.tags) {
      return marker.tags.indexOf(tag) >= 0;
    }
    return false;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ModelService_1;
function MODEL_ID(resource) {
  return resource.toString();
}
var ModelData = class {
  constructor(model, onWillDispose, onDidChangeLanguage) {
    this.model = model;
    this._modelEventListeners = new DisposableStore();
    this.model = model;
    this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));
    this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));
  }
  dispose() {
    this._modelEventListeners.dispose();
  }
};
var DEFAULT_EOL = isLinux || isMacintosh ? 1 : 2;
var DisposedModelInfo = class {
  constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {
    this.uri = uri;
    this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;
    this.time = time;
    this.sharesUndoRedoStack = sharesUndoRedoStack;
    this.heapSize = heapSize;
    this.sha1 = sha1;
    this.versionId = versionId;
    this.alternativeVersionId = alternativeVersionId;
  }
};
var ModelService = ModelService_1 = class ModelService2 extends Disposable {
  constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _languageService, _languageConfigurationService) {
    super();
    this._configurationService = _configurationService;
    this._resourcePropertiesService = _resourcePropertiesService;
    this._undoRedoService = _undoRedoService;
    this._languageService = _languageService;
    this._languageConfigurationService = _languageConfigurationService;
    this._onModelAdded = this._register(new Emitter());
    this.onModelAdded = this._onModelAdded.event;
    this._onModelRemoved = this._register(new Emitter());
    this.onModelRemoved = this._onModelRemoved.event;
    this._onModelModeChanged = this._register(new Emitter());
    this.onModelLanguageChanged = this._onModelModeChanged.event;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    this._models = {};
    this._disposedModels = /* @__PURE__ */ new Map();
    this._disposedModelsHeapSize = 0;
    this._register(this._configurationService.onDidChangeConfiguration((e) => this._updateModelOptions(e)));
    this._updateModelOptions(void 0);
  }
  static _readModelOptions(config, isForSimpleWidget) {
    var _a;
    let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;
    if (config.editor && typeof config.editor.tabSize !== "undefined") {
      const parsedTabSize = parseInt(config.editor.tabSize, 10);
      if (!isNaN(parsedTabSize)) {
        tabSize = parsedTabSize;
      }
      if (tabSize < 1) {
        tabSize = 1;
      }
    }
    let indentSize = "tabSize";
    if (config.editor && typeof config.editor.indentSize !== "undefined" && config.editor.indentSize !== "tabSize") {
      const parsedIndentSize = parseInt(config.editor.indentSize, 10);
      if (!isNaN(parsedIndentSize)) {
        indentSize = Math.max(parsedIndentSize, 1);
      }
    }
    let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;
    if (config.editor && typeof config.editor.insertSpaces !== "undefined") {
      insertSpaces = config.editor.insertSpaces === "false" ? false : Boolean(config.editor.insertSpaces);
    }
    let newDefaultEOL = DEFAULT_EOL;
    const eol = config.eol;
    if (eol === "\r\n") {
      newDefaultEOL = 2;
    } else if (eol === "\n") {
      newDefaultEOL = 1;
    }
    let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;
    if (config.editor && typeof config.editor.trimAutoWhitespace !== "undefined") {
      trimAutoWhitespace = config.editor.trimAutoWhitespace === "false" ? false : Boolean(config.editor.trimAutoWhitespace);
    }
    let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;
    if (config.editor && typeof config.editor.detectIndentation !== "undefined") {
      detectIndentation = config.editor.detectIndentation === "false" ? false : Boolean(config.editor.detectIndentation);
    }
    let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;
    if (config.editor && typeof config.editor.largeFileOptimizations !== "undefined") {
      largeFileOptimizations = config.editor.largeFileOptimizations === "false" ? false : Boolean(config.editor.largeFileOptimizations);
    }
    let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;
    if (((_a = config.editor) === null || _a === void 0 ? void 0 : _a.bracketPairColorization) && typeof config.editor.bracketPairColorization === "object") {
      bracketPairColorizationOptions = {
        enabled: !!config.editor.bracketPairColorization.enabled,
        independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType
      };
    }
    return {
      isForSimpleWidget,
      tabSize,
      indentSize,
      insertSpaces,
      detectIndentation,
      defaultEOL: newDefaultEOL,
      trimAutoWhitespace,
      largeFileOptimizations,
      bracketPairColorizationOptions
    };
  }
  _getEOL(resource, language) {
    if (resource) {
      return this._resourcePropertiesService.getEOL(resource, language);
    }
    const eol = this._configurationService.getValue("files.eol", { overrideIdentifier: language });
    if (eol && typeof eol === "string" && eol !== "auto") {
      return eol;
    }
    return OS === 3 || OS === 2 ? "\n" : "\r\n";
  }
  _shouldRestoreUndoStack() {
    const result = this._configurationService.getValue("files.restoreUndoStack");
    if (typeof result === "boolean") {
      return result;
    }
    return true;
  }
  getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {
    const language = typeof languageIdOrSelection === "string" ? languageIdOrSelection : languageIdOrSelection.languageId;
    let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];
    if (!creationOptions) {
      const editor2 = this._configurationService.getValue("editor", { overrideIdentifier: language, resource });
      const eol = this._getEOL(resource, language);
      creationOptions = ModelService_1._readModelOptions({ editor: editor2, eol }, isForSimpleWidget);
      this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;
    }
    return creationOptions;
  }
  _updateModelOptions(e) {
    const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(this._models);
    for (let i = 0, len = keys.length; i < len; i++) {
      const modelId = keys[i];
      const modelData = this._models[modelId];
      const language = modelData.model.getLanguageId();
      const uri = modelData.model.uri;
      if (e && !e.affectsConfiguration("editor", { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration("files.eol", { overrideIdentifier: language, resource: uri })) {
        continue;
      }
      const oldOptions = oldOptionsByLanguageAndResource[language + uri];
      const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);
      ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);
    }
  }
  static _setModelOptionsForModel(model, newOptions, currentOptions) {
    if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {
      model.setEOL(
        newOptions.defaultEOL === 1 ? 0 : 1
        /* EndOfLineSequence.CRLF */
      );
    }
    if (currentOptions && currentOptions.detectIndentation === newOptions.detectIndentation && currentOptions.insertSpaces === newOptions.insertSpaces && currentOptions.tabSize === newOptions.tabSize && currentOptions.indentSize === newOptions.indentSize && currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace && equals2(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {
      return;
    }
    if (newOptions.detectIndentation) {
      model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);
      model.updateOptions({
        trimAutoWhitespace: newOptions.trimAutoWhitespace,
        bracketColorizationOptions: newOptions.bracketPairColorizationOptions
      });
    } else {
      model.updateOptions({
        insertSpaces: newOptions.insertSpaces,
        tabSize: newOptions.tabSize,
        indentSize: newOptions.indentSize,
        trimAutoWhitespace: newOptions.trimAutoWhitespace,
        bracketColorizationOptions: newOptions.bracketPairColorizationOptions
      });
    }
  }
  // --- begin IModelService
  _insertDisposedModel(disposedModelData) {
    this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);
    this._disposedModelsHeapSize += disposedModelData.heapSize;
  }
  _removeDisposedModel(resource) {
    const disposedModelData = this._disposedModels.get(MODEL_ID(resource));
    if (disposedModelData) {
      this._disposedModelsHeapSize -= disposedModelData.heapSize;
    }
    this._disposedModels.delete(MODEL_ID(resource));
    return disposedModelData;
  }
  _ensureDisposedModelsHeapSize(maxModelsHeapSize) {
    if (this._disposedModelsHeapSize > maxModelsHeapSize) {
      const disposedModels = [];
      this._disposedModels.forEach((entry) => {
        if (!entry.sharesUndoRedoStack) {
          disposedModels.push(entry);
        }
      });
      disposedModels.sort((a, b) => a.time - b.time);
      while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {
        const disposedModel = disposedModels.shift();
        this._removeDisposedModel(disposedModel.uri);
        if (disposedModel.initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);
        }
      }
    }
  }
  _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {
    const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);
    const model = new TextModel(value, languageIdOrSelection, options, resource, this._undoRedoService, this._languageService, this._languageConfigurationService);
    if (resource && this._disposedModels.has(MODEL_ID(resource))) {
      const disposedModelData = this._removeDisposedModel(resource);
      const elements = this._undoRedoService.getElements(resource);
      const sha1Computer = this._getSHA1Computer();
      const sha1IsEqual = sha1Computer.canComputeSHA1(model) ? sha1Computer.computeSHA1(model) === disposedModelData.sha1 : false;
      if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {
        for (const element of elements.past) {
          if (isEditStackElement(element) && element.matchesResource(resource)) {
            element.setModel(model);
          }
        }
        for (const element of elements.future) {
          if (isEditStackElement(element) && element.matchesResource(resource)) {
            element.setModel(model);
          }
        }
        this._undoRedoService.setElementsValidFlag(resource, true, (element) => isEditStackElement(element) && element.matchesResource(resource));
        if (sha1IsEqual) {
          model._overwriteVersionId(disposedModelData.versionId);
          model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);
          model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);
        }
      } else {
        if (disposedModelData.initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);
        }
      }
    }
    const modelId = MODEL_ID(model.uri);
    if (this._models[modelId]) {
      throw new Error("ModelService: Cannot add model because it already exists!");
    }
    const modelData = new ModelData(model, (model2) => this._onWillDispose(model2), (model2, e) => this._onDidChangeLanguage(model2, e));
    this._models[modelId] = modelData;
    return modelData;
  }
  createModel(value, languageSelection, resource, isForSimpleWidget = false) {
    let modelData;
    if (languageSelection) {
      modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);
    } else {
      modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);
    }
    this._onModelAdded.fire(modelData.model);
    return modelData.model;
  }
  getModels() {
    const ret = [];
    const keys = Object.keys(this._models);
    for (let i = 0, len = keys.length; i < len; i++) {
      const modelId = keys[i];
      ret.push(this._models[modelId].model);
    }
    return ret;
  }
  getModel(resource) {
    const modelId = MODEL_ID(resource);
    const modelData = this._models[modelId];
    if (!modelData) {
      return null;
    }
    return modelData.model;
  }
  // --- end IModelService
  _schemaShouldMaintainUndoRedoElements(resource) {
    return resource.scheme === Schemas.file || resource.scheme === Schemas.vscodeRemote || resource.scheme === Schemas.vscodeUserData || resource.scheme === Schemas.vscodeNotebookCell || resource.scheme === "fake-fs";
  }
  _onWillDispose(model) {
    const modelId = MODEL_ID(model.uri);
    const modelData = this._models[modelId];
    const sharesUndoRedoStack = this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString();
    let maintainUndoRedoStack = false;
    let heapSize = 0;
    if (sharesUndoRedoStack || this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri)) {
      const elements = this._undoRedoService.getElements(model.uri);
      if (elements.past.length > 0 || elements.future.length > 0) {
        for (const element of elements.past) {
          if (isEditStackElement(element) && element.matchesResource(model.uri)) {
            maintainUndoRedoStack = true;
            heapSize += element.heapSize(model.uri);
            element.setModel(model.uri);
          }
        }
        for (const element of elements.future) {
          if (isEditStackElement(element) && element.matchesResource(model.uri)) {
            maintainUndoRedoStack = true;
            heapSize += element.heapSize(model.uri);
            element.setModel(model.uri);
          }
        }
      }
    }
    const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;
    const sha1Computer = this._getSHA1Computer();
    if (!maintainUndoRedoStack) {
      if (!sharesUndoRedoStack) {
        const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();
        if (initialUndoRedoSnapshot !== null) {
          this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);
        }
      }
    } else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {
      const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();
      if (initialUndoRedoSnapshot !== null) {
        this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);
      }
    } else {
      this._ensureDisposedModelsHeapSize(maxMemory - heapSize);
      this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => isEditStackElement(element) && element.matchesResource(model.uri));
      this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));
    }
    delete this._models[modelId];
    modelData.dispose();
    delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];
    this._onModelRemoved.fire(model);
  }
  _onDidChangeLanguage(model, e) {
    const oldLanguageId = e.oldLanguage;
    const newLanguageId = model.getLanguageId();
    const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);
    const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);
    ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);
    this._onModelModeChanged.fire({ model, oldLanguageId });
  }
  _getSHA1Computer() {
    return new DefaultModelSHA1Computer();
  }
};
ModelService.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;
ModelService = ModelService_1 = __decorate13([
  __param13(0, IConfigurationService),
  __param13(1, ITextResourcePropertiesService),
  __param13(2, IUndoRedoService),
  __param13(3, ILanguageService),
  __param13(4, ILanguageConfigurationService)
], ModelService);
var DefaultModelSHA1Computer = class _DefaultModelSHA1Computer {
  canComputeSHA1(model) {
    return model.getValueLength() <= _DefaultModelSHA1Computer.MAX_MODEL_SIZE;
  }
  computeSHA1(model) {
    const shaComputer = new StringSHA1();
    const snapshot = model.createSnapshot();
    let text;
    while (text = snapshot.read()) {
      shaComputer.update(text);
    }
    return shaComputer.digest();
  }
};
DefaultModelSHA1Computer.MAX_MODEL_SIZE = 10 * 1024 * 1024;

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInput.css";

// node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickAccess.js
var DefaultQuickAccessFilterValue;
(function(DefaultQuickAccessFilterValue2) {
  DefaultQuickAccessFilterValue2[DefaultQuickAccessFilterValue2["PRESERVE"] = 0] = "PRESERVE";
  DefaultQuickAccessFilterValue2[DefaultQuickAccessFilterValue2["LAST"] = 1] = "LAST";
})(DefaultQuickAccessFilterValue || (DefaultQuickAccessFilterValue = {}));
var Extensions4 = {
  Quickaccess: "workbench.contributions.quickaccess"
};
var QuickAccessRegistry = class {
  constructor() {
    this.providers = [];
    this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(provider) {
    if (provider.prefix.length === 0) {
      this.defaultProvider = provider;
    } else {
      this.providers.push(provider);
    }
    this.providers.sort((providerA, providerB) => providerB.prefix.length - providerA.prefix.length);
    return toDisposable(() => {
      this.providers.splice(this.providers.indexOf(provider), 1);
      if (this.defaultProvider === provider) {
        this.defaultProvider = void 0;
      }
    });
  }
  getQuickAccessProviders() {
    return coalesce([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(prefix) {
    const result = prefix ? this.providers.find((provider) => prefix.startsWith(provider.prefix)) || void 0 : void 0;
    return result || this.defaultProvider;
  }
};
Registry.add(Extensions4.Quickaccess, new QuickAccessRegistry());

// node_modules/monaco-editor/esm/vs/platform/quickinput/common/quickInput.js
var NO_KEY_MODS = { ctrlCmd: false, alt: false };
var QuickInputHideReason;
(function(QuickInputHideReason2) {
  QuickInputHideReason2[QuickInputHideReason2["Blur"] = 1] = "Blur";
  QuickInputHideReason2[QuickInputHideReason2["Gesture"] = 2] = "Gesture";
  QuickInputHideReason2[QuickInputHideReason2["Other"] = 3] = "Other";
})(QuickInputHideReason || (QuickInputHideReason = {}));
var ItemActivation;
(function(ItemActivation2) {
  ItemActivation2[ItemActivation2["NONE"] = 0] = "NONE";
  ItemActivation2[ItemActivation2["FIRST"] = 1] = "FIRST";
  ItemActivation2[ItemActivation2["SECOND"] = 2] = "SECOND";
  ItemActivation2[ItemActivation2["LAST"] = 3] = "LAST";
})(ItemActivation || (ItemActivation = {}));
var QuickPickItemScorerAccessor = class {
  constructor(options) {
    this.options = options;
  }
};
var quickPickItemScorerAccessor = new QuickPickItemScorerAccessor();
var IQuickInputService = createDecorator("quickInputService");

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickAccess.js
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var QuickAccessController = class QuickAccessController2 extends Disposable {
  constructor(quickInputService, instantiationService) {
    super();
    this.quickInputService = quickInputService;
    this.instantiationService = instantiationService;
    this.registry = Registry.as(Extensions4.Quickaccess);
    this.mapProviderToDescriptor = /* @__PURE__ */ new Map();
    this.lastAcceptedPickerValues = /* @__PURE__ */ new Map();
    this.visibleQuickAccess = void 0;
  }
  show(value = "", options) {
    this.doShowOrPick(value, false, options);
  }
  doShowOrPick(value, pick, options) {
    var _a;
    const [provider, descriptor] = this.getOrInstantiateProvider(value);
    const visibleQuickAccess = this.visibleQuickAccess;
    const visibleDescriptor = visibleQuickAccess === null || visibleQuickAccess === void 0 ? void 0 : visibleQuickAccess.descriptor;
    if (visibleQuickAccess && descriptor && visibleDescriptor === descriptor) {
      if (value !== descriptor.prefix && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {
        visibleQuickAccess.picker.value = value;
      }
      this.adjustValueSelection(visibleQuickAccess.picker, descriptor, options);
      return;
    }
    if (descriptor && !(options === null || options === void 0 ? void 0 : options.preserveValue)) {
      let newValue = void 0;
      if (visibleQuickAccess && visibleDescriptor && visibleDescriptor !== descriptor) {
        const newValueCandidateWithoutPrefix = visibleQuickAccess.value.substr(visibleDescriptor.prefix.length);
        if (newValueCandidateWithoutPrefix) {
          newValue = `${descriptor.prefix}${newValueCandidateWithoutPrefix}`;
        }
      }
      if (!newValue) {
        const defaultFilterValue = provider === null || provider === void 0 ? void 0 : provider.defaultFilterValue;
        if (defaultFilterValue === DefaultQuickAccessFilterValue.LAST) {
          newValue = this.lastAcceptedPickerValues.get(descriptor);
        } else if (typeof defaultFilterValue === "string") {
          newValue = `${descriptor.prefix}${defaultFilterValue}`;
        }
      }
      if (typeof newValue === "string") {
        value = newValue;
      }
    }
    const disposables = new DisposableStore();
    const picker = disposables.add(this.quickInputService.createQuickPick());
    picker.value = value;
    this.adjustValueSelection(picker, descriptor, options);
    picker.placeholder = descriptor === null || descriptor === void 0 ? void 0 : descriptor.placeholder;
    picker.quickNavigate = options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration;
    picker.hideInput = !!picker.quickNavigate && !visibleQuickAccess;
    if (typeof (options === null || options === void 0 ? void 0 : options.itemActivation) === "number" || (options === null || options === void 0 ? void 0 : options.quickNavigateConfiguration)) {
      picker.itemActivation = (_a = options === null || options === void 0 ? void 0 : options.itemActivation) !== null && _a !== void 0 ? _a : ItemActivation.SECOND;
    }
    picker.contextKey = descriptor === null || descriptor === void 0 ? void 0 : descriptor.contextKey;
    picker.filterValue = (value2) => value2.substring(descriptor ? descriptor.prefix.length : 0);
    let pickPromise = void 0;
    if (pick) {
      pickPromise = new DeferredPromise();
      disposables.add(Event.once(picker.onWillAccept)((e) => {
        e.veto();
        picker.hide();
      }));
    }
    disposables.add(this.registerPickerListeners(picker, provider, descriptor, value, options === null || options === void 0 ? void 0 : options.providerOptions));
    const cts = disposables.add(new CancellationTokenSource());
    if (provider) {
      disposables.add(provider.provide(picker, cts.token, options === null || options === void 0 ? void 0 : options.providerOptions));
    }
    Event.once(picker.onDidHide)(() => {
      if (picker.selectedItems.length === 0) {
        cts.cancel();
      }
      disposables.dispose();
      pickPromise === null || pickPromise === void 0 ? void 0 : pickPromise.complete(picker.selectedItems.slice(0));
    });
    picker.show();
    if (pick) {
      return pickPromise === null || pickPromise === void 0 ? void 0 : pickPromise.p;
    }
  }
  adjustValueSelection(picker, descriptor, options) {
    var _a;
    let valueSelection;
    if (options === null || options === void 0 ? void 0 : options.preserveValue) {
      valueSelection = [picker.value.length, picker.value.length];
    } else {
      valueSelection = [(_a = descriptor === null || descriptor === void 0 ? void 0 : descriptor.prefix.length) !== null && _a !== void 0 ? _a : 0, picker.value.length];
    }
    picker.valueSelection = valueSelection;
  }
  registerPickerListeners(picker, provider, descriptor, value, providerOptions) {
    const disposables = new DisposableStore();
    const visibleQuickAccess = this.visibleQuickAccess = { picker, descriptor, value };
    disposables.add(toDisposable(() => {
      if (visibleQuickAccess === this.visibleQuickAccess) {
        this.visibleQuickAccess = void 0;
      }
    }));
    disposables.add(picker.onDidChangeValue((value2) => {
      const [providerForValue] = this.getOrInstantiateProvider(value2);
      if (providerForValue !== provider) {
        this.show(value2, {
          // do not rewrite value from user typing!
          preserveValue: true,
          // persist the value of the providerOptions from the original showing
          providerOptions
        });
      } else {
        visibleQuickAccess.value = value2;
      }
    }));
    if (descriptor) {
      disposables.add(picker.onDidAccept(() => {
        this.lastAcceptedPickerValues.set(descriptor, picker.value);
      }));
    }
    return disposables;
  }
  getOrInstantiateProvider(value) {
    const providerDescriptor = this.registry.getQuickAccessProvider(value);
    if (!providerDescriptor) {
      return [void 0, void 0];
    }
    let provider = this.mapProviderToDescriptor.get(providerDescriptor);
    if (!provider) {
      provider = this.instantiationService.createInstance(providerDescriptor.ctor);
      this.mapProviderToDescriptor.set(providerDescriptor, provider);
    }
    return [provider, providerDescriptor];
  }
};
QuickAccessController = __decorate14([
  __param14(0, IQuickInputService),
  __param14(1, IInstantiationService)
], QuickAccessController);

// node_modules/monaco-editor/esm/vs/base/browser/ui/button/button.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/base/browser/ui/button/button.css";
var unthemedButtonStyles = {
  buttonBackground: "#0E639C",
  buttonHoverBackground: "#006BB3",
  buttonSeparator: Color.white.toString(),
  buttonForeground: Color.white.toString(),
  buttonBorder: void 0,
  buttonSecondaryBackground: void 0,
  buttonSecondaryForeground: void 0,
  buttonSecondaryHoverBackground: void 0
};
var Button = class extends Disposable {
  get onDidClick() {
    return this._onDidClick.event;
  }
  constructor(container, options) {
    super();
    this._label = "";
    this._onDidClick = this._register(new Emitter());
    this.options = options;
    this._element = document.createElement("a");
    this._element.classList.add("monaco-button");
    this._element.tabIndex = 0;
    this._element.setAttribute("role", "button");
    this._element.classList.toggle("secondary", !!options.secondary);
    const background = options.secondary ? options.buttonSecondaryBackground : options.buttonBackground;
    const foreground = options.secondary ? options.buttonSecondaryForeground : options.buttonForeground;
    this._element.style.color = foreground || "";
    this._element.style.backgroundColor = background || "";
    if (options.supportShortLabel) {
      this._labelShortElement = document.createElement("div");
      this._labelShortElement.classList.add("monaco-button-label-short");
      this._element.appendChild(this._labelShortElement);
      this._labelElement = document.createElement("div");
      this._labelElement.classList.add("monaco-button-label");
      this._element.appendChild(this._labelElement);
      this._element.classList.add("monaco-text-button-with-short-label");
    }
    container.appendChild(this._element);
    this._register(Gesture.addTarget(this._element));
    [EventType.CLICK, EventType2.Tap].forEach((eventType) => {
      this._register(addDisposableListener(this._element, eventType, (e) => {
        if (!this.enabled) {
          EventHelper.stop(e);
          return;
        }
        this._onDidClick.fire(e);
      }));
    });
    this._register(addDisposableListener(this._element, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      let eventHandled = false;
      if (this.enabled && (event.equals(
        3
        /* KeyCode.Enter */
      ) || event.equals(
        10
        /* KeyCode.Space */
      ))) {
        this._onDidClick.fire(e);
        eventHandled = true;
      } else if (event.equals(
        9
        /* KeyCode.Escape */
      )) {
        this._element.blur();
        eventHandled = true;
      }
      if (eventHandled) {
        EventHelper.stop(event, true);
      }
    }));
    this._register(addDisposableListener(this._element, EventType.MOUSE_OVER, (e) => {
      if (!this._element.classList.contains("disabled")) {
        this.updateBackground(true);
      }
    }));
    this._register(addDisposableListener(this._element, EventType.MOUSE_OUT, (e) => {
      this.updateBackground(false);
    }));
    this.focusTracker = this._register(trackFocus(this._element));
    this._register(this.focusTracker.onDidFocus(() => {
      if (this.enabled) {
        this.updateBackground(true);
      }
    }));
    this._register(this.focusTracker.onDidBlur(() => {
      if (this.enabled) {
        this.updateBackground(false);
      }
    }));
  }
  dispose() {
    super.dispose();
    this._element.remove();
  }
  getContentElements(content) {
    const elements = [];
    for (let segment of renderLabelWithIcons(content)) {
      if (typeof segment === "string") {
        segment = segment.trim();
        if (segment === "") {
          continue;
        }
        const node = document.createElement("span");
        node.textContent = segment;
        elements.push(node);
      } else {
        elements.push(segment);
      }
    }
    return elements;
  }
  updateBackground(hover) {
    let background;
    if (this.options.secondary) {
      background = hover ? this.options.buttonSecondaryHoverBackground : this.options.buttonSecondaryBackground;
    } else {
      background = hover ? this.options.buttonHoverBackground : this.options.buttonBackground;
    }
    if (background) {
      this._element.style.backgroundColor = background;
    }
  }
  get element() {
    return this._element;
  }
  set label(value) {
    var _a;
    if (this._label === value) {
      return;
    }
    if (isMarkdownString(this._label) && isMarkdownString(value) && markdownStringEqual(this._label, value)) {
      return;
    }
    this._element.classList.add("monaco-text-button");
    const labelElement = this.options.supportShortLabel ? this._labelElement : this._element;
    if (isMarkdownString(value)) {
      const rendered = renderMarkdown(value, { inline: true });
      rendered.dispose();
      const root = (_a = rendered.element.querySelector("p")) === null || _a === void 0 ? void 0 : _a.innerHTML;
      if (root) {
        const sanitized = sanitize(root, { ADD_TAGS: ["b", "i", "u", "code", "span"], ALLOWED_ATTR: ["class"], RETURN_TRUSTED_TYPE: true });
        labelElement.innerHTML = sanitized;
      } else {
        reset(labelElement);
      }
    } else {
      if (this.options.supportIcons) {
        reset(labelElement, ...this.getContentElements(value));
      } else {
        labelElement.textContent = value;
      }
    }
    if (typeof this.options.title === "string") {
      this._element.title = this.options.title;
    } else if (this.options.title) {
      this._element.title = renderStringAsPlaintext(value);
    }
    this._label = value;
  }
  get label() {
    return this._label;
  }
  set icon(icon) {
    this._element.classList.add(...ThemeIcon.asClassNameArray(icon));
  }
  set enabled(value) {
    if (value) {
      this._element.classList.remove("disabled");
      this._element.setAttribute("aria-disabled", String(false));
      this._element.tabIndex = 0;
    } else {
      this._element.classList.add("disabled");
      this._element.setAttribute("aria-disabled", String(true));
    }
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.css";
var CSS_DONE = "done";
var CSS_ACTIVE = "active";
var CSS_INFINITE = "infinite";
var CSS_INFINITE_LONG_RUNNING = "infinite-long-running";
var CSS_DISCRETE = "discrete";
var ProgressBar = class _ProgressBar extends Disposable {
  constructor(container, options) {
    super();
    this.workedVal = 0;
    this.showDelayedScheduler = this._register(new RunOnceScheduler(() => show(this.element), 0));
    this.longRunningScheduler = this._register(new RunOnceScheduler(() => this.infiniteLongRunning(), _ProgressBar.LONG_RUNNING_INFINITE_THRESHOLD));
    this.create(container, options);
  }
  create(container, options) {
    this.element = document.createElement("div");
    this.element.classList.add("monaco-progress-container");
    this.element.setAttribute("role", "progressbar");
    this.element.setAttribute("aria-valuemin", "0");
    container.appendChild(this.element);
    this.bit = document.createElement("div");
    this.bit.classList.add("progress-bit");
    this.bit.style.backgroundColor = (options === null || options === void 0 ? void 0 : options.progressBarBackground) || "#0E70C0";
    this.element.appendChild(this.bit);
  }
  off() {
    this.bit.style.width = "inherit";
    this.bit.style.opacity = "1";
    this.element.classList.remove(CSS_ACTIVE, CSS_INFINITE, CSS_INFINITE_LONG_RUNNING, CSS_DISCRETE);
    this.workedVal = 0;
    this.totalWork = void 0;
    this.longRunningScheduler.cancel();
  }
  /**
   * Stops the progressbar from showing any progress instantly without fading out.
   */
  stop() {
    return this.doDone(false);
  }
  doDone(delayed) {
    this.element.classList.add(CSS_DONE);
    if (!this.element.classList.contains(CSS_INFINITE)) {
      this.bit.style.width = "inherit";
      if (delayed) {
        setTimeout(() => this.off(), 200);
      } else {
        this.off();
      }
    } else {
      this.bit.style.opacity = "0";
      if (delayed) {
        setTimeout(() => this.off(), 200);
      } else {
        this.off();
      }
    }
    return this;
  }
  /**
   * Use this mode to indicate progress that has no total number of work units.
   */
  infinite() {
    this.bit.style.width = "2%";
    this.bit.style.opacity = "1";
    this.element.classList.remove(CSS_DISCRETE, CSS_DONE, CSS_INFINITE_LONG_RUNNING);
    this.element.classList.add(CSS_ACTIVE, CSS_INFINITE);
    this.longRunningScheduler.schedule();
    return this;
  }
  infiniteLongRunning() {
    this.element.classList.add(CSS_INFINITE_LONG_RUNNING);
  }
  getContainer() {
    return this.element;
  }
};
ProgressBar.LONG_RUNNING_INFINITE_THRESHOLD = 1e4;

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputBox.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/media/quickInput.css";
var $2 = $;
var QuickInputBox = class extends Disposable {
  constructor(parent, inputBoxStyles, toggleStyles) {
    super();
    this.parent = parent;
    this.onKeyDown = (handler) => {
      return addStandardDisposableListener(this.findInput.inputBox.inputElement, EventType.KEY_DOWN, handler);
    };
    this.onMouseDown = (handler) => {
      return addStandardDisposableListener(this.findInput.inputBox.inputElement, EventType.MOUSE_DOWN, handler);
    };
    this.onDidChange = (handler) => {
      return this.findInput.onDidChange(handler);
    };
    this.container = append(this.parent, $2(".quick-input-box"));
    this.findInput = this._register(new FindInput(this.container, void 0, { label: "", inputBoxStyles, toggleStyles }));
    const input = this.findInput.inputBox.inputElement;
    input.role = "combobox";
    input.ariaHasPopup = "menu";
    input.ariaAutoComplete = "list";
    input.ariaExpanded = "true";
  }
  get value() {
    return this.findInput.getValue();
  }
  set value(value) {
    this.findInput.setValue(value);
  }
  select(range2 = null) {
    this.findInput.inputBox.select(range2);
  }
  isSelectionAtEnd() {
    return this.findInput.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.findInput.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(placeholder) {
    this.findInput.inputBox.setPlaceHolder(placeholder);
  }
  get password() {
    return this.findInput.inputBox.inputElement.type === "password";
  }
  set password(password) {
    this.findInput.inputBox.inputElement.type = password ? "password" : "text";
  }
  set enabled(enabled) {
    this.findInput.inputBox.inputElement.toggleAttribute("readonly", !enabled);
  }
  set toggles(toggles) {
    this.findInput.setAdditionalToggles(toggles);
  }
  setAttribute(name, value) {
    this.findInput.inputBox.inputElement.setAttribute(name, value);
  }
  showDecoration(decoration) {
    if (decoration === severity_default.Ignore) {
      this.findInput.clearMessage();
    } else {
      this.findInput.showMessage({ type: decoration === severity_default.Info ? 1 : decoration === severity_default.Warning ? 2 : 3, content: "" });
    }
  }
  stylesForType(decoration) {
    return this.findInput.inputBox.stylesForType(
      decoration === severity_default.Info ? 1 : decoration === severity_default.Warning ? 2 : 3
      /* MessageType.ERROR */
    );
  }
  setFocus() {
    this.findInput.focus();
  }
  layout() {
    this.findInput.inputBox.layout();
  }
};

// node_modules/monaco-editor/esm/vs/base/common/comparers.js
var intlFileNameCollatorBaseNumeric = new Lazy(() => {
  const collator = new Intl.Collator(void 0, { numeric: true, sensitivity: "base" });
  return {
    collator,
    collatorIsNumeric: collator.resolvedOptions().numeric
  };
});
var intlFileNameCollatorNumeric = new Lazy(() => {
  const collator = new Intl.Collator(void 0, { numeric: true });
  return {
    collator
  };
});
var intlFileNameCollatorNumericCaseInsensitive = new Lazy(() => {
  const collator = new Intl.Collator(void 0, { numeric: true, sensitivity: "accent" });
  return {
    collator
  };
});
function compareFileNames(one, other, caseSensitive = false) {
  const a = one || "";
  const b = other || "";
  const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);
  if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {
    return a < b ? -1 : 1;
  }
  return result;
}
function compareAnything(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const prefixCompare = compareByPrefix(one, other, lookFor);
  if (prefixCompare) {
    return prefixCompare;
  }
  const elementASuffixMatch = elementAName.endsWith(lookFor);
  const elementBSuffixMatch = elementBName.endsWith(lookFor);
  if (elementASuffixMatch !== elementBSuffixMatch) {
    return elementASuffixMatch ? -1 : 1;
  }
  const r = compareFileNames(elementAName, elementBName);
  if (r !== 0) {
    return r;
  }
  return elementAName.localeCompare(elementBName);
}
function compareByPrefix(one, other, lookFor) {
  const elementAName = one.toLowerCase();
  const elementBName = other.toLowerCase();
  const elementAPrefixMatch = elementAName.startsWith(lookFor);
  const elementBPrefixMatch = elementBName.startsWith(lookFor);
  if (elementAPrefixMatch !== elementBPrefixMatch) {
    return elementAPrefixMatch ? -1 : 1;
  } else if (elementAPrefixMatch && elementBPrefixMatch) {
    if (elementAName.length < elementBName.length) {
      return -1;
    }
    if (elementAName.length > elementBName.length) {
      return 1;
    }
  }
  return 0;
}

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputList.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/media/quickInput.css";

// node_modules/monaco-editor/esm/vs/base/common/linkedText.js
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LinkedText = class {
  constructor(nodes) {
    this.nodes = nodes;
  }
  toString() {
    return this.nodes.map((node) => typeof node === "string" ? node : node.label).join("");
  }
};
__decorate15([
  memoize
], LinkedText.prototype, "toString", null);
var LINK_REGEX = /\[([^\]]+)\]\(((?:https?:\/\/|command:|file:)[^\)\s]+)(?: (["'])(.+?)(\3))?\)/gi;
function parseLinkedText(text) {
  const result = [];
  let index = 0;
  let match2;
  while (match2 = LINK_REGEX.exec(text)) {
    if (match2.index - index > 0) {
      result.push(text.substring(index, match2.index));
    }
    const [, label, href, , title] = match2;
    if (title) {
      result.push({ label, href, title });
    } else {
      result.push({ label, href });
    }
    index = match2.index + match2[0].length;
  }
  if (index < text.length) {
    result.push(text.substring(index));
  }
  return new LinkedText(result);
}

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputUtils.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/media/quickInput.css";
var iconPathToClass = {};
var iconClassGenerator = new IdGenerator("quick-input-button-icon-");
function getIconClass(iconPath) {
  if (!iconPath) {
    return void 0;
  }
  let iconClass;
  const key = iconPath.dark.toString();
  if (iconPathToClass[key]) {
    iconClass = iconPathToClass[key];
  } else {
    iconClass = iconClassGenerator.nextId();
    createCSSRule(`.${iconClass}, .hc-light .${iconClass}`, `background-image: ${asCSSUrl(iconPath.light || iconPath.dark)}`);
    createCSSRule(`.vs-dark .${iconClass}, .hc-black .${iconClass}`, `background-image: ${asCSSUrl(iconPath.dark)}`);
    iconPathToClass[key] = iconClass;
  }
  return iconClass;
}
function renderQuickInputDescription(description, container, actionHandler) {
  reset(container);
  const parsed = parseLinkedText(description);
  let tabIndex = 0;
  for (const node of parsed.nodes) {
    if (typeof node === "string") {
      container.append(...renderLabelWithIcons(node));
    } else {
      let title = node.title;
      if (!title && node.href.startsWith("command:")) {
        title = localize("executeCommand", "Click to execute command '{0}'", node.href.substring("command:".length));
      } else if (!title) {
        title = node.href;
      }
      const anchor = $("a", { href: node.href, title, tabIndex: tabIndex++ }, node.label);
      anchor.style.textDecoration = "underline";
      const handleOpen = (e) => {
        if (isEventLike(e)) {
          EventHelper.stop(e, true);
        }
        actionHandler.callback(node.href);
      };
      const onClick = actionHandler.disposables.add(new DomEmitter(anchor, EventType.CLICK)).event;
      const onKeydown = actionHandler.disposables.add(new DomEmitter(anchor, EventType.KEY_DOWN)).event;
      const onSpaceOrEnter = Event.chain(onKeydown, ($5) => $5.filter((e) => {
        const event = new StandardKeyboardEvent(e);
        return event.equals(
          10
          /* KeyCode.Space */
        ) || event.equals(
          3
          /* KeyCode.Enter */
        );
      }));
      actionHandler.disposables.add(Gesture.addTarget(anchor));
      const onTap = actionHandler.disposables.add(new DomEmitter(anchor, EventType2.Tap)).event;
      Event.any(onClick, onTap, onSpaceOrEnter)(handleOpen, null, actionHandler.disposables);
      container.appendChild(anchor);
    }
  }
}

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputList.js
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var $3 = $;
var ListElement = class {
  constructor(mainItem, previous, index, hasCheckbox, fireButtonTriggered, fireSeparatorButtonTriggered, onCheckedEmitter) {
    var _a, _b, _c;
    this._checked = false;
    this._hidden = false;
    this.hasCheckbox = hasCheckbox;
    this.index = index;
    this.fireButtonTriggered = fireButtonTriggered;
    this.fireSeparatorButtonTriggered = fireSeparatorButtonTriggered;
    this._onChecked = onCheckedEmitter;
    this.onChecked = hasCheckbox ? Event.map(Event.filter(this._onChecked.event, (e) => e.listElement === this), (e) => e.checked) : Event.None;
    if (mainItem.type === "separator") {
      this._separator = mainItem;
    } else {
      this.item = mainItem;
      if (previous && previous.type === "separator" && !previous.buttons) {
        this._separator = previous;
      }
      this.saneDescription = this.item.description;
      this.saneDetail = this.item.detail;
      this._labelHighlights = (_a = this.item.highlights) === null || _a === void 0 ? void 0 : _a.label;
      this._descriptionHighlights = (_b = this.item.highlights) === null || _b === void 0 ? void 0 : _b.description;
      this._detailHighlights = (_c = this.item.highlights) === null || _c === void 0 ? void 0 : _c.detail;
      this.saneTooltip = this.item.tooltip;
    }
    this._init = new Lazy(() => {
      var _a2;
      const saneLabel = (_a2 = mainItem.label) !== null && _a2 !== void 0 ? _a2 : "";
      const saneSortLabel = parseLabelWithIcons(saneLabel).text.trim();
      const saneAriaLabel = mainItem.ariaLabel || [saneLabel, this.saneDescription, this.saneDetail].map((s) => getCodiconAriaLabel(s)).filter((s) => !!s).join(", ");
      return {
        saneLabel,
        saneSortLabel,
        saneAriaLabel
      };
    });
  }
  // #region Lazy Getters
  get saneLabel() {
    return this._init.value.saneLabel;
  }
  get saneSortLabel() {
    return this._init.value.saneSortLabel;
  }
  get saneAriaLabel() {
    return this._init.value.saneAriaLabel;
  }
  // #endregion
  // #region Getters and Setters
  get element() {
    return this._element;
  }
  set element(value) {
    this._element = value;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(value) {
    this._hidden = value;
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    if (value !== this._checked) {
      this._checked = value;
      this._onChecked.fire({ listElement: this, checked: value });
    }
  }
  get separator() {
    return this._separator;
  }
  set separator(value) {
    this._separator = value;
  }
  get labelHighlights() {
    return this._labelHighlights;
  }
  set labelHighlights(value) {
    this._labelHighlights = value;
  }
  get descriptionHighlights() {
    return this._descriptionHighlights;
  }
  set descriptionHighlights(value) {
    this._descriptionHighlights = value;
  }
  get detailHighlights() {
    return this._detailHighlights;
  }
  set detailHighlights(value) {
    this._detailHighlights = value;
  }
};
var ListElementRenderer = class _ListElementRenderer {
  constructor(themeService) {
    this.themeService = themeService;
  }
  get templateId() {
    return _ListElementRenderer.ID;
  }
  renderTemplate(container) {
    const data = /* @__PURE__ */ Object.create(null);
    data.toDisposeElement = [];
    data.toDisposeTemplate = [];
    data.entry = append(container, $3(".quick-input-list-entry"));
    const label = append(data.entry, $3("label.quick-input-list-label"));
    data.toDisposeTemplate.push(addStandardDisposableListener(label, EventType.CLICK, (e) => {
      if (!data.checkbox.offsetParent) {
        e.preventDefault();
      }
    }));
    data.checkbox = append(label, $3("input.quick-input-list-checkbox"));
    data.checkbox.type = "checkbox";
    data.toDisposeTemplate.push(addStandardDisposableListener(data.checkbox, EventType.CHANGE, (e) => {
      data.element.checked = data.checkbox.checked;
    }));
    const rows = append(label, $3(".quick-input-list-rows"));
    const row1 = append(rows, $3(".quick-input-list-row"));
    const row2 = append(rows, $3(".quick-input-list-row"));
    data.label = new IconLabel(row1, { supportHighlights: true, supportDescriptionHighlights: true, supportIcons: true });
    data.toDisposeTemplate.push(data.label);
    data.icon = prepend(data.label.element, $3(".quick-input-list-icon"));
    const keybindingContainer = append(row1, $3(".quick-input-list-entry-keybinding"));
    data.keybinding = new KeybindingLabel(keybindingContainer, OS);
    const detailContainer = append(row2, $3(".quick-input-list-label-meta"));
    data.detail = new IconLabel(detailContainer, { supportHighlights: true, supportIcons: true });
    data.toDisposeTemplate.push(data.detail);
    data.separator = append(data.entry, $3(".quick-input-list-separator"));
    data.actionBar = new ActionBar(data.entry);
    data.actionBar.domNode.classList.add("quick-input-list-entry-action-bar");
    data.toDisposeTemplate.push(data.actionBar);
    return data;
  }
  renderElement(element, index, data) {
    var _a, _b, _c, _d;
    data.element = element;
    element.element = (_a = data.entry) !== null && _a !== void 0 ? _a : void 0;
    const mainItem = element.item ? element.item : element.separator;
    data.checkbox.checked = element.checked;
    data.toDisposeElement.push(element.onChecked((checked) => data.checkbox.checked = checked));
    const { labelHighlights, descriptionHighlights, detailHighlights } = element;
    if ((_b = element.item) === null || _b === void 0 ? void 0 : _b.iconPath) {
      const icon = isDark(this.themeService.getColorTheme().type) ? element.item.iconPath.dark : (_c = element.item.iconPath.light) !== null && _c !== void 0 ? _c : element.item.iconPath.dark;
      const iconUrl = URI.revive(icon);
      data.icon.className = "quick-input-list-icon";
      data.icon.style.backgroundImage = asCSSUrl(iconUrl);
    } else {
      data.icon.style.backgroundImage = "";
      data.icon.className = ((_d = element.item) === null || _d === void 0 ? void 0 : _d.iconClass) ? `quick-input-list-icon ${element.item.iconClass}` : "";
    }
    const options = {
      matches: labelHighlights || [],
      descriptionTitle: element.saneDescription,
      descriptionMatches: descriptionHighlights || [],
      labelEscapeNewLines: true
    };
    if (mainItem.type !== "separator") {
      options.extraClasses = mainItem.iconClasses;
      options.italic = mainItem.italic;
      options.strikethrough = mainItem.strikethrough;
      data.entry.classList.remove("quick-input-list-separator-as-item");
    } else {
      data.entry.classList.add("quick-input-list-separator-as-item");
    }
    data.label.setLabel(element.saneLabel, element.saneDescription, options);
    data.keybinding.set(mainItem.type === "separator" ? void 0 : mainItem.keybinding);
    if (element.saneDetail) {
      data.detail.element.style.display = "";
      data.detail.setLabel(element.saneDetail, void 0, {
        matches: detailHighlights,
        title: element.saneDetail,
        labelEscapeNewLines: true
      });
    } else {
      data.detail.element.style.display = "none";
    }
    if (element.item && element.separator && element.separator.label) {
      data.separator.textContent = element.separator.label;
      data.separator.style.display = "";
    } else {
      data.separator.style.display = "none";
    }
    data.entry.classList.toggle("quick-input-list-separator-border", !!element.separator);
    const buttons = mainItem.buttons;
    if (buttons && buttons.length) {
      data.actionBar.push(buttons.map((button, index2) => {
        let cssClasses = button.iconClass || (button.iconPath ? getIconClass(button.iconPath) : void 0);
        if (button.alwaysVisible) {
          cssClasses = cssClasses ? `${cssClasses} always-visible` : "always-visible";
        }
        return {
          id: `id-${index2}`,
          class: cssClasses,
          enabled: true,
          label: "",
          tooltip: button.tooltip || "",
          run: () => {
            mainItem.type !== "separator" ? element.fireButtonTriggered({
              button,
              item: mainItem
            }) : element.fireSeparatorButtonTriggered({
              button,
              separator: mainItem
            });
          }
        };
      }), { icon: true, label: false });
      data.entry.classList.add("has-actions");
    } else {
      data.entry.classList.remove("has-actions");
    }
  }
  disposeElement(element, index, data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
    data.actionBar.clear();
  }
  disposeTemplate(data) {
    data.toDisposeElement = dispose(data.toDisposeElement);
    data.toDisposeTemplate = dispose(data.toDisposeTemplate);
  }
};
ListElementRenderer.ID = "listelement";
var ListElementDelegate = class {
  getHeight(element) {
    if (!element.item) {
      return 24;
    }
    return element.saneDetail ? 44 : 22;
  }
  getTemplateId(element) {
    return ListElementRenderer.ID;
  }
};
var QuickInputListFocus;
(function(QuickInputListFocus2) {
  QuickInputListFocus2[QuickInputListFocus2["First"] = 1] = "First";
  QuickInputListFocus2[QuickInputListFocus2["Second"] = 2] = "Second";
  QuickInputListFocus2[QuickInputListFocus2["Last"] = 3] = "Last";
  QuickInputListFocus2[QuickInputListFocus2["Next"] = 4] = "Next";
  QuickInputListFocus2[QuickInputListFocus2["Previous"] = 5] = "Previous";
  QuickInputListFocus2[QuickInputListFocus2["NextPage"] = 6] = "NextPage";
  QuickInputListFocus2[QuickInputListFocus2["PreviousPage"] = 7] = "PreviousPage";
})(QuickInputListFocus || (QuickInputListFocus = {}));
var QuickInputList = class {
  constructor(parent, id, options, themeService) {
    this.parent = parent;
    this.options = options;
    this.inputElements = [];
    this.elements = [];
    this.elementsToIndexes = /* @__PURE__ */ new Map();
    this.matchOnDescription = false;
    this.matchOnDetail = false;
    this.matchOnLabel = true;
    this.matchOnLabelMode = "fuzzy";
    this.sortByLabel = true;
    this._onChangedAllVisibleChecked = new Emitter();
    this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event;
    this._onChangedCheckedCount = new Emitter();
    this.onChangedCheckedCount = this._onChangedCheckedCount.event;
    this._onChangedVisibleCount = new Emitter();
    this.onChangedVisibleCount = this._onChangedVisibleCount.event;
    this._onChangedCheckedElements = new Emitter();
    this.onChangedCheckedElements = this._onChangedCheckedElements.event;
    this._onButtonTriggered = new Emitter();
    this.onButtonTriggered = this._onButtonTriggered.event;
    this._onSeparatorButtonTriggered = new Emitter();
    this.onSeparatorButtonTriggered = this._onSeparatorButtonTriggered.event;
    this._onKeyDown = new Emitter();
    this.onKeyDown = this._onKeyDown.event;
    this._onLeave = new Emitter();
    this.onLeave = this._onLeave.event;
    this._listElementChecked = new Emitter();
    this._fireCheckedEvents = true;
    this.elementDisposables = [];
    this.disposables = [];
    this.id = id;
    this.container = append(this.parent, $3(".quick-input-list"));
    const delegate = new ListElementDelegate();
    const accessibilityProvider = new QuickInputAccessibilityProvider();
    this.list = options.createList("QuickInput", this.container, delegate, [new ListElementRenderer(themeService)], {
      identityProvider: {
        getId: (element) => {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          return (_h = (_f = (_d = (_b = (_a = element.item) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = element.item) === null || _c === void 0 ? void 0 : _c.label) !== null && _d !== void 0 ? _d : (_e = element.separator) === null || _e === void 0 ? void 0 : _e.id) !== null && _f !== void 0 ? _f : (_g = element.separator) === null || _g === void 0 ? void 0 : _g.label) !== null && _h !== void 0 ? _h : "";
        }
      },
      setRowLineHeight: false,
      multipleSelectionSupport: false,
      horizontalScrolling: false,
      accessibilityProvider
    });
    this.list.getHTMLElement().id = id;
    this.disposables.push(this.list);
    this.disposables.push(this.list.onKeyDown((e) => {
      const event = new StandardKeyboardEvent(e);
      switch (event.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
        case 31:
          if (isMacintosh ? e.metaKey : e.ctrlKey) {
            this.list.setFocus(range(this.list.length));
          }
          break;
        case 16: {
          const focus1 = this.list.getFocus();
          if (focus1.length === 1 && focus1[0] === 0) {
            this._onLeave.fire();
          }
          break;
        }
        case 18: {
          const focus2 = this.list.getFocus();
          if (focus2.length === 1 && focus2[0] === this.list.length - 1) {
            this._onLeave.fire();
          }
          break;
        }
      }
      this._onKeyDown.fire(event);
    }));
    this.disposables.push(this.list.onMouseDown((e) => {
      if (e.browserEvent.button !== 2) {
        e.browserEvent.preventDefault();
      }
    }));
    this.disposables.push(addDisposableListener(this.container, EventType.CLICK, (e) => {
      if (e.x || e.y) {
        this._onLeave.fire();
      }
    }));
    this.disposables.push(this.list.onMouseMiddleClick((e) => {
      this._onLeave.fire();
    }));
    this.disposables.push(this.list.onContextMenu((e) => {
      if (typeof e.index === "number") {
        e.browserEvent.preventDefault();
        this.list.setSelection([e.index]);
      }
    }));
    if (options.hoverDelegate) {
      const delayer = new ThrottledDelayer(options.hoverDelegate.delay);
      this.disposables.push(this.list.onMouseOver(async (e) => {
        var _a;
        if (e.browserEvent.target instanceof HTMLAnchorElement) {
          delayer.cancel();
          return;
        }
        if (
          // anchors are an exception as called out above so we skip them here
          !(e.browserEvent.relatedTarget instanceof HTMLAnchorElement) && // check if the mouse is still over the same element
          isAncestor(e.browserEvent.relatedTarget, (_a = e.element) === null || _a === void 0 ? void 0 : _a.element)
        ) {
          return;
        }
        try {
          await delayer.trigger(async () => {
            if (e.element) {
              this.showHover(e.element);
            }
          });
        } catch (e2) {
          if (!isCancellationError(e2)) {
            throw e2;
          }
        }
      }));
      this.disposables.push(this.list.onMouseOut((e) => {
        var _a;
        if (isAncestor(e.browserEvent.relatedTarget, (_a = e.element) === null || _a === void 0 ? void 0 : _a.element)) {
          return;
        }
        delayer.cancel();
      }));
      this.disposables.push(delayer);
    }
    this.disposables.push(this._listElementChecked.event((_) => this.fireCheckedEvents()));
    this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onSeparatorButtonTriggered, this._onLeave, this._onKeyDown);
  }
  get onDidChangeFocus() {
    return Event.map(this.list.onDidChangeFocus, (e) => e.elements.map((e2) => e2.item));
  }
  get onDidChangeSelection() {
    return Event.map(this.list.onDidChangeSelection, (e) => ({ items: e.elements.map((e2) => e2.item), event: e.browserEvent }));
  }
  get scrollTop() {
    return this.list.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.list.scrollTop = scrollTop;
  }
  get ariaLabel() {
    return this.list.getHTMLElement().ariaLabel;
  }
  set ariaLabel(label) {
    this.list.getHTMLElement().ariaLabel = label;
  }
  getAllVisibleChecked() {
    return this.allVisibleChecked(this.elements, false);
  }
  allVisibleChecked(elements, whenNoneVisible = true) {
    for (let i = 0, n = elements.length; i < n; i++) {
      const element = elements[i];
      if (!element.hidden) {
        if (!element.checked) {
          return false;
        } else {
          whenNoneVisible = true;
        }
      }
    }
    return whenNoneVisible;
  }
  getCheckedCount() {
    let count = 0;
    const elements = this.elements;
    for (let i = 0, n = elements.length; i < n; i++) {
      if (elements[i].checked) {
        count++;
      }
    }
    return count;
  }
  getVisibleCount() {
    let count = 0;
    const elements = this.elements;
    for (let i = 0, n = elements.length; i < n; i++) {
      if (!elements[i].hidden) {
        count++;
      }
    }
    return count;
  }
  setAllVisibleChecked(checked) {
    try {
      this._fireCheckedEvents = false;
      this.elements.forEach((element) => {
        if (!element.hidden) {
          element.checked = checked;
        }
      });
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  setElements(inputElements) {
    this.elementDisposables = dispose(this.elementDisposables);
    const fireButtonTriggered = (event) => this.fireButtonTriggered(event);
    const fireSeparatorButtonTriggered = (event) => this.fireSeparatorButtonTriggered(event);
    this.inputElements = inputElements;
    const elementsToIndexes = /* @__PURE__ */ new Map();
    const hasCheckbox = this.parent.classList.contains("show-checkboxes");
    this.elements = inputElements.reduce((result, item, index) => {
      var _a;
      const previous = index > 0 ? inputElements[index - 1] : void 0;
      if (item.type === "separator") {
        if (!item.buttons) {
          return result;
        }
      }
      const element = new ListElement(item, previous, index, hasCheckbox, fireButtonTriggered, fireSeparatorButtonTriggered, this._listElementChecked);
      const resultIndex = result.length;
      result.push(element);
      elementsToIndexes.set((_a = element.item) !== null && _a !== void 0 ? _a : element.separator, resultIndex);
      return result;
    }, []);
    this.elementsToIndexes = elementsToIndexes;
    this.list.splice(0, this.list.length);
    this.list.splice(0, this.list.length, this.elements);
    this._onChangedVisibleCount.fire(this.elements.length);
  }
  getFocusedElements() {
    return this.list.getFocusedElements().map((e) => e.item);
  }
  setFocusedElements(items) {
    this.list.setFocus(items.filter((item) => this.elementsToIndexes.has(item)).map((item) => this.elementsToIndexes.get(item)));
    if (items.length > 0) {
      const focused = this.list.getFocus()[0];
      if (typeof focused === "number") {
        this.list.reveal(focused);
      }
    }
  }
  getActiveDescendant() {
    return this.list.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(items) {
    this.list.setSelection(items.filter((item) => this.elementsToIndexes.has(item)).map((item) => this.elementsToIndexes.get(item)));
  }
  getCheckedElements() {
    return this.elements.filter((e) => e.checked).map((e) => e.item).filter((e) => !!e);
  }
  setCheckedElements(items) {
    try {
      this._fireCheckedEvents = false;
      const checked = /* @__PURE__ */ new Set();
      for (const item of items) {
        checked.add(item);
      }
      for (const element of this.elements) {
        element.checked = checked.has(element.item);
      }
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  set enabled(value) {
    this.list.getHTMLElement().style.pointerEvents = value ? "" : "none";
  }
  focus(what) {
    if (!this.list.length) {
      return;
    }
    if (what === QuickInputListFocus.Second && this.list.length < 2) {
      what = QuickInputListFocus.First;
    }
    switch (what) {
      case QuickInputListFocus.First:
        this.list.scrollTop = 0;
        this.list.focusFirst(void 0, (e) => !!e.item);
        break;
      case QuickInputListFocus.Second:
        this.list.scrollTop = 0;
        this.list.focusNth(1, void 0, (e) => !!e.item);
        break;
      case QuickInputListFocus.Last:
        this.list.scrollTop = this.list.scrollHeight;
        this.list.focusLast(void 0, (e) => !!e.item);
        break;
      case QuickInputListFocus.Next: {
        this.list.focusNext(void 0, true, void 0, (e) => !!e.item);
        const index = this.list.getFocus()[0];
        if (index !== 0 && !this.elements[index - 1].item && this.list.firstVisibleIndex > index - 1) {
          this.list.reveal(index - 1);
        }
        break;
      }
      case QuickInputListFocus.Previous: {
        this.list.focusPrevious(void 0, true, void 0, (e) => !!e.item);
        const index = this.list.getFocus()[0];
        if (index !== 0 && !this.elements[index - 1].item && this.list.firstVisibleIndex > index - 1) {
          this.list.reveal(index - 1);
        }
        break;
      }
      case QuickInputListFocus.NextPage:
        this.list.focusNextPage(void 0, (e) => !!e.item);
        break;
      case QuickInputListFocus.PreviousPage:
        this.list.focusPreviousPage(void 0, (e) => !!e.item);
        break;
    }
    const focused = this.list.getFocus()[0];
    if (typeof focused === "number") {
      this.list.reveal(focused);
    }
  }
  clearFocus() {
    this.list.setFocus([]);
  }
  domFocus() {
    this.list.domFocus();
  }
  /**
   * Disposes of the hover and shows a new one for the given index if it has a tooltip.
   * @param element The element to show the hover for
   */
  showHover(element) {
    var _a, _b, _c;
    if (this.options.hoverDelegate === void 0) {
      return;
    }
    if (this._lastHover && !this._lastHover.isDisposed) {
      (_b = (_a = this.options.hoverDelegate).onDidHideHover) === null || _b === void 0 ? void 0 : _b.call(_a);
      (_c = this._lastHover) === null || _c === void 0 ? void 0 : _c.dispose();
    }
    if (!element.element || !element.saneTooltip) {
      return;
    }
    this._lastHover = this.options.hoverDelegate.showHover({
      content: element.saneTooltip,
      target: element.element,
      linkHandler: (url) => {
        this.options.linkOpenerDelegate(url);
      },
      appearance: {
        showPointer: true
      },
      container: this.container,
      position: {
        hoverPosition: 1
        /* HoverPosition.RIGHT */
      }
    }, false);
  }
  layout(maxHeight) {
    this.list.getHTMLElement().style.maxHeight = maxHeight ? `${// Make sure height aligns with list item heights
    Math.floor(maxHeight / 44) * 44 + 6}px` : "";
    this.list.layout();
  }
  filter(query) {
    if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
      this.list.layout();
      return false;
    }
    const queryWithWhitespace = query;
    query = query.trim();
    if (!query || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail)) {
      this.elements.forEach((element) => {
        element.labelHighlights = void 0;
        element.descriptionHighlights = void 0;
        element.detailHighlights = void 0;
        element.hidden = false;
        const previous = element.index && this.inputElements[element.index - 1];
        if (element.item) {
          element.separator = previous && previous.type === "separator" && !previous.buttons ? previous : void 0;
        }
      });
    } else {
      let currentSeparator;
      this.elements.forEach((element) => {
        var _a, _b, _c, _d;
        let labelHighlights;
        if (this.matchOnLabelMode === "fuzzy") {
          labelHighlights = this.matchOnLabel ? (_a = matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneLabel))) !== null && _a !== void 0 ? _a : void 0 : void 0;
        } else {
          labelHighlights = this.matchOnLabel ? (_b = matchesContiguousIconAware(queryWithWhitespace, parseLabelWithIcons(element.saneLabel))) !== null && _b !== void 0 ? _b : void 0 : void 0;
        }
        const descriptionHighlights = this.matchOnDescription ? (_c = matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDescription || ""))) !== null && _c !== void 0 ? _c : void 0 : void 0;
        const detailHighlights = this.matchOnDetail ? (_d = matchesFuzzyIconAware(query, parseLabelWithIcons(element.saneDetail || ""))) !== null && _d !== void 0 ? _d : void 0 : void 0;
        if (labelHighlights || descriptionHighlights || detailHighlights) {
          element.labelHighlights = labelHighlights;
          element.descriptionHighlights = descriptionHighlights;
          element.detailHighlights = detailHighlights;
          element.hidden = false;
        } else {
          element.labelHighlights = void 0;
          element.descriptionHighlights = void 0;
          element.detailHighlights = void 0;
          element.hidden = element.item ? !element.item.alwaysShow : true;
        }
        if (element.item) {
          element.separator = void 0;
        } else if (element.separator) {
          element.hidden = true;
        }
        if (!this.sortByLabel) {
          const previous = element.index && this.inputElements[element.index - 1];
          currentSeparator = previous && previous.type === "separator" ? previous : currentSeparator;
          if (currentSeparator && !element.hidden) {
            element.separator = currentSeparator;
            currentSeparator = void 0;
          }
        }
      });
    }
    const shownElements = this.elements.filter((element) => !element.hidden);
    if (this.sortByLabel && query) {
      const normalizedSearchValue = query.toLowerCase();
      shownElements.sort((a, b) => {
        return compareEntries(a, b, normalizedSearchValue);
      });
    }
    this.elementsToIndexes = shownElements.reduce((map, element, index) => {
      var _a;
      map.set((_a = element.item) !== null && _a !== void 0 ? _a : element.separator, index);
      return map;
    }, /* @__PURE__ */ new Map());
    this.list.splice(0, this.list.length, shownElements);
    this.list.setFocus([]);
    this.list.layout();
    this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
    this._onChangedVisibleCount.fire(shownElements.length);
    return true;
  }
  toggleCheckbox() {
    try {
      this._fireCheckedEvents = false;
      const elements = this.list.getFocusedElements();
      const allChecked = this.allVisibleChecked(elements);
      for (const element of elements) {
        element.checked = !allChecked;
      }
    } finally {
      this._fireCheckedEvents = true;
      this.fireCheckedEvents();
    }
  }
  display(display) {
    this.container.style.display = display ? "" : "none";
  }
  isDisplayed() {
    return this.container.style.display !== "none";
  }
  dispose() {
    this.elementDisposables = dispose(this.elementDisposables);
    this.disposables = dispose(this.disposables);
  }
  fireCheckedEvents() {
    if (this._fireCheckedEvents) {
      this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
      this._onChangedCheckedCount.fire(this.getCheckedCount());
      this._onChangedCheckedElements.fire(this.getCheckedElements());
    }
  }
  fireButtonTriggered(event) {
    this._onButtonTriggered.fire(event);
  }
  fireSeparatorButtonTriggered(event) {
    this._onSeparatorButtonTriggered.fire(event);
  }
  style(styles) {
    this.list.style(styles);
  }
  toggleHover() {
    const element = this.list.getFocusedElements()[0];
    if (!(element === null || element === void 0 ? void 0 : element.saneTooltip)) {
      return;
    }
    if (this._lastHover && !this._lastHover.isDisposed) {
      this._lastHover.dispose();
      return;
    }
    const focused = this.list.getFocusedElements()[0];
    if (!focused) {
      return;
    }
    this.showHover(focused);
    const store = new DisposableStore();
    store.add(this.list.onDidChangeFocus((e) => {
      if (e.indexes.length) {
        this.showHover(e.elements[0]);
      }
    }));
    if (this._lastHover) {
      store.add(this._lastHover);
    }
    this._toggleHover = store;
    this.elementDisposables.push(this._toggleHover);
  }
};
__decorate16([
  memoize
], QuickInputList.prototype, "onDidChangeFocus", null);
__decorate16([
  memoize
], QuickInputList.prototype, "onDidChangeSelection", null);
function matchesContiguousIconAware(query, target) {
  const { text, iconOffsets } = target;
  if (!iconOffsets || iconOffsets.length === 0) {
    return matchesContiguous(query, text);
  }
  const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, " ");
  const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;
  const matches = matchesContiguous(query, wordToMatchAgainstWithoutIconsTrimmed);
  if (matches) {
    for (const match2 of matches) {
      const iconOffset = iconOffsets[match2.start + leadingWhitespaceOffset] + leadingWhitespaceOffset;
      match2.start += iconOffset;
      match2.end += iconOffset;
    }
  }
  return matches;
}
function matchesContiguous(word, wordToMatchAgainst) {
  const matchIndex = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
  if (matchIndex !== -1) {
    return [{ start: matchIndex, end: matchIndex + word.length }];
  }
  return null;
}
function compareEntries(elementA, elementB, lookFor) {
  const labelHighlightsA = elementA.labelHighlights || [];
  const labelHighlightsB = elementB.labelHighlights || [];
  if (labelHighlightsA.length && !labelHighlightsB.length) {
    return -1;
  }
  if (!labelHighlightsA.length && labelHighlightsB.length) {
    return 1;
  }
  if (labelHighlightsA.length === 0 && labelHighlightsB.length === 0) {
    return 0;
  }
  return compareAnything(elementA.saneSortLabel, elementB.saneSortLabel, lookFor);
}
var QuickInputAccessibilityProvider = class {
  getWidgetAriaLabel() {
    return localize("quickInput", "Quick Input");
  }
  getAriaLabel(element) {
    var _a;
    return ((_a = element.separator) === null || _a === void 0 ? void 0 : _a.label) ? `${element.saneAriaLabel}, ${element.separator.label}` : element.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole(element) {
    return element.hasCheckbox ? "checkbox" : "option";
  }
  isChecked(element) {
    if (!element.hasCheckbox) {
      return void 0;
    }
    return {
      value: element.checked,
      onDidChange: element.onChecked
    };
  }
};

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInput.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/media/quickInput.css";
var backButton = {
  iconClass: ThemeIcon.asClassName(Codicon.quickInputBack),
  tooltip: localize("quickInput.back", "Back"),
  handle: -1
  // TODO
};
var QuickInput = class _QuickInput extends Disposable {
  constructor(ui) {
    super();
    this.ui = ui;
    this._widgetUpdated = false;
    this.visible = false;
    this._enabled = true;
    this._busy = false;
    this._ignoreFocusOut = false;
    this._buttons = [];
    this.buttonsUpdated = false;
    this._toggles = [];
    this.togglesUpdated = false;
    this.noValidationMessage = _QuickInput.noPromptMessage;
    this._severity = severity_default.Ignore;
    this.onDidTriggerButtonEmitter = this._register(new Emitter());
    this.onDidHideEmitter = this._register(new Emitter());
    this.onDisposeEmitter = this._register(new Emitter());
    this.visibleDisposables = this._register(new DisposableStore());
    this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(title) {
    this._title = title;
    this.update();
  }
  get description() {
    return this._description;
  }
  set description(description) {
    this._description = description;
    this.update();
  }
  get step() {
    return this._steps;
  }
  set step(step) {
    this._steps = step;
    this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(totalSteps) {
    this._totalSteps = totalSteps;
    this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(contextKey) {
    this._contextKey = contextKey;
    this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(busy) {
    this._busy = busy;
    this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(ignoreFocusOut) {
    const shouldUpdate = this._ignoreFocusOut !== ignoreFocusOut && !isIOS;
    this._ignoreFocusOut = ignoreFocusOut && !isIOS;
    if (shouldUpdate) {
      this.update();
    }
  }
  get buttons() {
    return this._buttons;
  }
  set buttons(buttons) {
    this._buttons = buttons;
    this.buttonsUpdated = true;
    this.update();
  }
  get toggles() {
    return this._toggles;
  }
  set toggles(toggles) {
    this._toggles = toggles !== null && toggles !== void 0 ? toggles : [];
    this.togglesUpdated = true;
    this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(validationMessage) {
    this._validationMessage = validationMessage;
    this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(severity) {
    this._severity = severity;
    this.update();
  }
  show() {
    if (this.visible) {
      return;
    }
    this.visibleDisposables.add(this.ui.onDidTriggerButton((button) => {
      if (this.buttons.indexOf(button) !== -1) {
        this.onDidTriggerButtonEmitter.fire(button);
      }
    }));
    this.ui.show(this);
    this.visible = true;
    this._lastValidationMessage = void 0;
    this._lastSeverity = void 0;
    if (this.buttons.length) {
      this.buttonsUpdated = true;
    }
    if (this.toggles.length) {
      this.togglesUpdated = true;
    }
    this.update();
  }
  hide() {
    if (!this.visible) {
      return;
    }
    this.ui.hide();
  }
  didHide(reason = QuickInputHideReason.Other) {
    this.visible = false;
    this.visibleDisposables.clear();
    this.onDidHideEmitter.fire({ reason });
  }
  update() {
    var _a, _b;
    if (!this.visible) {
      return;
    }
    const title = this.getTitle();
    if (title && this.ui.title.textContent !== title) {
      this.ui.title.textContent = title;
    } else if (!title && this.ui.title.innerHTML !== "&nbsp;") {
      this.ui.title.innerText = " ";
    }
    const description = this.getDescription();
    if (this.ui.description1.textContent !== description) {
      this.ui.description1.textContent = description;
    }
    if (this.ui.description2.textContent !== description) {
      this.ui.description2.textContent = description;
    }
    if (this._widgetUpdated) {
      this._widgetUpdated = false;
      if (this._widget) {
        reset(this.ui.widget, this._widget);
      } else {
        reset(this.ui.widget);
      }
    }
    if (this.busy && !this.busyDelay) {
      this.busyDelay = new TimeoutTimer();
      this.busyDelay.setIfNotSet(() => {
        if (this.visible) {
          this.ui.progressBar.infinite();
        }
      }, 800);
    }
    if (!this.busy && this.busyDelay) {
      this.ui.progressBar.stop();
      this.busyDelay.cancel();
      this.busyDelay = void 0;
    }
    if (this.buttonsUpdated) {
      this.buttonsUpdated = false;
      this.ui.leftActionBar.clear();
      const leftButtons = this.buttons.filter((button) => button === backButton);
      this.ui.leftActionBar.push(leftButtons.map((button, index) => {
        const action = new Action(`id-${index}`, "", button.iconClass || getIconClass(button.iconPath), true, async () => {
          this.onDidTriggerButtonEmitter.fire(button);
        });
        action.tooltip = button.tooltip || "";
        return action;
      }), { icon: true, label: false });
      this.ui.rightActionBar.clear();
      const rightButtons = this.buttons.filter((button) => button !== backButton);
      this.ui.rightActionBar.push(rightButtons.map((button, index) => {
        const action = new Action(`id-${index}`, "", button.iconClass || getIconClass(button.iconPath), true, async () => {
          this.onDidTriggerButtonEmitter.fire(button);
        });
        action.tooltip = button.tooltip || "";
        return action;
      }), { icon: true, label: false });
    }
    if (this.togglesUpdated) {
      this.togglesUpdated = false;
      const concreteToggles = (_b = (_a = this.toggles) === null || _a === void 0 ? void 0 : _a.filter((opts) => opts instanceof Toggle)) !== null && _b !== void 0 ? _b : [];
      this.ui.inputBox.toggles = concreteToggles;
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut;
    this.ui.setEnabled(this.enabled);
    this.ui.setContextKey(this.contextKey);
    const validationMessage = this.validationMessage || this.noValidationMessage;
    if (this._lastValidationMessage !== validationMessage) {
      this._lastValidationMessage = validationMessage;
      reset(this.ui.message);
      renderQuickInputDescription(validationMessage, this.ui.message, {
        callback: (content) => {
          this.ui.linkOpenerDelegate(content);
        },
        disposables: this.visibleDisposables
      });
    }
    if (this._lastSeverity !== this.severity) {
      this._lastSeverity = this.severity;
      this.showMessageDecoration(this.severity);
    }
  }
  getTitle() {
    if (this.title && this.step) {
      return `${this.title} (${this.getSteps()})`;
    }
    if (this.title) {
      return this.title;
    }
    if (this.step) {
      return this.getSteps();
    }
    return "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    if (this.step && this.totalSteps) {
      return localize("quickInput.steps", "{0}/{1}", this.step, this.totalSteps);
    }
    if (this.step) {
      return String(this.step);
    }
    return "";
  }
  showMessageDecoration(severity) {
    this.ui.inputBox.showDecoration(severity);
    if (severity !== severity_default.Ignore) {
      const styles = this.ui.inputBox.stylesForType(severity);
      this.ui.message.style.color = styles.foreground ? `${styles.foreground}` : "";
      this.ui.message.style.backgroundColor = styles.background ? `${styles.background}` : "";
      this.ui.message.style.border = styles.border ? `1px solid ${styles.border}` : "";
      this.ui.message.style.marginBottom = "-2px";
    } else {
      this.ui.message.style.color = "";
      this.ui.message.style.backgroundColor = "";
      this.ui.message.style.border = "";
      this.ui.message.style.marginBottom = "";
    }
  }
  dispose() {
    this.hide();
    this.onDisposeEmitter.fire();
    super.dispose();
  }
};
QuickInput.noPromptMessage = localize("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
var QuickPick = class _QuickPick extends QuickInput {
  constructor() {
    super(...arguments);
    this._value = "";
    this.onDidChangeValueEmitter = this._register(new Emitter());
    this.onWillAcceptEmitter = this._register(new Emitter());
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidCustomEmitter = this._register(new Emitter());
    this._items = [];
    this.itemsUpdated = false;
    this._canSelectMany = false;
    this._canAcceptInBackground = false;
    this._matchOnDescription = false;
    this._matchOnDetail = false;
    this._matchOnLabel = true;
    this._matchOnLabelMode = "fuzzy";
    this._sortByLabel = true;
    this._autoFocusOnList = true;
    this._keepScrollPosition = false;
    this._itemActivation = ItemActivation.FIRST;
    this._activeItems = [];
    this.activeItemsUpdated = false;
    this.activeItemsToConfirm = [];
    this.onDidChangeActiveEmitter = this._register(new Emitter());
    this._selectedItems = [];
    this.selectedItemsUpdated = false;
    this.selectedItemsToConfirm = [];
    this.onDidChangeSelectionEmitter = this._register(new Emitter());
    this.onDidTriggerItemButtonEmitter = this._register(new Emitter());
    this.onDidTriggerSeparatorButtonEmitter = this._register(new Emitter());
    this.valueSelectionUpdated = true;
    this._ok = "default";
    this._customButton = false;
    this.filterValue = (value) => value;
    this.onDidChangeValue = this.onDidChangeValueEmitter.event;
    this.onWillAccept = this.onWillAcceptEmitter.event;
    this.onDidAccept = this.onDidAcceptEmitter.event;
    this.onDidChangeActive = this.onDidChangeActiveEmitter.event;
    this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event;
    this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
    this.onDidTriggerSeparatorButton = this.onDidTriggerSeparatorButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(quickNavigate) {
    this._quickNavigate = quickNavigate;
    this.update();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this.doSetValue(value);
  }
  doSetValue(value, skipUpdate) {
    if (this._value !== value) {
      this._value = value;
      if (!skipUpdate) {
        this.update();
      }
      if (this.visible) {
        const didFilter = this.ui.list.filter(this.filterValue(this._value));
        if (didFilter) {
          this.trySelectFirst();
        }
      }
      this.onDidChangeValueEmitter.fire(this._value);
    }
  }
  set ariaLabel(ariaLabel) {
    this._ariaLabel = ariaLabel;
    this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(placeholder) {
    this._placeholder = placeholder;
    this.update();
  }
  get items() {
    return this._items;
  }
  get scrollTop() {
    return this.ui.list.scrollTop;
  }
  set scrollTop(scrollTop) {
    this.ui.list.scrollTop = scrollTop;
  }
  set items(items) {
    this._items = items;
    this.itemsUpdated = true;
    this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(canSelectMany) {
    this._canSelectMany = canSelectMany;
    this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(canAcceptInBackground) {
    this._canAcceptInBackground = canAcceptInBackground;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(matchOnDescription) {
    this._matchOnDescription = matchOnDescription;
    this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(matchOnDetail) {
    this._matchOnDetail = matchOnDetail;
    this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(matchOnLabel) {
    this._matchOnLabel = matchOnLabel;
    this.update();
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(matchOnLabelMode) {
    this._matchOnLabelMode = matchOnLabelMode;
    this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(sortByLabel) {
    this._sortByLabel = sortByLabel;
    this.update();
  }
  get autoFocusOnList() {
    return this._autoFocusOnList;
  }
  set autoFocusOnList(autoFocusOnList) {
    this._autoFocusOnList = autoFocusOnList;
    this.update();
  }
  get keepScrollPosition() {
    return this._keepScrollPosition;
  }
  set keepScrollPosition(keepScrollPosition) {
    this._keepScrollPosition = keepScrollPosition;
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(itemActivation) {
    this._itemActivation = itemActivation;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(activeItems) {
    this._activeItems = activeItems;
    this.activeItemsUpdated = true;
    this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(selectedItems) {
    this._selectedItems = selectedItems;
    this.selectedItemsUpdated = true;
    this.update();
  }
  get keyMods() {
    if (this._quickNavigate) {
      return NO_KEY_MODS;
    }
    return this.ui.keyMods;
  }
  set valueSelection(valueSelection) {
    this._valueSelection = valueSelection;
    this.valueSelectionUpdated = true;
    this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(showCustomButton) {
    this._customButton = showCustomButton;
    this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(label) {
    this._customButtonLabel = label;
    this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(hover) {
    this._customButtonHover = hover;
    this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(showOkButton) {
    this._ok = showOkButton;
    this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(hideInput) {
    this._hideInput = hideInput;
    this.update();
  }
  trySelectFirst() {
    if (this.autoFocusOnList) {
      if (!this.canSelectMany) {
        this.ui.list.focus(QuickInputListFocus.First);
      }
    }
  }
  show() {
    if (!this.visible) {
      this.visibleDisposables.add(this.ui.inputBox.onDidChange((value) => {
        this.doSetValue(
          value,
          true
          /* skip update since this originates from the UI */
        );
      }));
      this.visibleDisposables.add(this.ui.inputBox.onMouseDown((event) => {
        if (!this.autoFocusOnList) {
          this.ui.list.clearFocus();
        }
      }));
      this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((event) => {
        switch (event.keyCode) {
          case 18:
            this.ui.list.focus(QuickInputListFocus.Next);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 16:
            if (this.ui.list.getFocusedElements().length) {
              this.ui.list.focus(QuickInputListFocus.Previous);
            } else {
              this.ui.list.focus(QuickInputListFocus.Last);
            }
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 12:
            this.ui.list.focus(QuickInputListFocus.NextPage);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 11:
            this.ui.list.focus(QuickInputListFocus.PreviousPage);
            if (this.canSelectMany) {
              this.ui.list.domFocus();
            }
            EventHelper.stop(event, true);
            break;
          case 17:
            if (!this._canAcceptInBackground) {
              return;
            }
            if (!this.ui.inputBox.isSelectionAtEnd()) {
              return;
            }
            if (this.activeItems[0]) {
              this._selectedItems = [this.activeItems[0]];
              this.onDidChangeSelectionEmitter.fire(this.selectedItems);
              this.handleAccept(true);
            }
            break;
          case 14:
            if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
              this.ui.list.focus(QuickInputListFocus.First);
              EventHelper.stop(event, true);
            }
            break;
          case 13:
            if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
              this.ui.list.focus(QuickInputListFocus.Last);
              EventHelper.stop(event, true);
            }
            break;
        }
      }));
      this.visibleDisposables.add(this.ui.onDidAccept(() => {
        if (this.canSelectMany) {
          if (!this.ui.list.getCheckedElements().length) {
            this._selectedItems = [];
            this.onDidChangeSelectionEmitter.fire(this.selectedItems);
          }
        } else if (this.activeItems[0]) {
          this._selectedItems = [this.activeItems[0]];
          this.onDidChangeSelectionEmitter.fire(this.selectedItems);
        }
        this.handleAccept(false);
      }));
      this.visibleDisposables.add(this.ui.onDidCustom(() => {
        this.onDidCustomEmitter.fire();
      }));
      this.visibleDisposables.add(this.ui.list.onDidChangeFocus((focusedItems) => {
        if (this.activeItemsUpdated) {
          return;
        }
        if (this.activeItemsToConfirm !== this._activeItems && equals(focusedItems, this._activeItems, (a, b) => a === b)) {
          return;
        }
        this._activeItems = focusedItems;
        this.onDidChangeActiveEmitter.fire(focusedItems);
      }));
      this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: selectedItems, event }) => {
        if (this.canSelectMany) {
          if (selectedItems.length) {
            this.ui.list.setSelectedElements([]);
          }
          return;
        }
        if (this.selectedItemsToConfirm !== this._selectedItems && equals(selectedItems, this._selectedItems, (a, b) => a === b)) {
          return;
        }
        this._selectedItems = selectedItems;
        this.onDidChangeSelectionEmitter.fire(selectedItems);
        if (selectedItems.length) {
          this.handleAccept(
            isMouseEvent(event) && event.button === 1
            /* mouse middle click */
          );
        }
      }));
      this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((checkedItems) => {
        if (!this.canSelectMany) {
          return;
        }
        if (this.selectedItemsToConfirm !== this._selectedItems && equals(checkedItems, this._selectedItems, (a, b) => a === b)) {
          return;
        }
        this._selectedItems = checkedItems;
        this.onDidChangeSelectionEmitter.fire(checkedItems);
      }));
      this.visibleDisposables.add(this.ui.list.onButtonTriggered((event) => this.onDidTriggerItemButtonEmitter.fire(event)));
      this.visibleDisposables.add(this.ui.list.onSeparatorButtonTriggered((event) => this.onDidTriggerSeparatorButtonEmitter.fire(event)));
      this.visibleDisposables.add(this.registerQuickNavigation());
      this.valueSelectionUpdated = true;
    }
    super.show();
  }
  handleAccept(inBackground) {
    let veto = false;
    this.onWillAcceptEmitter.fire({ veto: () => veto = true });
    if (!veto) {
      this.onDidAcceptEmitter.fire({ inBackground });
    }
  }
  registerQuickNavigation() {
    return addDisposableListener(this.ui.container, EventType.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate) {
        return;
      }
      const keyboardEvent = new StandardKeyboardEvent(e);
      const keyCode = keyboardEvent.keyCode;
      const quickNavKeys = this._quickNavigate.keybindings;
      const wasTriggerKeyPressed = quickNavKeys.some((k) => {
        const chords = k.getChords();
        if (chords.length > 1) {
          return false;
        }
        if (chords[0].shiftKey && keyCode === 4) {
          if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {
            return false;
          }
          return true;
        }
        if (chords[0].altKey && keyCode === 6) {
          return true;
        }
        if (chords[0].ctrlKey && keyCode === 5) {
          return true;
        }
        if (chords[0].metaKey && keyCode === 57) {
          return true;
        }
        return false;
      });
      if (wasTriggerKeyPressed) {
        if (this.activeItems[0]) {
          this._selectedItems = [this.activeItems[0]];
          this.onDidChangeSelectionEmitter.fire(this.selectedItems);
          this.handleAccept(false);
        }
        this._quickNavigate = void 0;
      }
    });
  }
  update() {
    if (!this.visible) {
      return;
    }
    const scrollTopBefore = this.keepScrollPosition ? this.scrollTop : 0;
    const hasDescription = !!this.description;
    const visibilities = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: hasDescription,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !this._hideInput,
      progressBar: !this._hideInput || hasDescription,
      visibleCount: true,
      count: this.canSelectMany && !this._hideCountBadge,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: true,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(visibilities);
    super.update();
    if (this.ui.inputBox.value !== this.value) {
      this.ui.inputBox.value = this.value;
    }
    if (this.valueSelectionUpdated) {
      this.valueSelectionUpdated = false;
      this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });
    }
    if (this.ui.inputBox.placeholder !== (this.placeholder || "")) {
      this.ui.inputBox.placeholder = this.placeholder || "";
    }
    let ariaLabel = this.ariaLabel;
    if (!ariaLabel && visibilities.inputBox) {
      ariaLabel = this.placeholder || _QuickPick.DEFAULT_ARIA_LABEL;
      if (this.title) {
        ariaLabel += ` - ${this.title}`;
      }
    }
    if (this.ui.list.ariaLabel !== ariaLabel) {
      this.ui.list.ariaLabel = ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : null;
    }
    this.ui.list.matchOnDescription = this.matchOnDescription;
    this.ui.list.matchOnDetail = this.matchOnDetail;
    this.ui.list.matchOnLabel = this.matchOnLabel;
    this.ui.list.matchOnLabelMode = this.matchOnLabelMode;
    this.ui.list.sortByLabel = this.sortByLabel;
    if (this.itemsUpdated) {
      this.itemsUpdated = false;
      this.ui.list.setElements(this.items);
      this.ui.list.filter(this.filterValue(this.ui.inputBox.value));
      this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked();
      this.ui.visibleCount.setCount(this.ui.list.getVisibleCount());
      this.ui.count.setCount(this.ui.list.getCheckedCount());
      switch (this._itemActivation) {
        case ItemActivation.NONE:
          this._itemActivation = ItemActivation.FIRST;
          break;
        case ItemActivation.SECOND:
          this.ui.list.focus(QuickInputListFocus.Second);
          this._itemActivation = ItemActivation.FIRST;
          break;
        case ItemActivation.LAST:
          this.ui.list.focus(QuickInputListFocus.Last);
          this._itemActivation = ItemActivation.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    }
    if (this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany) {
      if (this.canSelectMany) {
        this.ui.list.clearFocus();
      } else {
        this.trySelectFirst();
      }
    }
    if (this.activeItemsUpdated) {
      this.activeItemsUpdated = false;
      this.activeItemsToConfirm = this._activeItems;
      this.ui.list.setFocusedElements(this.activeItems);
      if (this.activeItemsToConfirm === this._activeItems) {
        this.activeItemsToConfirm = null;
      }
    }
    if (this.selectedItemsUpdated) {
      this.selectedItemsUpdated = false;
      this.selectedItemsToConfirm = this._selectedItems;
      if (this.canSelectMany) {
        this.ui.list.setCheckedElements(this.selectedItems);
      } else {
        this.ui.list.setSelectedElements(this.selectedItems);
      }
      if (this.selectedItemsToConfirm === this._selectedItems) {
        this.selectedItemsToConfirm = null;
      }
    }
    this.ui.customButton.label = this.customLabel || "";
    this.ui.customButton.element.title = this.customHover || "";
    if (!visibilities.inputBox) {
      this.ui.list.domFocus();
      if (this.canSelectMany) {
        this.ui.list.focus(QuickInputListFocus.First);
      }
    }
    if (this.keepScrollPosition) {
      this.scrollTop = scrollTopBefore;
    }
  }
};
QuickPick.DEFAULT_ARIA_LABEL = localize("quickInputBox.ariaLabel", "Type to narrow down results.");
var InputBox = class extends QuickInput {
  constructor() {
    super(...arguments);
    this._value = "";
    this.valueSelectionUpdated = true;
    this._password = false;
    this.onDidValueChangeEmitter = this._register(new Emitter());
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidChangeValue = this.onDidValueChangeEmitter.event;
    this.onDidAccept = this.onDidAcceptEmitter.event;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value || "";
    this.update();
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(placeholder) {
    this._placeholder = placeholder;
    this.update();
  }
  get password() {
    return this._password;
  }
  set password(password) {
    this._password = password;
    this.update();
  }
  show() {
    if (!this.visible) {
      this.visibleDisposables.add(this.ui.inputBox.onDidChange((value) => {
        if (value === this.value) {
          return;
        }
        this._value = value;
        this.onDidValueChangeEmitter.fire(value);
      }));
      this.visibleDisposables.add(this.ui.onDidAccept(() => this.onDidAcceptEmitter.fire()));
      this.valueSelectionUpdated = true;
    }
    super.show();
  }
  update() {
    if (!this.visible) {
      return;
    }
    this.ui.container.classList.remove("hidden-input");
    const visibilities = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: !!this.description || !!this.step,
      inputBox: true,
      message: true,
      progressBar: true
    };
    this.ui.setVisibilities(visibilities);
    super.update();
    if (this.ui.inputBox.value !== this.value) {
      this.ui.inputBox.value = this.value;
    }
    if (this.valueSelectionUpdated) {
      this.valueSelectionUpdated = false;
      this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });
    }
    if (this.ui.inputBox.placeholder !== (this.placeholder || "")) {
      this.ui.inputBox.placeholder = this.placeholder || "";
    }
    if (this.ui.inputBox.password !== this.password) {
      this.ui.inputBox.password = this.password;
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputController.js
var $4 = $;
var QuickInputController = class _QuickInputController extends Disposable {
  constructor(options, themeService, layoutService) {
    super();
    this.options = options;
    this.themeService = themeService;
    this.layoutService = layoutService;
    this.enabled = true;
    this.onDidAcceptEmitter = this._register(new Emitter());
    this.onDidCustomEmitter = this._register(new Emitter());
    this.onDidTriggerButtonEmitter = this._register(new Emitter());
    this.keyMods = { ctrlCmd: false, alt: false };
    this.controller = null;
    this.onShowEmitter = this._register(new Emitter());
    this.onShow = this.onShowEmitter.event;
    this.onHideEmitter = this._register(new Emitter());
    this.onHide = this.onHideEmitter.event;
    this.idPrefix = options.idPrefix;
    this.parentElement = options.container;
    this.styles = options.styles;
    this._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => this.registerKeyModsListeners(window, disposables), { window: mainWindow, disposables: this._store }));
    this._register(onWillUnregisterWindow((window) => {
      if (this.ui && getWindow(this.ui.container) === window) {
        this.reparentUI(this.layoutService.mainContainer);
      }
    }));
  }
  registerKeyModsListeners(window, disposables) {
    const listener = (e) => {
      this.keyMods.ctrlCmd = e.ctrlKey || e.metaKey;
      this.keyMods.alt = e.altKey;
    };
    for (const event of [EventType.KEY_DOWN, EventType.KEY_UP, EventType.MOUSE_DOWN]) {
      disposables.add(addDisposableListener(window, event, listener, true));
    }
  }
  getUI(showInActiveContainer) {
    if (this.ui) {
      if (showInActiveContainer) {
        if (this.parentElement.ownerDocument !== this.layoutService.activeContainer.ownerDocument) {
          this.reparentUI(this.layoutService.activeContainer);
        }
      }
      return this.ui;
    }
    const container = append(this.parentElement, $4(".quick-input-widget.show-file-icons"));
    container.tabIndex = -1;
    container.style.display = "none";
    const styleSheet = createStyleSheet(container);
    const titleBar = append(container, $4(".quick-input-titlebar"));
    const actionBarOption = this.options.hoverDelegate ? { hoverDelegate: this.options.hoverDelegate } : void 0;
    const leftActionBar = this._register(new ActionBar(titleBar, actionBarOption));
    leftActionBar.domNode.classList.add("quick-input-left-action-bar");
    const title = append(titleBar, $4(".quick-input-title"));
    const rightActionBar = this._register(new ActionBar(titleBar, actionBarOption));
    rightActionBar.domNode.classList.add("quick-input-right-action-bar");
    const headerContainer = append(container, $4(".quick-input-header"));
    const checkAll = append(headerContainer, $4("input.quick-input-check-all"));
    checkAll.type = "checkbox";
    checkAll.setAttribute("aria-label", localize("quickInput.checkAll", "Toggle all checkboxes"));
    this._register(addStandardDisposableListener(checkAll, EventType.CHANGE, (e) => {
      const checked = checkAll.checked;
      list.setAllVisibleChecked(checked);
    }));
    this._register(addDisposableListener(checkAll, EventType.CLICK, (e) => {
      if (e.x || e.y) {
        inputBox.setFocus();
      }
    }));
    const description2 = append(headerContainer, $4(".quick-input-description"));
    const inputContainer = append(headerContainer, $4(".quick-input-and-message"));
    const filterContainer = append(inputContainer, $4(".quick-input-filter"));
    const inputBox = this._register(new QuickInputBox(filterContainer, this.styles.inputBox, this.styles.toggle));
    inputBox.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const visibleCountContainer = append(filterContainer, $4(".quick-input-visible-count"));
    visibleCountContainer.setAttribute("aria-live", "polite");
    visibleCountContainer.setAttribute("aria-atomic", "true");
    const visibleCount = new CountBadge(visibleCountContainer, { countFormat: localize({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }, this.styles.countBadge);
    const countContainer = append(filterContainer, $4(".quick-input-count"));
    countContainer.setAttribute("aria-live", "polite");
    const count = new CountBadge(countContainer, { countFormat: localize({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }, this.styles.countBadge);
    const okContainer = append(headerContainer, $4(".quick-input-action"));
    const ok = this._register(new Button(okContainer, this.styles.button));
    ok.label = localize("ok", "OK");
    this._register(ok.onDidClick((e) => {
      this.onDidAcceptEmitter.fire();
    }));
    const customButtonContainer = append(headerContainer, $4(".quick-input-action"));
    const customButton = this._register(new Button(customButtonContainer, this.styles.button));
    customButton.label = localize("custom", "Custom");
    this._register(customButton.onDidClick((e) => {
      this.onDidCustomEmitter.fire();
    }));
    const message = append(inputContainer, $4(`#${this.idPrefix}message.quick-input-message`));
    const progressBar = this._register(new ProgressBar(container, this.styles.progressBar));
    progressBar.getContainer().classList.add("quick-input-progress");
    const widget = append(container, $4(".quick-input-html-widget"));
    widget.tabIndex = -1;
    const description1 = append(container, $4(".quick-input-description"));
    const listId = this.idPrefix + "list";
    const list = this._register(new QuickInputList(container, listId, this.options, this.themeService));
    inputBox.setAttribute("aria-controls", listId);
    this._register(list.onDidChangeFocus(() => {
      var _a;
      inputBox.setAttribute("aria-activedescendant", (_a = list.getActiveDescendant()) !== null && _a !== void 0 ? _a : "");
    }));
    this._register(list.onChangedAllVisibleChecked((checked) => {
      checkAll.checked = checked;
    }));
    this._register(list.onChangedVisibleCount((c) => {
      visibleCount.setCount(c);
    }));
    this._register(list.onChangedCheckedCount((c) => {
      count.setCount(c);
    }));
    this._register(list.onLeave(() => {
      setTimeout(() => {
        inputBox.setFocus();
        if (this.controller instanceof QuickPick && this.controller.canSelectMany) {
          list.clearFocus();
        }
      }, 0);
    }));
    const focusTracker = trackFocus(container);
    this._register(focusTracker);
    this._register(addDisposableListener(container, EventType.FOCUS, (e) => {
      if (isAncestor(e.relatedTarget, container)) {
        return;
      }
      this.previousFocusElement = e.relatedTarget instanceof HTMLElement ? e.relatedTarget : void 0;
    }, true));
    this._register(focusTracker.onDidBlur(() => {
      if (!this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut()) {
        this.hide(QuickInputHideReason.Blur);
      }
      this.previousFocusElement = void 0;
    }));
    this._register(addDisposableListener(container, EventType.FOCUS, (e) => {
      inputBox.setFocus();
    }));
    this._register(addStandardDisposableListener(container, EventType.KEY_DOWN, (event) => {
      if (isAncestor(event.target, widget)) {
        return;
      }
      switch (event.keyCode) {
        case 3:
          EventHelper.stop(event, true);
          if (this.enabled) {
            this.onDidAcceptEmitter.fire();
          }
          break;
        case 9:
          EventHelper.stop(event, true);
          this.hide(QuickInputHideReason.Gesture);
          break;
        case 2:
          if (!event.altKey && !event.ctrlKey && !event.metaKey) {
            const selectors = [
              ".quick-input-list .monaco-action-bar .always-visible",
              ".quick-input-list-entry:hover .monaco-action-bar",
              ".monaco-list-row.focused .monaco-action-bar"
            ];
            if (container.classList.contains("show-checkboxes")) {
              selectors.push("input");
            } else {
              selectors.push("input[type=text]");
            }
            if (this.getUI().list.isDisplayed()) {
              selectors.push(".monaco-list");
            }
            if (this.getUI().message) {
              selectors.push(".quick-input-message a");
            }
            if (this.getUI().widget) {
              if (isAncestor(event.target, this.getUI().widget)) {
                break;
              }
              selectors.push(".quick-input-html-widget");
            }
            const stops = container.querySelectorAll(selectors.join(", "));
            if (event.shiftKey && event.target === stops[0]) {
              EventHelper.stop(event, true);
              list.clearFocus();
            } else if (!event.shiftKey && isAncestor(event.target, stops[stops.length - 1])) {
              EventHelper.stop(event, true);
              stops[0].focus();
            }
          }
          break;
        case 10:
          if (event.ctrlKey) {
            EventHelper.stop(event, true);
            this.getUI().list.toggleHover();
          }
          break;
      }
    }));
    this.ui = {
      container,
      styleSheet,
      leftActionBar,
      titleBar,
      title,
      description1,
      description2,
      widget,
      rightActionBar,
      checkAll,
      inputContainer,
      filterContainer,
      inputBox,
      visibleCountContainer,
      visibleCount,
      countContainer,
      count,
      okContainer,
      ok,
      message,
      customButtonContainer,
      customButton,
      list,
      progressBar,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: false,
      keyMods: this.keyMods,
      show: (controller) => this.show(controller),
      hide: () => this.hide(),
      setVisibilities: (visibilities) => this.setVisibilities(visibilities),
      setEnabled: (enabled) => this.setEnabled(enabled),
      setContextKey: (contextKey) => this.options.setContextKey(contextKey),
      linkOpenerDelegate: (content) => this.options.linkOpenerDelegate(content)
    };
    this.updateStyles();
    return this.ui;
  }
  reparentUI(container) {
    if (this.ui) {
      this.parentElement = container;
      append(this.parentElement, this.ui.container);
    }
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return new Promise((doResolve, reject) => {
      let resolve = (result) => {
        var _a;
        resolve = doResolve;
        (_a = options.onKeyMods) === null || _a === void 0 ? void 0 : _a.call(options, input.keyMods);
        doResolve(result);
      };
      if (token.isCancellationRequested) {
        resolve(void 0);
        return;
      }
      const input = this.createQuickPick();
      let activeItem;
      const disposables = [
        input,
        input.onDidAccept(() => {
          if (input.canSelectMany) {
            resolve(input.selectedItems.slice());
            input.hide();
          } else {
            const result = input.activeItems[0];
            if (result) {
              resolve(result);
              input.hide();
            }
          }
        }),
        input.onDidChangeActive((items) => {
          const focused = items[0];
          if (focused && options.onDidFocus) {
            options.onDidFocus(focused);
          }
        }),
        input.onDidChangeSelection((items) => {
          if (!input.canSelectMany) {
            const result = items[0];
            if (result) {
              resolve(result);
              input.hide();
            }
          }
        }),
        input.onDidTriggerItemButton((event) => options.onDidTriggerItemButton && options.onDidTriggerItemButton({
          ...event,
          removeItem: () => {
            const index = input.items.indexOf(event.item);
            if (index !== -1) {
              const items = input.items.slice();
              const removed = items.splice(index, 1);
              const activeItems = input.activeItems.filter((activeItem2) => activeItem2 !== removed[0]);
              const keepScrollPositionBefore = input.keepScrollPosition;
              input.keepScrollPosition = true;
              input.items = items;
              if (activeItems) {
                input.activeItems = activeItems;
              }
              input.keepScrollPosition = keepScrollPositionBefore;
            }
          }
        })),
        input.onDidTriggerSeparatorButton((event) => {
          var _a;
          return (_a = options.onDidTriggerSeparatorButton) === null || _a === void 0 ? void 0 : _a.call(options, event);
        }),
        input.onDidChangeValue((value) => {
          if (activeItem && !value && (input.activeItems.length !== 1 || input.activeItems[0] !== activeItem)) {
            input.activeItems = [activeItem];
          }
        }),
        token.onCancellationRequested(() => {
          input.hide();
        }),
        input.onDidHide(() => {
          dispose(disposables);
          resolve(void 0);
        })
      ];
      input.title = options.title;
      input.canSelectMany = !!options.canPickMany;
      input.placeholder = options.placeHolder;
      input.ignoreFocusOut = !!options.ignoreFocusLost;
      input.matchOnDescription = !!options.matchOnDescription;
      input.matchOnDetail = !!options.matchOnDetail;
      input.matchOnLabel = options.matchOnLabel === void 0 || options.matchOnLabel;
      input.autoFocusOnList = options.autoFocusOnList === void 0 || options.autoFocusOnList;
      input.quickNavigate = options.quickNavigate;
      input.hideInput = !!options.hideInput;
      input.contextKey = options.contextKey;
      input.busy = true;
      Promise.all([picks, options.activeItem]).then(([items, _activeItem]) => {
        activeItem = _activeItem;
        input.busy = false;
        input.items = items;
        if (input.canSelectMany) {
          input.selectedItems = items.filter((item) => item.type !== "separator" && item.picked);
        }
        if (activeItem) {
          input.activeItems = [activeItem];
        }
      });
      input.show();
      Promise.resolve(picks).then(void 0, (err) => {
        reject(err);
        input.hide();
      });
    });
  }
  createQuickPick() {
    const ui = this.getUI(true);
    return new QuickPick(ui);
  }
  createInputBox() {
    const ui = this.getUI(true);
    return new InputBox(ui);
  }
  show(controller) {
    const ui = this.getUI(true);
    this.onShowEmitter.fire();
    const oldController = this.controller;
    this.controller = controller;
    oldController === null || oldController === void 0 ? void 0 : oldController.didHide();
    this.setEnabled(true);
    ui.leftActionBar.clear();
    ui.title.textContent = "";
    ui.description1.textContent = "";
    ui.description2.textContent = "";
    reset(ui.widget);
    ui.rightActionBar.clear();
    ui.checkAll.checked = false;
    ui.inputBox.placeholder = "";
    ui.inputBox.password = false;
    ui.inputBox.showDecoration(severity_default.Ignore);
    ui.visibleCount.setCount(0);
    ui.count.setCount(0);
    reset(ui.message);
    ui.progressBar.stop();
    ui.list.setElements([]);
    ui.list.matchOnDescription = false;
    ui.list.matchOnDetail = false;
    ui.list.matchOnLabel = true;
    ui.list.sortByLabel = true;
    ui.ignoreFocusOut = false;
    ui.inputBox.toggles = void 0;
    const backKeybindingLabel = this.options.backKeybindingLabel();
    backButton.tooltip = backKeybindingLabel ? localize("quickInput.backWithKeybinding", "Back ({0})", backKeybindingLabel) : localize("quickInput.back", "Back");
    ui.container.style.display = "";
    this.updateLayout();
    ui.inputBox.setFocus();
  }
  isVisible() {
    return !!this.ui && this.ui.container.style.display !== "none";
  }
  setVisibilities(visibilities) {
    const ui = this.getUI();
    ui.title.style.display = visibilities.title ? "" : "none";
    ui.description1.style.display = visibilities.description && (visibilities.inputBox || visibilities.checkAll) ? "" : "none";
    ui.description2.style.display = visibilities.description && !(visibilities.inputBox || visibilities.checkAll) ? "" : "none";
    ui.checkAll.style.display = visibilities.checkAll ? "" : "none";
    ui.inputContainer.style.display = visibilities.inputBox ? "" : "none";
    ui.filterContainer.style.display = visibilities.inputBox ? "" : "none";
    ui.visibleCountContainer.style.display = visibilities.visibleCount ? "" : "none";
    ui.countContainer.style.display = visibilities.count ? "" : "none";
    ui.okContainer.style.display = visibilities.ok ? "" : "none";
    ui.customButtonContainer.style.display = visibilities.customButton ? "" : "none";
    ui.message.style.display = visibilities.message ? "" : "none";
    ui.progressBar.getContainer().style.display = visibilities.progressBar ? "" : "none";
    ui.list.display(!!visibilities.list);
    ui.container.classList.toggle("show-checkboxes", !!visibilities.checkBox);
    ui.container.classList.toggle("hidden-input", !visibilities.inputBox && !visibilities.description);
    this.updateLayout();
  }
  setEnabled(enabled) {
    if (enabled !== this.enabled) {
      this.enabled = enabled;
      for (const item of this.getUI().leftActionBar.viewItems) {
        item.action.enabled = enabled;
      }
      for (const item of this.getUI().rightActionBar.viewItems) {
        item.action.enabled = enabled;
      }
      this.getUI().checkAll.disabled = !enabled;
      this.getUI().inputBox.enabled = enabled;
      this.getUI().ok.enabled = enabled;
      this.getUI().list.enabled = enabled;
    }
  }
  hide(reason) {
    var _a, _b;
    const controller = this.controller;
    if (!controller) {
      return;
    }
    const container = (_a = this.ui) === null || _a === void 0 ? void 0 : _a.container;
    const focusChanged = container && !isAncestorOfActiveElement(container);
    this.controller = null;
    this.onHideEmitter.fire();
    if (container) {
      container.style.display = "none";
    }
    if (!focusChanged) {
      let currentElement = this.previousFocusElement;
      while (currentElement && !currentElement.offsetParent) {
        currentElement = (_b = currentElement.parentElement) !== null && _b !== void 0 ? _b : void 0;
      }
      if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.offsetParent) {
        currentElement.focus();
        this.previousFocusElement = void 0;
      } else {
        this.options.returnFocus();
      }
    }
    controller.didHide(reason);
  }
  layout(dimension, titleBarOffset) {
    this.dimension = dimension;
    this.titleBarOffset = titleBarOffset;
    this.updateLayout();
  }
  updateLayout() {
    if (this.ui && this.isVisible()) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const style = this.ui.container.style;
      const width = Math.min(this.dimension.width * 0.62, _QuickInputController.MAX_WIDTH);
      style.width = width + "px";
      style.marginLeft = "-" + width / 2 + "px";
      this.ui.inputBox.layout();
      this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(styles) {
    this.styles = styles;
    this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: quickInputTitleBackground2, quickInputBackground: quickInputBackground2, quickInputForeground: quickInputForeground2, widgetBorder: widgetBorder2, widgetShadow: widgetShadow2 } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = quickInputTitleBackground2 !== null && quickInputTitleBackground2 !== void 0 ? quickInputTitleBackground2 : "";
      this.ui.container.style.backgroundColor = quickInputBackground2 !== null && quickInputBackground2 !== void 0 ? quickInputBackground2 : "";
      this.ui.container.style.color = quickInputForeground2 !== null && quickInputForeground2 !== void 0 ? quickInputForeground2 : "";
      this.ui.container.style.border = widgetBorder2 ? `1px solid ${widgetBorder2}` : "";
      this.ui.container.style.boxShadow = widgetShadow2 ? `0 0 8px 2px ${widgetShadow2}` : "";
      this.ui.list.style(this.styles.list);
      const content = [];
      if (this.styles.pickerGroup.pickerGroupBorder) {
        content.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.pickerGroup.pickerGroupBorder}; }`);
      }
      if (this.styles.pickerGroup.pickerGroupForeground) {
        content.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.pickerGroup.pickerGroupForeground}; }`);
      }
      if (this.styles.pickerGroup.pickerGroupForeground) {
        content.push(`.quick-input-list .quick-input-list-separator-as-item { color: var(--vscode-descriptionForeground); }`);
      }
      if (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) {
        content.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {");
        if (this.styles.keybindingLabel.keybindingLabelBackground) {
          content.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelBorder) {
          content.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelBottomBorder) {
          content.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelShadow) {
          content.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`);
        }
        if (this.styles.keybindingLabel.keybindingLabelForeground) {
          content.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`);
        }
        content.push("}");
      }
      const newStyles = content.join("\n");
      if (newStyles !== this.ui.styleSheet.textContent) {
        this.ui.styleSheet.textContent = newStyles;
      }
    }
  }
};
QuickInputController.MAX_WIDTH = 600;

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/quickInputService.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var QuickInputService = class QuickInputService2 extends Themable {
  get controller() {
    if (!this._controller) {
      this._controller = this._register(this.createController());
    }
    return this._controller;
  }
  get hasController() {
    return !!this._controller;
  }
  get quickAccess() {
    if (!this._quickAccess) {
      this._quickAccess = this._register(this.instantiationService.createInstance(QuickAccessController));
    }
    return this._quickAccess;
  }
  constructor(instantiationService, contextKeyService, themeService, layoutService) {
    super(themeService);
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.layoutService = layoutService;
    this._onShow = this._register(new Emitter());
    this._onHide = this._register(new Emitter());
    this.contexts = /* @__PURE__ */ new Map();
  }
  createController(host = this.layoutService, options) {
    const defaultOptions = {
      idPrefix: "quickInput_",
      container: host.activeContainer,
      ignoreFocusOut: () => false,
      backKeybindingLabel: () => void 0,
      setContextKey: (id) => this.setContextKey(id),
      linkOpenerDelegate: (content) => {
        this.instantiationService.invokeFunction((accessor) => {
          const openerService = accessor.get(IOpenerService);
          openerService.open(content, { allowCommands: true, fromUserGesture: true });
        });
      },
      returnFocus: () => host.focus(),
      createList: (user, container, delegate, renderers, options2) => this.instantiationService.createInstance(WorkbenchList, user, container, delegate, renderers, options2),
      styles: this.computeStyles()
    };
    const controller = this._register(new QuickInputController({
      ...defaultOptions,
      ...options
    }, this.themeService, this.layoutService));
    controller.layout(host.activeContainerDimension, host.activeContainerOffset.quickPickTop);
    this._register(host.onDidLayoutActiveContainer((dimension) => controller.layout(dimension, host.activeContainerOffset.quickPickTop)));
    this._register(host.onDidChangeActiveContainer(() => {
      if (controller.isVisible()) {
        return;
      }
      controller.layout(host.activeContainerDimension, host.activeContainerOffset.quickPickTop);
    }));
    this._register(controller.onShow(() => {
      this.resetContextKeys();
      this._onShow.fire();
    }));
    this._register(controller.onHide(() => {
      this.resetContextKeys();
      this._onHide.fire();
    }));
    return controller;
  }
  setContextKey(id) {
    let key;
    if (id) {
      key = this.contexts.get(id);
      if (!key) {
        key = new RawContextKey(id, false).bindTo(this.contextKeyService);
        this.contexts.set(id, key);
      }
    }
    if (key && key.get()) {
      return;
    }
    this.resetContextKeys();
    key === null || key === void 0 ? void 0 : key.set(true);
  }
  resetContextKeys() {
    this.contexts.forEach((context) => {
      if (context.get()) {
        context.reset();
      }
    });
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return this.controller.pick(picks, options, token);
  }
  createQuickPick() {
    return this.controller.createQuickPick();
  }
  createInputBox() {
    return this.controller.createInputBox();
  }
  updateStyles() {
    if (this.hasController) {
      this.controller.applyStyles(this.computeStyles());
    }
  }
  computeStyles() {
    return {
      widget: {
        quickInputBackground: asCssVariable(quickInputBackground),
        quickInputForeground: asCssVariable(quickInputForeground),
        quickInputTitleBackground: asCssVariable(quickInputTitleBackground),
        widgetBorder: asCssVariable(widgetBorder),
        widgetShadow: asCssVariable(widgetShadow)
      },
      inputBox: defaultInputBoxStyles,
      toggle: defaultToggleStyles,
      countBadge: defaultCountBadgeStyles,
      button: defaultButtonStyles,
      progressBar: defaultProgressBarStyles,
      keybindingLabel: defaultKeybindingLabelStyles,
      list: getListStyles({
        listBackground: quickInputBackground,
        listFocusBackground: quickInputListFocusBackground,
        listFocusForeground: quickInputListFocusForeground,
        // Look like focused when inactive.
        listInactiveFocusForeground: quickInputListFocusForeground,
        listInactiveSelectionIconForeground: quickInputListFocusIconForeground,
        listInactiveFocusBackground: quickInputListFocusBackground,
        listFocusOutline: activeContrastBorder,
        listInactiveFocusOutline: activeContrastBorder
      }),
      pickerGroup: {
        pickerGroupBorder: asCssVariable(pickerGroupBorder),
        pickerGroupForeground: asCssVariable(pickerGroupForeground)
      }
    };
  }
};
QuickInputService = __decorate17([
  __param15(0, IInstantiationService),
  __param15(1, IContextKeyService),
  __param15(2, IThemeService),
  __param15(3, ILayoutService)
], QuickInputService);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EditorScopedQuickInputService = class EditorScopedQuickInputService2 extends QuickInputService {
  constructor(editor2, instantiationService, contextKeyService, themeService, codeEditorService) {
    super(instantiationService, contextKeyService, themeService, new EditorScopedLayoutService(editor2.getContainerDomNode(), codeEditorService));
    this.host = void 0;
    const contribution = QuickInputEditorContribution.get(editor2);
    if (contribution) {
      const widget = contribution.widget;
      this.host = {
        _serviceBrand: void 0,
        get mainContainer() {
          return widget.getDomNode();
        },
        getContainer() {
          return widget.getDomNode();
        },
        get containers() {
          return [widget.getDomNode()];
        },
        get activeContainer() {
          return widget.getDomNode();
        },
        get mainContainerDimension() {
          return editor2.getLayoutInfo();
        },
        get activeContainerDimension() {
          return editor2.getLayoutInfo();
        },
        get onDidLayoutMainContainer() {
          return editor2.onDidLayoutChange;
        },
        get onDidLayoutActiveContainer() {
          return editor2.onDidLayoutChange;
        },
        get onDidLayoutContainer() {
          return Event.map(editor2.onDidLayoutChange, (dimension) => ({ container: widget.getDomNode(), dimension }));
        },
        get onDidChangeActiveContainer() {
          return Event.None;
        },
        get onDidAddContainer() {
          return Event.None;
        },
        get mainContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        get activeContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        focus: () => editor2.focus()
      };
    } else {
      this.host = void 0;
    }
  }
  createController() {
    return super.createController(this.host);
  }
};
EditorScopedQuickInputService = __decorate18([
  __param16(1, IInstantiationService),
  __param16(2, IContextKeyService),
  __param16(3, IThemeService),
  __param16(4, ICodeEditorService)
], EditorScopedQuickInputService);
var StandaloneQuickInputService = class StandaloneQuickInputService2 {
  get activeService() {
    const editor2 = this.codeEditorService.getFocusedCodeEditor();
    if (!editor2) {
      throw new Error("Quick input service needs a focused editor to work.");
    }
    let quickInputService = this.mapEditorToService.get(editor2);
    if (!quickInputService) {
      const newQuickInputService = quickInputService = this.instantiationService.createInstance(EditorScopedQuickInputService, editor2);
      this.mapEditorToService.set(editor2, quickInputService);
      createSingleCallFunction(editor2.onDidDispose)(() => {
        newQuickInputService.dispose();
        this.mapEditorToService.delete(editor2);
      });
    }
    return quickInputService;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  constructor(instantiationService, codeEditorService) {
    this.instantiationService = instantiationService;
    this.codeEditorService = codeEditorService;
    this.mapEditorToService = /* @__PURE__ */ new Map();
  }
  pick(picks, options = {}, token = CancellationToken.None) {
    return this.activeService.pick(picks, options, token);
  }
  createQuickPick() {
    return this.activeService.createQuickPick();
  }
  createInputBox() {
    return this.activeService.createInputBox();
  }
};
StandaloneQuickInputService = __decorate18([
  __param16(0, IInstantiationService),
  __param16(1, ICodeEditorService)
], StandaloneQuickInputService);
var QuickInputEditorContribution = class _QuickInputEditorContribution {
  static get(editor2) {
    return editor2.getContribution(_QuickInputEditorContribution.ID);
  }
  constructor(editor2) {
    this.editor = editor2;
    this.widget = new QuickInputEditorWidget(this.editor);
  }
  dispose() {
    this.widget.dispose();
  }
};
QuickInputEditorContribution.ID = "editor.controller.quickInput";
var QuickInputEditorWidget = class _QuickInputEditorWidget {
  constructor(codeEditor) {
    this.codeEditor = codeEditor;
    this.domNode = document.createElement("div");
    this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return _QuickInputEditorWidget.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      preference: 2
      /* OverlayWidgetPositionPreference.TOP_CENTER */
    };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
};
QuickInputEditorWidget.ID = "editor.contrib.quickInputWidget";
registerEditorContribution(
  QuickInputEditorContribution.ID,
  QuickInputEditorContribution,
  4
  /* EditorContributionInstantiation.Lazy */
);

// node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js
var ParsedTokenThemeRule = class {
  constructor(token, index, fontStyle, foreground, background) {
    this._parsedThemeRuleBrand = void 0;
    this.token = token;
    this.index = index;
    this.fontStyle = fontStyle;
    this.foreground = foreground;
    this.background = background;
  }
};
function parseTokenTheme(source) {
  if (!source || !Array.isArray(source)) {
    return [];
  }
  const result = [];
  let resultLen = 0;
  for (let i = 0, len = source.length; i < len; i++) {
    const entry = source[i];
    let fontStyle = -1;
    if (typeof entry.fontStyle === "string") {
      fontStyle = 0;
      const segments = entry.fontStyle.split(" ");
      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {
        const segment = segments[j];
        switch (segment) {
          case "italic":
            fontStyle = fontStyle | 1;
            break;
          case "bold":
            fontStyle = fontStyle | 2;
            break;
          case "underline":
            fontStyle = fontStyle | 4;
            break;
          case "strikethrough":
            fontStyle = fontStyle | 8;
            break;
        }
      }
    }
    let foreground = null;
    if (typeof entry.foreground === "string") {
      foreground = entry.foreground;
    }
    let background = null;
    if (typeof entry.background === "string") {
      background = entry.background;
    }
    result[resultLen++] = new ParsedTokenThemeRule(entry.token || "", i, fontStyle, foreground, background);
  }
  return result;
}
function resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {
  parsedThemeRules.sort((a, b) => {
    const r = strcmp(a.token, b.token);
    if (r !== 0) {
      return r;
    }
    return a.index - b.index;
  });
  let defaultFontStyle = 0;
  let defaultForeground = "000000";
  let defaultBackground = "ffffff";
  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === "") {
    const incomingDefaults = parsedThemeRules.shift();
    if (incomingDefaults.fontStyle !== -1) {
      defaultFontStyle = incomingDefaults.fontStyle;
    }
    if (incomingDefaults.foreground !== null) {
      defaultForeground = incomingDefaults.foreground;
    }
    if (incomingDefaults.background !== null) {
      defaultBackground = incomingDefaults.background;
    }
  }
  const colorMap = new ColorMap();
  for (const color of customTokenColors) {
    colorMap.getId(color);
  }
  const foregroundColorId = colorMap.getId(defaultForeground);
  const backgroundColorId = colorMap.getId(defaultBackground);
  const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);
  const root = new ThemeTrieElement(defaults);
  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {
    const rule = parsedThemeRules[i];
    root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
  }
  return new TokenTheme(colorMap, root);
}
var colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
var ColorMap = class {
  constructor() {
    this._lastColorId = 0;
    this._id2color = [];
    this._color2id = /* @__PURE__ */ new Map();
  }
  getId(color) {
    if (color === null) {
      return 0;
    }
    const match2 = color.match(colorRegExp);
    if (!match2) {
      throw new Error("Illegal value for token color: " + color);
    }
    color = match2[1].toUpperCase();
    let value = this._color2id.get(color);
    if (value) {
      return value;
    }
    value = ++this._lastColorId;
    this._color2id.set(color, value);
    this._id2color[value] = Color.fromHex("#" + color);
    return value;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
};
var TokenTheme = class {
  static createFromRawTokenTheme(source, customTokenColors) {
    return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);
  }
  static createFromParsedTokenTheme(source, customTokenColors) {
    return resolveParsedTokenThemeRules(source, customTokenColors);
  }
  constructor(colorMap, root) {
    this._colorMap = colorMap;
    this._root = root;
    this._cache = /* @__PURE__ */ new Map();
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(token) {
    return this._root.match(token);
  }
  match(languageId, token) {
    let result = this._cache.get(token);
    if (typeof result === "undefined") {
      const rule = this._match(token);
      const standardToken = toStandardTokenType(token);
      result = (rule.metadata | standardToken << 8) >>> 0;
      this._cache.set(token, result);
    }
    return (result | languageId << 0) >>> 0;
  }
};
var STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|regexp)\b/;
function toStandardTokenType(tokenType) {
  const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);
  if (!m) {
    return 0;
  }
  switch (m[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 3;
    case "regexp":
      return 3;
  }
  throw new Error("Unexpected match for standard token type!");
}
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
var ThemeTrieElementRule = class _ThemeTrieElementRule {
  constructor(fontStyle, foreground, background) {
    this._themeTrieElementRuleBrand = void 0;
    this._fontStyle = fontStyle;
    this._foreground = foreground;
    this._background = background;
    this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
  clone() {
    return new _ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(fontStyle, foreground, background) {
    if (fontStyle !== -1) {
      this._fontStyle = fontStyle;
    }
    if (foreground !== 0) {
      this._foreground = foreground;
    }
    if (background !== 0) {
      this._background = background;
    }
    this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
};
var ThemeTrieElement = class _ThemeTrieElement {
  constructor(mainRule) {
    this._themeTrieElementBrand = void 0;
    this._mainRule = mainRule;
    this._children = /* @__PURE__ */ new Map();
  }
  match(token) {
    if (token === "") {
      return this._mainRule;
    }
    const dotIndex = token.indexOf(".");
    let head;
    let tail;
    if (dotIndex === -1) {
      head = token;
      tail = "";
    } else {
      head = token.substring(0, dotIndex);
      tail = token.substring(dotIndex + 1);
    }
    const child = this._children.get(head);
    if (typeof child !== "undefined") {
      return child.match(tail);
    }
    return this._mainRule;
  }
  insert(token, fontStyle, foreground, background) {
    if (token === "") {
      this._mainRule.acceptOverwrite(fontStyle, foreground, background);
      return;
    }
    const dotIndex = token.indexOf(".");
    let head;
    let tail;
    if (dotIndex === -1) {
      head = token;
      tail = "";
    } else {
      head = token.substring(0, dotIndex);
      tail = token.substring(dotIndex + 1);
    }
    let child = this._children.get(head);
    if (typeof child === "undefined") {
      child = new _ThemeTrieElement(this._mainRule.clone());
      this._children.set(head, child);
    }
    child.insert(tail, fontStyle, foreground, background);
  }
};
function generateTokensCSSForColorMap(colorMap) {
  const rules = [];
  for (let i = 1, len = colorMap.length; i < len; i++) {
    const color = colorMap[i];
    rules[i] = `.mtk${i} { color: ${color}; }`;
  }
  rules.push(".mtki { font-style: italic; }");
  rules.push(".mtkb { font-weight: bold; }");
  rules.push(".mtku { text-decoration: underline; text-underline-position: under; }");
  rules.push(".mtks { text-decoration: line-through; }");
  rules.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }");
  return rules.join("\n");
}

// node_modules/monaco-editor/esm/vs/editor/standalone/common/themes.js
var vs = {
  base: "vs",
  inherit: false,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [editorBackground]: "#FFFFFE",
    [editorForeground]: "#000000",
    [editorInactiveSelection]: "#E5EBF1",
    [editorIndentGuide1]: "#D3D3D3",
    [editorActiveIndentGuide1]: "#939393",
    [editorSelectionHighlight]: "#ADD6FF4D"
  }
};
var vs_dark = {
  base: "vs-dark",
  inherit: false,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [editorBackground]: "#1E1E1E",
    [editorForeground]: "#D4D4D4",
    [editorInactiveSelection]: "#3A3D41",
    [editorIndentGuide1]: "#404040",
    [editorActiveIndentGuide1]: "#707070",
    [editorSelectionHighlight]: "#ADD6FF26"
  }
};
var hc_black = {
  base: "hc-black",
  inherit: false,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [editorBackground]: "#000000",
    [editorForeground]: "#FFFFFF",
    [editorIndentGuide1]: "#FFFFFF",
    [editorActiveIndentGuide1]: "#FFFFFF"
  }
};
var hc_light = {
  base: "hc-light",
  inherit: false,
  rules: [
    { token: "", foreground: "292929", background: "FFFFFF" },
    { token: "invalid", foreground: "B5200D" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "264F70" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "B5200D" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "264F78" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "string", foreground: "A31515" },
    { token: "string.sql", foreground: "B5200D" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [editorBackground]: "#FFFFFF",
    [editorForeground]: "#292929",
    [editorIndentGuide1]: "#292929",
    [editorActiveIndentGuide1]: "#292929"
  }
};

// node_modules/monaco-editor/esm/vs/platform/theme/browser/iconsStyleSheet.js
function getIconsStyleSheet(themeService) {
  const disposable = new DisposableStore();
  const onDidChangeEmmiter = disposable.add(new Emitter());
  const iconRegistry = getIconRegistry();
  disposable.add(iconRegistry.onDidChange(() => onDidChangeEmmiter.fire()));
  if (themeService) {
    disposable.add(themeService.onDidProductIconThemeChange(() => onDidChangeEmmiter.fire()));
  }
  return {
    dispose: () => disposable.dispose(),
    onDidChange: onDidChangeEmmiter.event,
    getCSS() {
      const productIconTheme = themeService ? themeService.getProductIconTheme() : new UnthemedProductIconTheme();
      const usedFontIds = {};
      const formatIconRule = (contribution) => {
        const definition = productIconTheme.getIcon(contribution);
        if (!definition) {
          return void 0;
        }
        const fontContribution = definition.font;
        if (fontContribution) {
          usedFontIds[fontContribution.id] = fontContribution.definition;
          return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; font-family: ${asCSSPropertyValue(fontContribution.id)}; }`;
        }
        return `.codicon-${contribution.id}:before { content: '${definition.fontCharacter}'; }`;
      };
      const rules = [];
      for (const contribution of iconRegistry.getIcons()) {
        const rule = formatIconRule(contribution);
        if (rule) {
          rules.push(rule);
        }
      }
      for (const id in usedFontIds) {
        const definition = usedFontIds[id];
        const fontWeight = definition.weight ? `font-weight: ${definition.weight};` : "";
        const fontStyle = definition.style ? `font-style: ${definition.style};` : "";
        const src = definition.src.map((l) => `${asCSSUrl(l.location)} format('${l.format}')`).join(", ");
        rules.push(`@font-face { src: ${src}; font-family: ${asCSSPropertyValue(id)};${fontWeight}${fontStyle} font-display: block; }`);
      }
      return rules.join("\n");
    }
  };
}
var UnthemedProductIconTheme = class {
  getIcon(contribution) {
    const iconRegistry = getIconRegistry();
    let definition = contribution.defaults;
    while (ThemeIcon.isThemeIcon(definition)) {
      const c = iconRegistry.getIcon(definition.id);
      if (!c) {
        return void 0;
      }
      definition = c.defaults;
    }
    return definition;
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneThemeService.js
var VS_LIGHT_THEME_NAME = "vs";
var VS_DARK_THEME_NAME = "vs-dark";
var HC_BLACK_THEME_NAME = "hc-black";
var HC_LIGHT_THEME_NAME = "hc-light";
var colorRegistry = Registry.as(Extensions3.ColorContribution);
var themingRegistry = Registry.as(Extensions2.ThemingContribution);
var StandaloneTheme = class {
  constructor(name, standaloneThemeData) {
    this.semanticHighlighting = false;
    this.themeData = standaloneThemeData;
    const base = standaloneThemeData.base;
    if (name.length > 0) {
      if (isBuiltinTheme(name)) {
        this.id = name;
      } else {
        this.id = base + " " + name;
      }
      this.themeName = name;
    } else {
      this.id = base;
      this.themeName = base;
    }
    this.colors = null;
    this.defaultColors = /* @__PURE__ */ Object.create(null);
    this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    if (this.themeData.inherit) {
      this.colors = null;
      this._tokenTheme = null;
    }
  }
  getColors() {
    if (!this.colors) {
      const colors = /* @__PURE__ */ new Map();
      for (const id in this.themeData.colors) {
        colors.set(id, Color.fromHex(this.themeData.colors[id]));
      }
      if (this.themeData.inherit) {
        const baseData = getBuiltinRules(this.themeData.base);
        for (const id in baseData.colors) {
          if (!colors.has(id)) {
            colors.set(id, Color.fromHex(baseData.colors[id]));
          }
        }
      }
      this.colors = colors;
    }
    return this.colors;
  }
  getColor(colorId, useDefault) {
    const color = this.getColors().get(colorId);
    if (color) {
      return color;
    }
    if (useDefault !== false) {
      return this.getDefault(colorId);
    }
    return void 0;
  }
  getDefault(colorId) {
    let color = this.defaultColors[colorId];
    if (color) {
      return color;
    }
    color = colorRegistry.resolveDefaultColor(colorId, this);
    this.defaultColors[colorId] = color;
    return color;
  }
  defines(colorId) {
    return this.getColors().has(colorId);
  }
  get type() {
    switch (this.base) {
      case VS_LIGHT_THEME_NAME:
        return ColorScheme.LIGHT;
      case HC_BLACK_THEME_NAME:
        return ColorScheme.HIGH_CONTRAST_DARK;
      case HC_LIGHT_THEME_NAME:
        return ColorScheme.HIGH_CONTRAST_LIGHT;
      default:
        return ColorScheme.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let rules = [];
      let encodedTokensColors = [];
      if (this.themeData.inherit) {
        const baseData = getBuiltinRules(this.themeData.base);
        rules = baseData.rules;
        if (baseData.encodedTokensColors) {
          encodedTokensColors = baseData.encodedTokensColors;
        }
      }
      const editorForeground2 = this.themeData.colors["editor.foreground"];
      const editorBackground2 = this.themeData.colors["editor.background"];
      if (editorForeground2 || editorBackground2) {
        const rule = { token: "" };
        if (editorForeground2) {
          rule.foreground = editorForeground2;
        }
        if (editorBackground2) {
          rule.background = editorBackground2;
        }
        rules.push(rule);
      }
      rules = rules.concat(this.themeData.rules);
      if (this.themeData.encodedTokensColors) {
        encodedTokensColors = this.themeData.encodedTokensColors;
      }
      this._tokenTheme = TokenTheme.createFromRawTokenTheme(rules, encodedTokensColors);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(type, modifiers, modelLanguage) {
    const style = this.tokenTheme._match([type].concat(modifiers).join("."));
    const metadata = style.metadata;
    const foreground = TokenMetadata.getForeground(metadata);
    const fontStyle = TokenMetadata.getFontStyle(metadata);
    return {
      foreground,
      italic: Boolean(
        fontStyle & 1
        /* FontStyle.Italic */
      ),
      bold: Boolean(
        fontStyle & 2
        /* FontStyle.Bold */
      ),
      underline: Boolean(
        fontStyle & 4
        /* FontStyle.Underline */
      ),
      strikethrough: Boolean(
        fontStyle & 8
        /* FontStyle.Strikethrough */
      )
    };
  }
};
function isBuiltinTheme(themeName) {
  return themeName === VS_LIGHT_THEME_NAME || themeName === VS_DARK_THEME_NAME || themeName === HC_BLACK_THEME_NAME || themeName === HC_LIGHT_THEME_NAME;
}
function getBuiltinRules(builtinTheme) {
  switch (builtinTheme) {
    case VS_LIGHT_THEME_NAME:
      return vs;
    case VS_DARK_THEME_NAME:
      return vs_dark;
    case HC_BLACK_THEME_NAME:
      return hc_black;
    case HC_LIGHT_THEME_NAME:
      return hc_light;
  }
}
function newBuiltInTheme(builtinTheme) {
  const themeData = getBuiltinRules(builtinTheme);
  return new StandaloneTheme(builtinTheme, themeData);
}
var StandaloneThemeService = class extends Disposable {
  constructor() {
    super();
    this._onColorThemeChange = this._register(new Emitter());
    this.onDidColorThemeChange = this._onColorThemeChange.event;
    this._onProductIconThemeChange = this._register(new Emitter());
    this.onDidProductIconThemeChange = this._onProductIconThemeChange.event;
    this._environment = /* @__PURE__ */ Object.create(null);
    this._builtInProductIconTheme = new UnthemedProductIconTheme();
    this._autoDetectHighContrast = true;
    this._knownThemes = /* @__PURE__ */ new Map();
    this._knownThemes.set(VS_LIGHT_THEME_NAME, newBuiltInTheme(VS_LIGHT_THEME_NAME));
    this._knownThemes.set(VS_DARK_THEME_NAME, newBuiltInTheme(VS_DARK_THEME_NAME));
    this._knownThemes.set(HC_BLACK_THEME_NAME, newBuiltInTheme(HC_BLACK_THEME_NAME));
    this._knownThemes.set(HC_LIGHT_THEME_NAME, newBuiltInTheme(HC_LIGHT_THEME_NAME));
    const iconsStyleSheet = this._register(getIconsStyleSheet(this));
    this._codiconCSS = iconsStyleSheet.getCSS();
    this._themeCSS = "";
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`;
    this._globalStyleElement = null;
    this._styleElements = [];
    this._colorMapOverride = null;
    this.setTheme(VS_LIGHT_THEME_NAME);
    this._onOSSchemeChanged();
    this._register(iconsStyleSheet.onDidChange(() => {
      this._codiconCSS = iconsStyleSheet.getCSS();
      this._updateCSS();
    }));
    addMatchMediaChangeListener("(forced-colors: active)", () => {
      this._onOSSchemeChanged();
    });
  }
  registerEditorContainer(domNode) {
    if (isInShadowDOM(domNode)) {
      return this._registerShadowDomContainer(domNode);
    }
    return this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    if (!this._globalStyleElement) {
      this._globalStyleElement = createStyleSheet(void 0, (style) => {
        style.className = "monaco-colors";
        style.textContent = this._allCSS;
      });
      this._styleElements.push(this._globalStyleElement);
    }
    return Disposable.None;
  }
  _registerShadowDomContainer(domNode) {
    const styleElement = createStyleSheet(domNode, (style) => {
      style.className = "monaco-colors";
      style.textContent = this._allCSS;
    });
    this._styleElements.push(styleElement);
    return {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++) {
          if (this._styleElements[i] === styleElement) {
            this._styleElements.splice(i, 1);
            return;
          }
        }
      }
    };
  }
  defineTheme(themeName, themeData) {
    if (!/^[a-z0-9\-]+$/i.test(themeName)) {
      throw new Error("Illegal theme name!");
    }
    if (!isBuiltinTheme(themeData.base) && !isBuiltinTheme(themeName)) {
      throw new Error("Illegal theme base!");
    }
    this._knownThemes.set(themeName, new StandaloneTheme(themeName, themeData));
    if (isBuiltinTheme(themeName)) {
      this._knownThemes.forEach((theme) => {
        if (theme.base === themeName) {
          theme.notifyBaseUpdated();
        }
      });
    }
    if (this._theme.themeName === themeName) {
      this.setTheme(themeName);
    }
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(colorMapOverride) {
    this._colorMapOverride = colorMapOverride;
    this._updateThemeOrColorMap();
  }
  setTheme(themeName) {
    let theme;
    if (this._knownThemes.has(themeName)) {
      theme = this._knownThemes.get(themeName);
    } else {
      theme = this._knownThemes.get(VS_LIGHT_THEME_NAME);
    }
    this._updateActualTheme(theme);
  }
  _updateActualTheme(desiredTheme) {
    if (!desiredTheme || this._theme === desiredTheme) {
      return;
    }
    this._theme = desiredTheme;
    this._updateThemeOrColorMap();
  }
  _onOSSchemeChanged() {
    if (this._autoDetectHighContrast) {
      const wantsHighContrast = mainWindow.matchMedia(`(forced-colors: active)`).matches;
      if (wantsHighContrast !== isHighContrast(this._theme.type)) {
        let newThemeName;
        if (isDark(this._theme.type)) {
          newThemeName = wantsHighContrast ? HC_BLACK_THEME_NAME : VS_DARK_THEME_NAME;
        } else {
          newThemeName = wantsHighContrast ? HC_LIGHT_THEME_NAME : VS_LIGHT_THEME_NAME;
        }
        this._updateActualTheme(this._knownThemes.get(newThemeName));
      }
    }
  }
  setAutoDetectHighContrast(autoDetectHighContrast) {
    this._autoDetectHighContrast = autoDetectHighContrast;
    this._onOSSchemeChanged();
  }
  _updateThemeOrColorMap() {
    const cssRules = [];
    const hasRule = {};
    const ruleCollector = {
      addRule: (rule) => {
        if (!hasRule[rule]) {
          cssRules.push(rule);
          hasRule[rule] = true;
        }
      }
    };
    themingRegistry.getThemingParticipants().forEach((p) => p(this._theme, ruleCollector, this._environment));
    const colorVariables = [];
    for (const item of colorRegistry.getColors()) {
      const color = this._theme.getColor(item.id, true);
      if (color) {
        colorVariables.push(`${asCssVariableName(item.id)}: ${color.toString()};`);
      }
    }
    ruleCollector.addRule(`.monaco-editor, .monaco-diff-editor, .monaco-component { ${colorVariables.join("\n")} }`);
    const colorMap = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    ruleCollector.addRule(generateTokensCSSForColorMap(colorMap));
    this._themeCSS = cssRules.join("\n");
    this._updateCSS();
    TokenizationRegistry.setColorMap(colorMap);
    this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`;
    this._styleElements.forEach((styleElement) => styleElement.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: false,
      hasFolderIcons: false,
      hidesExplorerArrows: false
    };
  }
  getProductIconTheme() {
    return this._builtInProductIconTheme;
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/common/standaloneTheme.js
var IStandaloneThemeService = createDecorator("themeService");

// node_modules/monaco-editor/esm/vs/platform/accessibility/browser/accessibilityService.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AccessibilityService = class AccessibilityService2 extends Disposable {
  constructor(_contextKeyService, _layoutService, _configurationService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._layoutService = _layoutService;
    this._configurationService = _configurationService;
    this._accessibilitySupport = 0;
    this._onDidChangeScreenReaderOptimized = new Emitter();
    this._onDidChangeReducedMotion = new Emitter();
    this._accessibilityModeEnabledContext = CONTEXT_ACCESSIBILITY_MODE_ENABLED.bindTo(this._contextKeyService);
    const updateContextKey = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("editor.accessibilitySupport")) {
        updateContextKey();
        this._onDidChangeScreenReaderOptimized.fire();
      }
      if (e.affectsConfiguration("workbench.reduceMotion")) {
        this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion");
        this._onDidChangeReducedMotion.fire();
      }
    }));
    updateContextKey();
    this._register(this.onDidChangeScreenReaderOptimized(() => updateContextKey()));
    const reduceMotionMatcher = mainWindow.matchMedia(`(prefers-reduced-motion: reduce)`);
    this._systemMotionReduced = reduceMotionMatcher.matches;
    this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion");
    this.initReducedMotionListeners(reduceMotionMatcher);
  }
  initReducedMotionListeners(reduceMotionMatcher) {
    this._register(addDisposableListener(reduceMotionMatcher, "change", () => {
      this._systemMotionReduced = reduceMotionMatcher.matches;
      if (this._configMotionReduced === "auto") {
        this._onDidChangeReducedMotion.fire();
      }
    }));
    const updateRootClasses = () => {
      const reduce = this.isMotionReduced();
      this._layoutService.mainContainer.classList.toggle("reduce-motion", reduce);
      this._layoutService.mainContainer.classList.toggle("enable-motion", !reduce);
    };
    updateRootClasses();
    this._register(this.onDidChangeReducedMotion(() => updateRootClasses()));
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const config = this._configurationService.getValue("editor.accessibilitySupport");
    return config === "on" || config === "auto" && this._accessibilitySupport === 2;
  }
  get onDidChangeReducedMotion() {
    return this._onDidChangeReducedMotion.event;
  }
  isMotionReduced() {
    const config = this._configMotionReduced;
    return config === "on" || config === "auto" && this._systemMotionReduced;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
AccessibilityService = __decorate19([
  __param17(0, IContextKeyService),
  __param17(1, ILayoutService),
  __param17(2, IConfigurationService)
], AccessibilityService);

// node_modules/monaco-editor/esm/vs/platform/actions/common/menuService.js
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var PersistedMenuHideState_1;
var MenuInfo_1;
var MenuService = class MenuService2 {
  constructor(_commandService, storageService) {
    this._commandService = _commandService;
    this._hiddenStates = new PersistedMenuHideState(storageService);
  }
  createMenu(id, contextKeyService, options) {
    return new MenuImpl(id, this._hiddenStates, { emitEventsForSubmenuChanges: false, eventDebounceDelay: 50, ...options }, this._commandService, contextKeyService);
  }
  resetHiddenStates(ids) {
    this._hiddenStates.reset(ids);
  }
};
MenuService = __decorate20([
  __param18(0, ICommandService),
  __param18(1, IStorageService)
], MenuService);
var PersistedMenuHideState = PersistedMenuHideState_1 = class PersistedMenuHideState2 {
  constructor(_storageService) {
    this._storageService = _storageService;
    this._disposables = new DisposableStore();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._ignoreChangeEvent = false;
    this._hiddenByDefaultCache = /* @__PURE__ */ new Map();
    try {
      const raw = _storageService.get(PersistedMenuHideState_1._key, 0, "{}");
      this._data = JSON.parse(raw);
    } catch (err) {
      this._data = /* @__PURE__ */ Object.create(null);
    }
    this._disposables.add(_storageService.onDidChangeValue(0, PersistedMenuHideState_1._key, this._disposables)(() => {
      if (!this._ignoreChangeEvent) {
        try {
          const raw = _storageService.get(PersistedMenuHideState_1._key, 0, "{}");
          this._data = JSON.parse(raw);
        } catch (err) {
          console.log("FAILED to read storage after UPDATE", err);
        }
      }
      this._onDidChange.fire();
    }));
  }
  dispose() {
    this._onDidChange.dispose();
    this._disposables.dispose();
  }
  _isHiddenByDefault(menu, commandId) {
    var _a;
    return (_a = this._hiddenByDefaultCache.get(`${menu.id}/${commandId}`)) !== null && _a !== void 0 ? _a : false;
  }
  setDefaultState(menu, commandId, hidden) {
    this._hiddenByDefaultCache.set(`${menu.id}/${commandId}`, hidden);
  }
  isHidden(menu, commandId) {
    var _a, _b;
    const hiddenByDefault = this._isHiddenByDefault(menu, commandId);
    const state = (_b = (_a = this._data[menu.id]) === null || _a === void 0 ? void 0 : _a.includes(commandId)) !== null && _b !== void 0 ? _b : false;
    return hiddenByDefault ? !state : state;
  }
  updateHidden(menu, commandId, hidden) {
    const hiddenByDefault = this._isHiddenByDefault(menu, commandId);
    if (hiddenByDefault) {
      hidden = !hidden;
    }
    const entries = this._data[menu.id];
    if (!hidden) {
      if (entries) {
        const idx = entries.indexOf(commandId);
        if (idx >= 0) {
          removeFastWithoutKeepingOrder(entries, idx);
        }
        if (entries.length === 0) {
          delete this._data[menu.id];
        }
      }
    } else {
      if (!entries) {
        this._data[menu.id] = [commandId];
      } else {
        const idx = entries.indexOf(commandId);
        if (idx < 0) {
          entries.push(commandId);
        }
      }
    }
    this._persist();
  }
  reset(menus) {
    if (menus === void 0) {
      this._data = /* @__PURE__ */ Object.create(null);
      this._persist();
    } else {
      for (const { id } of menus) {
        if (this._data[id]) {
          delete this._data[id];
        }
      }
      this._persist();
    }
  }
  _persist() {
    try {
      this._ignoreChangeEvent = true;
      const raw = JSON.stringify(this._data);
      this._storageService.store(
        PersistedMenuHideState_1._key,
        raw,
        0,
        0
        /* StorageTarget.USER */
      );
    } finally {
      this._ignoreChangeEvent = false;
    }
  }
};
PersistedMenuHideState._key = "menu.hiddenCommands";
PersistedMenuHideState = PersistedMenuHideState_1 = __decorate20([
  __param18(0, IStorageService)
], PersistedMenuHideState);
var MenuInfo = MenuInfo_1 = class MenuInfo2 {
  constructor(_id, _hiddenStates, _collectContextKeysForSubmenus, _commandService, _contextKeyService) {
    this._id = _id;
    this._hiddenStates = _hiddenStates;
    this._collectContextKeysForSubmenus = _collectContextKeysForSubmenus;
    this._commandService = _commandService;
    this._contextKeyService = _contextKeyService;
    this._menuGroups = [];
    this._structureContextKeys = /* @__PURE__ */ new Set();
    this._preconditionContextKeys = /* @__PURE__ */ new Set();
    this._toggledContextKeys = /* @__PURE__ */ new Set();
    this.refresh();
  }
  get structureContextKeys() {
    return this._structureContextKeys;
  }
  get preconditionContextKeys() {
    return this._preconditionContextKeys;
  }
  get toggledContextKeys() {
    return this._toggledContextKeys;
  }
  refresh() {
    this._menuGroups.length = 0;
    this._structureContextKeys.clear();
    this._preconditionContextKeys.clear();
    this._toggledContextKeys.clear();
    const menuItems = MenuRegistry.getMenuItems(this._id);
    let group;
    menuItems.sort(MenuInfo_1._compareMenuItems);
    for (const item of menuItems) {
      const groupName = item.group || "";
      if (!group || group[0] !== groupName) {
        group = [groupName, []];
        this._menuGroups.push(group);
      }
      group[1].push(item);
      this._collectContextKeys(item);
    }
  }
  _collectContextKeys(item) {
    MenuInfo_1._fillInKbExprKeys(item.when, this._structureContextKeys);
    if (isIMenuItem(item)) {
      if (item.command.precondition) {
        MenuInfo_1._fillInKbExprKeys(item.command.precondition, this._preconditionContextKeys);
      }
      if (item.command.toggled) {
        const toggledExpression = item.command.toggled.condition || item.command.toggled;
        MenuInfo_1._fillInKbExprKeys(toggledExpression, this._toggledContextKeys);
      }
    } else if (this._collectContextKeysForSubmenus) {
      MenuRegistry.getMenuItems(item.submenu).forEach(this._collectContextKeys, this);
    }
  }
  createActionGroups(options) {
    const result = [];
    for (const group of this._menuGroups) {
      const [id, items] = group;
      const activeActions = [];
      for (const item of items) {
        if (this._contextKeyService.contextMatchesRules(item.when)) {
          const isMenuItem = isIMenuItem(item);
          if (isMenuItem) {
            this._hiddenStates.setDefaultState(this._id, item.command.id, !!item.isHiddenByDefault);
          }
          const menuHide = createMenuHide(this._id, isMenuItem ? item.command : item, this._hiddenStates);
          if (isMenuItem) {
            activeActions.push(new MenuItemAction(item.command, item.alt, options, menuHide, this._contextKeyService, this._commandService));
          } else {
            const groups = new MenuInfo_1(item.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._contextKeyService).createActionGroups(options);
            const submenuActions = Separator.join(...groups.map((g) => g[1]));
            if (submenuActions.length > 0) {
              activeActions.push(new SubmenuItemAction(item, menuHide, submenuActions));
            }
          }
        }
      }
      if (activeActions.length > 0) {
        result.push([id, activeActions]);
      }
    }
    return result;
  }
  static _fillInKbExprKeys(exp, set) {
    if (exp) {
      for (const key of exp.keys()) {
        set.add(key);
      }
    }
  }
  static _compareMenuItems(a, b) {
    const aGroup = a.group;
    const bGroup = b.group;
    if (aGroup !== bGroup) {
      if (!aGroup) {
        return 1;
      } else if (!bGroup) {
        return -1;
      }
      if (aGroup === "navigation") {
        return -1;
      } else if (bGroup === "navigation") {
        return 1;
      }
      const value = aGroup.localeCompare(bGroup);
      if (value !== 0) {
        return value;
      }
    }
    const aPrio = a.order || 0;
    const bPrio = b.order || 0;
    if (aPrio < bPrio) {
      return -1;
    } else if (aPrio > bPrio) {
      return 1;
    }
    return MenuInfo_1._compareTitles(isIMenuItem(a) ? a.command.title : a.title, isIMenuItem(b) ? b.command.title : b.title);
  }
  static _compareTitles(a, b) {
    const aStr = typeof a === "string" ? a : a.original;
    const bStr = typeof b === "string" ? b : b.original;
    return aStr.localeCompare(bStr);
  }
};
MenuInfo = MenuInfo_1 = __decorate20([
  __param18(3, ICommandService),
  __param18(4, IContextKeyService)
], MenuInfo);
var MenuImpl = class MenuImpl2 {
  constructor(id, hiddenStates, options, commandService, contextKeyService) {
    this._disposables = new DisposableStore();
    this._menuInfo = new MenuInfo(id, hiddenStates, options.emitEventsForSubmenuChanges, commandService, contextKeyService);
    const rebuildMenuSoon = new RunOnceScheduler(() => {
      this._menuInfo.refresh();
      this._onDidChange.fire({ menu: this, isStructuralChange: true, isEnablementChange: true, isToggleChange: true });
    }, options.eventDebounceDelay);
    this._disposables.add(rebuildMenuSoon);
    this._disposables.add(MenuRegistry.onDidChangeMenu((e) => {
      if (e.has(id)) {
        rebuildMenuSoon.schedule();
      }
    }));
    const lazyListener = this._disposables.add(new DisposableStore());
    const merge = (events) => {
      let isStructuralChange = false;
      let isEnablementChange = false;
      let isToggleChange = false;
      for (const item of events) {
        isStructuralChange = isStructuralChange || item.isStructuralChange;
        isEnablementChange = isEnablementChange || item.isEnablementChange;
        isToggleChange = isToggleChange || item.isToggleChange;
        if (isStructuralChange && isEnablementChange && isToggleChange) {
          break;
        }
      }
      return { menu: this, isStructuralChange, isEnablementChange, isToggleChange };
    };
    const startLazyListener = () => {
      lazyListener.add(contextKeyService.onDidChangeContext((e) => {
        const isStructuralChange = e.affectsSome(this._menuInfo.structureContextKeys);
        const isEnablementChange = e.affectsSome(this._menuInfo.preconditionContextKeys);
        const isToggleChange = e.affectsSome(this._menuInfo.toggledContextKeys);
        if (isStructuralChange || isEnablementChange || isToggleChange) {
          this._onDidChange.fire({ menu: this, isStructuralChange, isEnablementChange, isToggleChange });
        }
      }));
      lazyListener.add(hiddenStates.onDidChange((e) => {
        this._onDidChange.fire({ menu: this, isStructuralChange: true, isEnablementChange: false, isToggleChange: false });
      }));
    };
    this._onDidChange = new DebounceEmitter({
      // start/stop context key listener
      onWillAddFirstListener: startLazyListener,
      onDidRemoveLastListener: lazyListener.clear.bind(lazyListener),
      delay: options.eventDebounceDelay,
      merge
    });
    this.onDidChange = this._onDidChange.event;
  }
  getActions(options) {
    return this._menuInfo.createActionGroups(options);
  }
  dispose() {
    this._disposables.dispose();
    this._onDidChange.dispose();
  }
};
MenuImpl = __decorate20([
  __param18(3, ICommandService),
  __param18(4, IContextKeyService)
], MenuImpl);
function createMenuHide(menu, command, states) {
  const id = isISubmenuItem(command) ? command.submenu.id : command.id;
  const title = typeof command.title === "string" ? command.title : command.title.value;
  const hide2 = toAction({
    id: `hide/${menu.id}/${id}`,
    label: localize("hide.label", "Hide '{0}'", title),
    run() {
      states.updateHidden(menu, id, true);
    }
  });
  const toggle = toAction({
    id: `toggle/${menu.id}/${id}`,
    label: title,
    get checked() {
      return !states.isHidden(menu, id);
    },
    run() {
      states.updateHidden(menu, id, !!this.checked);
    }
  });
  return {
    hide: hide2,
    toggle,
    get isHidden() {
      return !toggle.checked;
    }
  };
}

// node_modules/monaco-editor/esm/vs/platform/clipboard/browser/clipboardService.js
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BrowserClipboardService = class BrowserClipboardService2 extends Disposable {
  constructor(layoutService, logService) {
    super();
    this.layoutService = layoutService;
    this.logService = logService;
    this.mapTextToType = /* @__PURE__ */ new Map();
    this.findText = "";
    this.resources = [];
    if (isSafari || isWebkitWebView) {
      this.installWebKitWriteTextWorkaround();
    }
  }
  // In Safari, it has the following note:
  //
  // "The request to write to the clipboard must be triggered during a user gesture.
  // A call to clipboard.write or clipboard.writeText outside the scope of a user
  // gesture(such as "click" or "touch" event handlers) will result in the immediate
  // rejection of the promise returned by the API call."
  // From: https://webkit.org/blog/10855/async-clipboard-api/
  //
  // Since extensions run in a web worker, and handle gestures in an asynchronous way,
  // they are not classified by Safari as "in response to a user gesture" and will reject.
  //
  // This function sets up some handlers to work around that behavior.
  installWebKitWriteTextWorkaround() {
    const handler = () => {
      const currentWritePromise = new DeferredPromise();
      if (this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled) {
        this.webKitPendingClipboardWritePromise.cancel();
      }
      this.webKitPendingClipboardWritePromise = currentWritePromise;
      navigator.clipboard.write([new ClipboardItem({
        "text/plain": currentWritePromise.p
      })]).catch(async (err) => {
        if (!(err instanceof Error) || err.name !== "NotAllowedError" || !currentWritePromise.isRejected) {
          this.logService.error(err);
        }
      });
    };
    this._register(Event.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container, disposables }) => {
      disposables.add(addDisposableListener(container, "click", handler));
      disposables.add(addDisposableListener(container, "keydown", handler));
    }, { container: this.layoutService.mainContainer, disposables: this._store }));
  }
  async writeText(text, type) {
    if (type) {
      this.mapTextToType.set(type, text);
      return;
    }
    if (this.webKitPendingClipboardWritePromise) {
      return this.webKitPendingClipboardWritePromise.complete(text);
    }
    try {
      return await navigator.clipboard.writeText(text);
    } catch (error) {
      console.error(error);
    }
    const activeDocument = getActiveDocument();
    const activeElement = activeDocument.activeElement;
    const textArea = activeDocument.body.appendChild($("textarea", { "aria-hidden": true }));
    textArea.style.height = "1px";
    textArea.style.width = "1px";
    textArea.style.position = "absolute";
    textArea.value = text;
    textArea.focus();
    textArea.select();
    activeDocument.execCommand("copy");
    if (activeElement instanceof HTMLElement) {
      activeElement.focus();
    }
    activeDocument.body.removeChild(textArea);
    return;
  }
  async readText(type) {
    if (type) {
      return this.mapTextToType.get(type) || "";
    }
    try {
      return await navigator.clipboard.readText();
    } catch (error) {
      console.error(error);
      return "";
    }
  }
  async readFindText() {
    return this.findText;
  }
  async writeFindText(text) {
    this.findText = text;
  }
  async writeResources(resources) {
    this.resources = resources;
  }
  async readResources() {
    return this.resources;
  }
};
BrowserClipboardService = __decorate21([
  __param19(0, ILayoutService),
  __param19(1, ILogService)
], BrowserClipboardService);

// node_modules/monaco-editor/esm/vs/platform/contextkey/browser/contextKeyService.js
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var KEYBINDING_CONTEXT_ATTR = "data-keybinding-context";
var Context = class {
  constructor(id, parent) {
    this._id = id;
    this._parent = parent;
    this._value = /* @__PURE__ */ Object.create(null);
    this._value["_contextId"] = id;
  }
  get value() {
    return { ...this._value };
  }
  setValue(key, value) {
    if (this._value[key] !== value) {
      this._value[key] = value;
      return true;
    }
    return false;
  }
  removeValue(key) {
    if (key in this._value) {
      delete this._value[key];
      return true;
    }
    return false;
  }
  getValue(key) {
    const ret = this._value[key];
    if (typeof ret === "undefined" && this._parent) {
      return this._parent.getValue(key);
    }
    return ret;
  }
};
var NullContext = class extends Context {
  constructor() {
    super(-1, null);
  }
  setValue(key, value) {
    return false;
  }
  removeValue(key) {
    return false;
  }
  getValue(key) {
    return void 0;
  }
};
NullContext.INSTANCE = new NullContext();
var ConfigAwareContextValuesContainer = class _ConfigAwareContextValuesContainer extends Context {
  constructor(id, _configurationService, emitter) {
    super(id, null);
    this._configurationService = _configurationService;
    this._values = TernarySearchTree.forConfigKeys();
    this._listener = this._configurationService.onDidChangeConfiguration((event) => {
      if (event.source === 7) {
        const allKeys = Array.from(this._values, ([k]) => k);
        this._values.clear();
        emitter.fire(new ArrayContextKeyChangeEvent(allKeys));
      } else {
        const changedKeys = [];
        for (const configKey of event.affectedKeys) {
          const contextKey = `config.${configKey}`;
          const cachedItems = this._values.findSuperstr(contextKey);
          if (cachedItems !== void 0) {
            changedKeys.push(...Iterable.map(cachedItems, ([key]) => key));
            this._values.deleteSuperstr(contextKey);
          }
          if (this._values.has(contextKey)) {
            changedKeys.push(contextKey);
            this._values.delete(contextKey);
          }
        }
        emitter.fire(new ArrayContextKeyChangeEvent(changedKeys));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(key) {
    if (key.indexOf(_ConfigAwareContextValuesContainer._keyPrefix) !== 0) {
      return super.getValue(key);
    }
    if (this._values.has(key)) {
      return this._values.get(key);
    }
    const configKey = key.substr(_ConfigAwareContextValuesContainer._keyPrefix.length);
    const configValue = this._configurationService.getValue(configKey);
    let value = void 0;
    switch (typeof configValue) {
      case "number":
      case "boolean":
      case "string":
        value = configValue;
        break;
      default:
        if (Array.isArray(configValue)) {
          value = JSON.stringify(configValue);
        } else {
          value = configValue;
        }
    }
    this._values.set(key, value);
    return value;
  }
  setValue(key, value) {
    return super.setValue(key, value);
  }
  removeValue(key) {
    return super.removeValue(key);
  }
};
ConfigAwareContextValuesContainer._keyPrefix = "config.";
var ContextKey = class {
  constructor(service, key, defaultValue) {
    this._service = service;
    this._key = key;
    this._defaultValue = defaultValue;
    this.reset();
  }
  set(value) {
    this._service.setContext(this._key, value);
  }
  reset() {
    if (typeof this._defaultValue === "undefined") {
      this._service.removeContext(this._key);
    } else {
      this._service.setContext(this._key, this._defaultValue);
    }
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
};
var SimpleContextKeyChangeEvent = class {
  constructor(key) {
    this.key = key;
  }
  affectsSome(keys) {
    return keys.has(this.key);
  }
  allKeysContainedIn(keys) {
    return this.affectsSome(keys);
  }
};
var ArrayContextKeyChangeEvent = class {
  constructor(keys) {
    this.keys = keys;
  }
  affectsSome(keys) {
    for (const key of this.keys) {
      if (keys.has(key)) {
        return true;
      }
    }
    return false;
  }
  allKeysContainedIn(keys) {
    return this.keys.every((key) => keys.has(key));
  }
};
var CompositeContextKeyChangeEvent = class {
  constructor(events) {
    this.events = events;
  }
  affectsSome(keys) {
    for (const e of this.events) {
      if (e.affectsSome(keys)) {
        return true;
      }
    }
    return false;
  }
  allKeysContainedIn(keys) {
    return this.events.every((evt) => evt.allKeysContainedIn(keys));
  }
};
function allEventKeysInContext(event, context) {
  return event.allKeysContainedIn(new Set(Object.keys(context)));
}
var AbstractContextKeyService = class extends Disposable {
  constructor(myContextId) {
    super();
    this._onDidChangeContext = this._register(new PauseableEmitter({ merge: (input) => new CompositeContextKeyChangeEvent(input) }));
    this.onDidChangeContext = this._onDidChangeContext.event;
    this._isDisposed = false;
    this._myContextId = myContextId;
  }
  createKey(key, defaultValue) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    return new ContextKey(this, key, defaultValue);
  }
  bufferChangeEvents(callback) {
    this._onDidChangeContext.pause();
    try {
      callback();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(domNode) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    return new ScopedContextKeyService(this, domNode);
  }
  contextMatchesRules(rules) {
    if (this._isDisposed) {
      throw new Error(`AbstractContextKeyService has been disposed`);
    }
    const context = this.getContextValuesContainer(this._myContextId);
    const result = rules ? rules.evaluate(context) : true;
    return result;
  }
  getContextKeyValue(key) {
    if (this._isDisposed) {
      return void 0;
    }
    return this.getContextValuesContainer(this._myContextId).getValue(key);
  }
  setContext(key, value) {
    if (this._isDisposed) {
      return;
    }
    const myContext = this.getContextValuesContainer(this._myContextId);
    if (!myContext) {
      return;
    }
    if (myContext.setValue(key, value)) {
      this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));
    }
  }
  removeContext(key) {
    if (this._isDisposed) {
      return;
    }
    if (this.getContextValuesContainer(this._myContextId).removeValue(key)) {
      this._onDidChangeContext.fire(new SimpleContextKeyChangeEvent(key));
    }
  }
  getContext(target) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this.getContextValuesContainer(findContextAttr(target));
  }
  dispose() {
    super.dispose();
    this._isDisposed = true;
  }
};
var ContextKeyService = class ContextKeyService2 extends AbstractContextKeyService {
  constructor(configurationService) {
    super(0);
    this._contexts = /* @__PURE__ */ new Map();
    this._lastContextId = 0;
    const myContext = this._register(new ConfigAwareContextValuesContainer(this._myContextId, configurationService, this._onDidChangeContext));
    this._contexts.set(this._myContextId, myContext);
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._contexts.get(contextId) || NullContext.INSTANCE;
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ContextKeyService has been disposed`);
    }
    const id = ++this._lastContextId;
    this._contexts.set(id, new Context(id, this.getContextValuesContainer(parentContextId)));
    return id;
  }
  disposeContext(contextId) {
    if (!this._isDisposed) {
      this._contexts.delete(contextId);
    }
  }
};
ContextKeyService = __decorate22([
  __param20(0, IConfigurationService)
], ContextKeyService);
var ScopedContextKeyService = class extends AbstractContextKeyService {
  constructor(parent, domNode) {
    super(parent.createChildContext());
    this._parentChangeListener = this._register(new MutableDisposable());
    this._parent = parent;
    this._updateParentChangeListener();
    this._domNode = domNode;
    if (this._domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
      let extraInfo = "";
      if (this._domNode.classList) {
        extraInfo = Array.from(this._domNode.classList.values()).join(", ");
      }
      console.error(`Element already has context attribute${extraInfo ? ": " + extraInfo : ""}`);
    }
    this._domNode.setAttribute(KEYBINDING_CONTEXT_ATTR, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext((e) => {
      const thisContainer = this._parent.getContextValuesContainer(this._myContextId);
      const thisContextValues = thisContainer.value;
      if (!allEventKeysInContext(e, thisContextValues)) {
        this._onDidChangeContext.fire(e);
      }
    });
  }
  dispose() {
    if (this._isDisposed) {
      return;
    }
    this._parent.disposeContext(this._myContextId);
    this._domNode.removeAttribute(KEYBINDING_CONTEXT_ATTR);
    super.dispose();
  }
  getContextValuesContainer(contextId) {
    if (this._isDisposed) {
      return NullContext.INSTANCE;
    }
    return this._parent.getContextValuesContainer(contextId);
  }
  createChildContext(parentContextId = this._myContextId) {
    if (this._isDisposed) {
      throw new Error(`ScopedContextKeyService has been disposed`);
    }
    return this._parent.createChildContext(parentContextId);
  }
  disposeContext(contextId) {
    if (this._isDisposed) {
      return;
    }
    this._parent.disposeContext(contextId);
  }
};
function findContextAttr(domNode) {
  while (domNode) {
    if (domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
      const attr = domNode.getAttribute(KEYBINDING_CONTEXT_ATTR);
      if (attr) {
        return parseInt(attr, 10);
      }
      return NaN;
    }
    domNode = domNode.parentElement;
  }
  return 0;
}
function setContext(accessor, contextKey, contextValue) {
  const contextKeyService = accessor.get(IContextKeyService);
  contextKeyService.createKey(String(contextKey), stringifyURIs(contextValue));
}
function stringifyURIs(contextValue) {
  return cloneAndChange(contextValue, (obj) => {
    if (typeof obj === "object" && obj.$mid === 1) {
      return URI.revive(obj).toString();
    }
    if (obj instanceof URI) {
      return obj.toString();
    }
    return void 0;
  });
}
CommandsRegistry.registerCommand("_setContext", setContext);
CommandsRegistry.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...RawContextKey.all()].sort((a, b) => a.key.localeCompare(b.key));
  },
  metadata: {
    description: localize("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
CommandsRegistry.registerCommand("_generateContextKeyInfo", function() {
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const info of RawContextKey.all()) {
    if (!seen.has(info.key)) {
      seen.add(info.key);
      result.push(info);
    }
  }
  result.sort((a, b) => a.key.localeCompare(b.key));
  console.log(JSON.stringify(result, void 0, 2));
});

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/graph.js
var Node = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
    this.incoming = /* @__PURE__ */ new Map();
    this.outgoing = /* @__PURE__ */ new Map();
  }
};
var Graph = class {
  constructor(_hashFn) {
    this._hashFn = _hashFn;
    this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const ret = [];
    for (const node of this._nodes.values()) {
      if (node.outgoing.size === 0) {
        ret.push(node);
      }
    }
    return ret;
  }
  insertEdge(from, to) {
    const fromNode = this.lookupOrInsertNode(from);
    const toNode = this.lookupOrInsertNode(to);
    fromNode.outgoing.set(toNode.key, toNode);
    toNode.incoming.set(fromNode.key, fromNode);
  }
  removeNode(data) {
    const key = this._hashFn(data);
    this._nodes.delete(key);
    for (const node of this._nodes.values()) {
      node.outgoing.delete(key);
      node.incoming.delete(key);
    }
  }
  lookupOrInsertNode(data) {
    const key = this._hashFn(data);
    let node = this._nodes.get(key);
    if (!node) {
      node = new Node(key, data);
      this._nodes.set(key, node);
    }
    return node;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const data = [];
    for (const [key, value] of this._nodes) {
      data.push(`${key}
	(-> incoming)[${[...value.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...value.outgoing.keys()].join(",")}]
`);
    }
    return data.join("\n");
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (const [id, node] of this._nodes) {
      const seen = /* @__PURE__ */ new Set([id]);
      const res = this._findCycle(node, seen);
      if (res) {
        return res;
      }
    }
    return void 0;
  }
  _findCycle(node, seen) {
    for (const [id, outgoing] of node.outgoing) {
      if (seen.has(id)) {
        return [...seen, id].join(" -> ");
      }
      seen.add(id);
      const value = this._findCycle(outgoing, seen);
      if (value) {
        return value;
      }
      seen.delete(id);
    }
    return void 0;
  }
};

// node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js
var _enableAllTracing = false;
var CyclicDependencyError = class extends Error {
  constructor(graph) {
    var _a;
    super("cyclic dependency between services");
    this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: 
${graph.toString()}`;
  }
};
var InstantiationService = class _InstantiationService {
  constructor(_services = new ServiceCollection(), _strict = false, _parent, _enableTracing = _enableAllTracing) {
    var _a;
    this._services = _services;
    this._strict = _strict;
    this._parent = _parent;
    this._enableTracing = _enableTracing;
    this._activeInstantiations = /* @__PURE__ */ new Set();
    this._services.set(IInstantiationService, this);
    this._globalGraph = _enableTracing ? (_a = _parent === null || _parent === void 0 ? void 0 : _parent._globalGraph) !== null && _a !== void 0 ? _a : new Graph((e) => e) : void 0;
  }
  createChild(services) {
    return new _InstantiationService(services, this._strict, this, this._enableTracing);
  }
  invokeFunction(fn, ...args) {
    const _trace = Trace.traceInvocation(this._enableTracing, fn);
    let _done = false;
    try {
      const accessor = {
        get: (id) => {
          if (_done) {
            throw illegalState("service accessor is only valid during the invocation of its target method");
          }
          const result = this._getOrCreateServiceInstance(id, _trace);
          if (!result) {
            throw new Error(`[invokeFunction] unknown service '${id}'`);
          }
          return result;
        }
      };
      return fn(accessor, ...args);
    } finally {
      _done = true;
      _trace.stop();
    }
  }
  createInstance(ctorOrDescriptor, ...rest) {
    let _trace;
    let result;
    if (ctorOrDescriptor instanceof SyncDescriptor) {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);
      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);
    } else {
      _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);
      result = this._createInstance(ctorOrDescriptor, rest, _trace);
    }
    _trace.stop();
    return result;
  }
  _createInstance(ctor, args = [], _trace) {
    const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);
    const serviceArgs = [];
    for (const dependency of serviceDependencies) {
      const service = this._getOrCreateServiceInstance(dependency.id, _trace);
      if (!service) {
        this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);
      }
      serviceArgs.push(service);
    }
    const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;
    if (args.length !== firstServiceArgPos) {
      console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);
      const delta = firstServiceArgPos - args.length;
      if (delta > 0) {
        args = args.concat(new Array(delta));
      } else {
        args = args.slice(0, firstServiceArgPos);
      }
    }
    return Reflect.construct(ctor, args.concat(serviceArgs));
  }
  _setServiceInstance(id, instance) {
    if (this._services.get(id) instanceof SyncDescriptor) {
      this._services.set(id, instance);
    } else if (this._parent) {
      this._parent._setServiceInstance(id, instance);
    } else {
      throw new Error("illegalState - setting UNKNOWN service instance");
    }
  }
  _getServiceInstanceOrDescriptor(id) {
    const instanceOrDesc = this._services.get(id);
    if (!instanceOrDesc && this._parent) {
      return this._parent._getServiceInstanceOrDescriptor(id);
    } else {
      return instanceOrDesc;
    }
  }
  _getOrCreateServiceInstance(id, _trace) {
    if (this._globalGraph && this._globalGraphImplicitDependency) {
      this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));
    }
    const thing = this._getServiceInstanceOrDescriptor(id);
    if (thing instanceof SyncDescriptor) {
      return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));
    } else {
      _trace.branch(id, false);
      return thing;
    }
  }
  _safeCreateAndCacheServiceInstance(id, desc, _trace) {
    if (this._activeInstantiations.has(id)) {
      throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);
    }
    this._activeInstantiations.add(id);
    try {
      return this._createAndCacheServiceInstance(id, desc, _trace);
    } finally {
      this._activeInstantiations.delete(id);
    }
  }
  _createAndCacheServiceInstance(id, desc, _trace) {
    var _a;
    const graph = new Graph((data) => data.id.toString());
    let cycleCount = 0;
    const stack = [{ id, desc, _trace }];
    while (stack.length) {
      const item = stack.pop();
      graph.lookupOrInsertNode(item);
      if (cycleCount++ > 1e3) {
        throw new CyclicDependencyError(graph);
      }
      for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);
        if (!instanceOrDesc) {
          this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);
        }
        (_a = this._globalGraph) === null || _a === void 0 ? void 0 : _a.insertEdge(String(item.id), String(dependency.id));
        if (instanceOrDesc instanceof SyncDescriptor) {
          const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };
          graph.insertEdge(item, d);
          stack.push(d);
        }
      }
    }
    while (true) {
      const roots = graph.roots();
      if (roots.length === 0) {
        if (!graph.isEmpty()) {
          throw new CyclicDependencyError(graph);
        }
        break;
      }
      for (const { data } of roots) {
        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);
        if (instanceOrDesc instanceof SyncDescriptor) {
          const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);
          this._setServiceInstance(data.id, instance);
        }
        graph.removeNode(data);
      }
    }
    return this._getServiceInstanceOrDescriptor(id);
  }
  _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {
    if (this._services.get(id) instanceof SyncDescriptor) {
      return this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace);
    } else if (this._parent) {
      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);
    } else {
      throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);
    }
  }
  _createServiceInstance(id, ctor, args = [], supportsDelayedInstantiation, _trace) {
    if (!supportsDelayedInstantiation) {
      return this._createInstance(ctor, args, _trace);
    } else {
      const child = new _InstantiationService(void 0, this._strict, this, this._enableTracing);
      child._globalGraphImplicitDependency = String(id);
      const earlyListeners = /* @__PURE__ */ new Map();
      const idle = new GlobalIdleValue(() => {
        const result = child._createInstance(ctor, args, _trace);
        for (const [key, values] of earlyListeners) {
          const candidate = result[key];
          if (typeof candidate === "function") {
            for (const listener of values) {
              candidate.apply(result, listener);
            }
          }
        }
        earlyListeners.clear();
        return result;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(target, key) {
          if (!idle.isInitialized) {
            if (typeof key === "string" && (key.startsWith("onDid") || key.startsWith("onWill"))) {
              let list = earlyListeners.get(key);
              if (!list) {
                list = new LinkedList();
                earlyListeners.set(key, list);
              }
              const event = (callback, thisArg, disposables) => {
                const rm = list.push([callback, thisArg, disposables]);
                return toDisposable(rm);
              };
              return event;
            }
          }
          if (key in target) {
            return target[key];
          }
          const obj = idle.value;
          let prop = obj[key];
          if (typeof prop !== "function") {
            return prop;
          }
          prop = prop.bind(obj);
          target[key] = prop;
          return prop;
        },
        set(_target, p, value) {
          idle.value[p] = value;
          return true;
        },
        getPrototypeOf(_target) {
          return ctor.prototype;
        }
      });
    }
  }
  _throwIfStrict(msg, printWarning) {
    if (printWarning) {
      console.warn(msg);
    }
    if (this._strict) {
      throw new Error(msg);
    }
  }
};
var Trace = class _Trace {
  static traceInvocation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(2, ctor.name || new Error().stack.split("\n").slice(3, 4).join("\n"));
  }
  static traceCreation(_enableTracing, ctor) {
    return !_enableTracing ? _Trace._None : new _Trace(1, ctor.name);
  }
  constructor(type, name) {
    this.type = type;
    this.name = name;
    this._start = Date.now();
    this._dep = [];
  }
  branch(id, first) {
    const child = new _Trace(3, id.toString());
    this._dep.push([id, first, child]);
    return child;
  }
  stop() {
    const dur = Date.now() - this._start;
    _Trace._totals += dur;
    let causedCreation = false;
    function printChild(n, trace) {
      const res = [];
      const prefix = new Array(n + 1).join("	");
      for (const [id, first, child] of trace._dep) {
        if (first && child) {
          causedCreation = true;
          res.push(`${prefix}CREATES -> ${id}`);
          const nested = printChild(n + 1, child);
          if (nested) {
            res.push(nested);
          }
        } else {
          res.push(`${prefix}uses -> ${id}`);
        }
      }
      return res.join("\n");
    }
    const lines = [
      `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
      `${printChild(1, this)}`,
      `DONE, took ${dur.toFixed(2)}ms (grand total ${_Trace._totals.toFixed(2)}ms)`
    ];
    if (dur > 2 || causedCreation) {
      _Trace.all.add(lines.join("\n"));
    }
  }
};
Trace.all = /* @__PURE__ */ new Set();
Trace._None = new class extends Trace {
  constructor() {
    super(0, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}();
Trace._totals = 0;

// node_modules/monaco-editor/esm/vs/platform/markers/common/markerService.js
var unsupportedSchemas = /* @__PURE__ */ new Set([Schemas.inMemory, Schemas.vscodeSourceControl, Schemas.walkThrough, Schemas.walkThroughSnippet]);
var DoubleResourceMap = class {
  constructor() {
    this._byResource = new ResourceMap();
    this._byOwner = /* @__PURE__ */ new Map();
  }
  set(resource, owner, value) {
    let ownerMap = this._byResource.get(resource);
    if (!ownerMap) {
      ownerMap = /* @__PURE__ */ new Map();
      this._byResource.set(resource, ownerMap);
    }
    ownerMap.set(owner, value);
    let resourceMap = this._byOwner.get(owner);
    if (!resourceMap) {
      resourceMap = new ResourceMap();
      this._byOwner.set(owner, resourceMap);
    }
    resourceMap.set(resource, value);
  }
  get(resource, owner) {
    const ownerMap = this._byResource.get(resource);
    return ownerMap === null || ownerMap === void 0 ? void 0 : ownerMap.get(owner);
  }
  delete(resource, owner) {
    let removedA = false;
    let removedB = false;
    const ownerMap = this._byResource.get(resource);
    if (ownerMap) {
      removedA = ownerMap.delete(owner);
    }
    const resourceMap = this._byOwner.get(owner);
    if (resourceMap) {
      removedB = resourceMap.delete(resource);
    }
    if (removedA !== removedB) {
      throw new Error("illegal state");
    }
    return removedA && removedB;
  }
  values(key) {
    var _a, _b, _c, _d;
    if (typeof key === "string") {
      return (_b = (_a = this._byOwner.get(key)) === null || _a === void 0 ? void 0 : _a.values()) !== null && _b !== void 0 ? _b : Iterable.empty();
    }
    if (URI.isUri(key)) {
      return (_d = (_c = this._byResource.get(key)) === null || _c === void 0 ? void 0 : _c.values()) !== null && _d !== void 0 ? _d : Iterable.empty();
    }
    return Iterable.map(Iterable.concat(...this._byOwner.values()), (map) => map[1]);
  }
};
var MarkerStats = class {
  constructor(service) {
    this.errors = 0;
    this.infos = 0;
    this.warnings = 0;
    this.unknowns = 0;
    this._data = new ResourceMap();
    this._service = service;
    this._subscription = service.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(resources) {
    for (const resource of resources) {
      const oldStats = this._data.get(resource);
      if (oldStats) {
        this._substract(oldStats);
      }
      const newStats = this._resourceStats(resource);
      this._add(newStats);
      this._data.set(resource, newStats);
    }
  }
  _resourceStats(resource) {
    const result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (unsupportedSchemas.has(resource.scheme)) {
      return result;
    }
    for (const { severity } of this._service.read({ resource })) {
      if (severity === MarkerSeverity.Error) {
        result.errors += 1;
      } else if (severity === MarkerSeverity.Warning) {
        result.warnings += 1;
      } else if (severity === MarkerSeverity.Info) {
        result.infos += 1;
      } else {
        result.unknowns += 1;
      }
    }
    return result;
  }
  _substract(op) {
    this.errors -= op.errors;
    this.warnings -= op.warnings;
    this.infos -= op.infos;
    this.unknowns -= op.unknowns;
  }
  _add(op) {
    this.errors += op.errors;
    this.warnings += op.warnings;
    this.infos += op.infos;
    this.unknowns += op.unknowns;
  }
};
var MarkerService = class _MarkerService {
  constructor() {
    this._onMarkerChanged = new DebounceEmitter({
      delay: 0,
      merge: _MarkerService._merge
    });
    this.onMarkerChanged = this._onMarkerChanged.event;
    this._data = new DoubleResourceMap();
    this._stats = new MarkerStats(this);
  }
  dispose() {
    this._stats.dispose();
    this._onMarkerChanged.dispose();
  }
  remove(owner, resources) {
    for (const resource of resources || []) {
      this.changeOne(owner, resource, []);
    }
  }
  changeOne(owner, resource, markerData) {
    if (isFalsyOrEmpty(markerData)) {
      const removed = this._data.delete(resource, owner);
      if (removed) {
        this._onMarkerChanged.fire([resource]);
      }
    } else {
      const markers = [];
      for (const data of markerData) {
        const marker = _MarkerService._toMarker(owner, resource, data);
        if (marker) {
          markers.push(marker);
        }
      }
      this._data.set(resource, owner, markers);
      this._onMarkerChanged.fire([resource]);
    }
  }
  static _toMarker(owner, resource, data) {
    let { code, severity, message, source, startLineNumber, startColumn, endLineNumber, endColumn, relatedInformation, tags } = data;
    if (!message) {
      return void 0;
    }
    startLineNumber = startLineNumber > 0 ? startLineNumber : 1;
    startColumn = startColumn > 0 ? startColumn : 1;
    endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;
    endColumn = endColumn > 0 ? endColumn : startColumn;
    return {
      resource,
      owner,
      code,
      severity,
      message,
      source,
      startLineNumber,
      startColumn,
      endLineNumber,
      endColumn,
      relatedInformation,
      tags
    };
  }
  changeAll(owner, data) {
    const changes = [];
    const existing = this._data.values(owner);
    if (existing) {
      for (const data2 of existing) {
        const first = Iterable.first(data2);
        if (first) {
          changes.push(first.resource);
          this._data.delete(first.resource, owner);
        }
      }
    }
    if (isNonEmptyArray(data)) {
      const groups = new ResourceMap();
      for (const { resource, marker: markerData } of data) {
        const marker = _MarkerService._toMarker(owner, resource, markerData);
        if (!marker) {
          continue;
        }
        const array = groups.get(resource);
        if (!array) {
          groups.set(resource, [marker]);
          changes.push(resource);
        } else {
          array.push(marker);
        }
      }
      for (const [resource, value] of groups) {
        this._data.set(resource, owner, value);
      }
    }
    if (changes.length > 0) {
      this._onMarkerChanged.fire(changes);
    }
  }
  read(filter = /* @__PURE__ */ Object.create(null)) {
    let { owner, resource, severities, take } = filter;
    if (!take || take < 0) {
      take = -1;
    }
    if (owner && resource) {
      const data = this._data.get(resource, owner);
      if (!data) {
        return [];
      } else {
        const result = [];
        for (const marker of data) {
          if (_MarkerService._accept(marker, severities)) {
            const newLen = result.push(marker);
            if (take > 0 && newLen === take) {
              break;
            }
          }
        }
        return result;
      }
    } else if (!owner && !resource) {
      const result = [];
      for (const markers of this._data.values()) {
        for (const data of markers) {
          if (_MarkerService._accept(data, severities)) {
            const newLen = result.push(data);
            if (take > 0 && newLen === take) {
              return result;
            }
          }
        }
      }
      return result;
    } else {
      const iterable = this._data.values(resource !== null && resource !== void 0 ? resource : owner);
      const result = [];
      for (const markers of iterable) {
        for (const data of markers) {
          if (_MarkerService._accept(data, severities)) {
            const newLen = result.push(data);
            if (take > 0 && newLen === take) {
              return result;
            }
          }
        }
      }
      return result;
    }
  }
  static _accept(marker, severities) {
    return severities === void 0 || (severities & marker.severity) === marker.severity;
  }
  // --- event debounce logic
  static _merge(all) {
    const set = new ResourceMap();
    for (const array of all) {
      for (const item of array) {
        set.set(item, true);
      }
    }
    return Array.from(set.keys());
  }
};

// node_modules/monaco-editor/esm/vs/platform/configuration/common/configurations.js
var DefaultConfiguration = class extends Disposable {
  constructor() {
    super(...arguments);
    this._configurationModel = new ConfigurationModel();
  }
  get configurationModel() {
    return this._configurationModel;
  }
  reload() {
    this.resetConfigurationModel();
    return this.configurationModel;
  }
  getConfigurationDefaultOverrides() {
    return {};
  }
  resetConfigurationModel() {
    this._configurationModel = new ConfigurationModel();
    const properties = Registry.as(Extensions.Configuration).getConfigurationProperties();
    this.updateConfigurationModel(Object.keys(properties), properties);
  }
  updateConfigurationModel(properties, configurationProperties) {
    const configurationDefaultsOverrides = this.getConfigurationDefaultOverrides();
    for (const key of properties) {
      const defaultOverrideValue = configurationDefaultsOverrides[key];
      const propertySchema = configurationProperties[key];
      if (defaultOverrideValue !== void 0) {
        this._configurationModel.addValue(key, defaultOverrideValue);
      } else if (propertySchema) {
        this._configurationModel.addValue(key, propertySchema.default);
      } else {
        this._configurationModel.removeValue(key);
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/log/common/logService.js
var LogService = class extends Disposable {
  constructor(primaryLogger, otherLoggers = []) {
    super();
    this.logger = new MultiplexLogger([primaryLogger, ...otherLoggers]);
    this._register(primaryLogger.onDidChangeLogLevel((level) => this.setLevel(level)));
  }
  get onDidChangeLogLevel() {
    return this.logger.onDidChangeLogLevel;
  }
  setLevel(level) {
    this.logger.setLevel(level);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(message, ...args) {
    this.logger.trace(message, ...args);
  }
  debug(message, ...args) {
    this.logger.debug(message, ...args);
  }
  info(message, ...args) {
    this.logger.info(message, ...args);
  }
  warn(message, ...args) {
    this.logger.warn(message, ...args);
  }
  error(message, ...args) {
    this.logger.error(message, ...args);
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js
var editorFeatures = [];
function getEditorFeatures() {
  return editorFeatures.slice(0);
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SimpleModel = class {
  constructor(model) {
    this.disposed = false;
    this.model = model;
    this._onWillDispose = new Emitter();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = true;
    this._onWillDispose.fire();
  }
};
var StandaloneTextModelService = class StandaloneTextModelService2 {
  constructor(modelService) {
    this.modelService = modelService;
  }
  createModelReference(resource) {
    const model = this.modelService.getModel(resource);
    if (!model) {
      return Promise.reject(new Error(`Model not found`));
    }
    return Promise.resolve(new ImmortalReference(new SimpleModel(model)));
  }
};
StandaloneTextModelService = __decorate23([
  __param21(0, IModelService)
], StandaloneTextModelService);
var StandaloneEditorProgressService = class _StandaloneEditorProgressService {
  show() {
    return _StandaloneEditorProgressService.NULL_PROGRESS_RUNNER;
  }
  async showWhile(promise, delay) {
    await promise;
  }
};
StandaloneEditorProgressService.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
var StandaloneProgressService = class {
  withProgress(_options, task, onDidCancel) {
    return task({
      report: () => {
      }
    });
  }
};
var StandaloneEnvironmentService = class {
  constructor() {
    this.isExtensionDevelopment = false;
    this.isBuilt = false;
  }
};
var StandaloneDialogService = class {
  async confirm(confirmation) {
    const confirmed = this.doConfirm(confirmation.message, confirmation.detail);
    return {
      confirmed,
      checkboxChecked: false
      // unsupported
    };
  }
  doConfirm(message, detail) {
    let messageText = message;
    if (detail) {
      messageText = messageText + "\n\n" + detail;
    }
    return mainWindow.confirm(messageText);
  }
  async prompt(prompt) {
    var _a, _b;
    let result = void 0;
    const confirmed = this.doConfirm(prompt.message, prompt.detail);
    if (confirmed) {
      const promptButtons = [...(_a = prompt.buttons) !== null && _a !== void 0 ? _a : []];
      if (prompt.cancelButton && typeof prompt.cancelButton !== "string" && typeof prompt.cancelButton !== "boolean") {
        promptButtons.push(prompt.cancelButton);
      }
      result = await ((_b = promptButtons[0]) === null || _b === void 0 ? void 0 : _b.run({ checkboxChecked: false }));
    }
    return { result };
  }
  async error(message, detail) {
    await this.prompt({ type: severity_default.Error, message, detail });
  }
};
var StandaloneNotificationService = class _StandaloneNotificationService {
  info(message) {
    return this.notify({ severity: severity_default.Info, message });
  }
  warn(message) {
    return this.notify({ severity: severity_default.Warning, message });
  }
  error(error) {
    return this.notify({ severity: severity_default.Error, message: error });
  }
  notify(notification) {
    switch (notification.severity) {
      case severity_default.Error:
        console.error(notification.message);
        break;
      case severity_default.Warning:
        console.warn(notification.message);
        break;
      default:
        console.log(notification.message);
        break;
    }
    return _StandaloneNotificationService.NO_OP;
  }
  prompt(severity, message, choices, options) {
    return _StandaloneNotificationService.NO_OP;
  }
  status(message, options) {
    return Disposable.None;
  }
};
StandaloneNotificationService.NO_OP = new NoOpNotification();
var StandaloneCommandService = class StandaloneCommandService2 {
  constructor(instantiationService) {
    this._onWillExecuteCommand = new Emitter();
    this._onDidExecuteCommand = new Emitter();
    this.onDidExecuteCommand = this._onDidExecuteCommand.event;
    this._instantiationService = instantiationService;
  }
  executeCommand(id, ...args) {
    const command = CommandsRegistry.getCommand(id);
    if (!command) {
      return Promise.reject(new Error(`command '${id}' not found`));
    }
    try {
      this._onWillExecuteCommand.fire({ commandId: id, args });
      const result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler, ...args]);
      this._onDidExecuteCommand.fire({ commandId: id, args });
      return Promise.resolve(result);
    } catch (err) {
      return Promise.reject(err);
    }
  }
};
StandaloneCommandService = __decorate23([
  __param21(0, IInstantiationService)
], StandaloneCommandService);
var StandaloneKeybindingService = class StandaloneKeybindingService2 extends AbstractKeybindingService {
  constructor(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {
    super(contextKeyService, commandService, telemetryService, notificationService, logService);
    this._cachedResolver = null;
    this._dynamicKeybindings = [];
    this._domNodeListeners = [];
    const addContainer = (domNode) => {
      const disposables = new DisposableStore();
      disposables.add(addDisposableListener(domNode, EventType.KEY_DOWN, (e) => {
        const keyEvent = new StandardKeyboardEvent(e);
        const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);
        if (shouldPreventDefault) {
          keyEvent.preventDefault();
          keyEvent.stopPropagation();
        }
      }));
      disposables.add(addDisposableListener(domNode, EventType.KEY_UP, (e) => {
        const keyEvent = new StandardKeyboardEvent(e);
        const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);
        if (shouldPreventDefault) {
          keyEvent.preventDefault();
        }
      }));
      this._domNodeListeners.push(new DomNodeListeners(domNode, disposables));
    };
    const removeContainer = (domNode) => {
      for (let i = 0; i < this._domNodeListeners.length; i++) {
        const domNodeListeners = this._domNodeListeners[i];
        if (domNodeListeners.domNode === domNode) {
          this._domNodeListeners.splice(i, 1);
          domNodeListeners.dispose();
        }
      }
    };
    const addCodeEditor = (codeEditor) => {
      if (codeEditor.getOption(
        61
        /* EditorOption.inDiffEditor */
      )) {
        return;
      }
      addContainer(codeEditor.getContainerDomNode());
    };
    const removeCodeEditor = (codeEditor) => {
      if (codeEditor.getOption(
        61
        /* EditorOption.inDiffEditor */
      )) {
        return;
      }
      removeContainer(codeEditor.getContainerDomNode());
    };
    this._register(codeEditorService.onCodeEditorAdd(addCodeEditor));
    this._register(codeEditorService.onCodeEditorRemove(removeCodeEditor));
    codeEditorService.listCodeEditors().forEach(addCodeEditor);
    const addDiffEditor = (diffEditor) => {
      addContainer(diffEditor.getContainerDomNode());
    };
    const removeDiffEditor = (diffEditor) => {
      removeContainer(diffEditor.getContainerDomNode());
    };
    this._register(codeEditorService.onDiffEditorAdd(addDiffEditor));
    this._register(codeEditorService.onDiffEditorRemove(removeDiffEditor));
    codeEditorService.listDiffEditors().forEach(addDiffEditor);
  }
  addDynamicKeybinding(command, keybinding, handler, when) {
    return combinedDisposable(CommandsRegistry.registerCommand(command, handler), this.addDynamicKeybindings([{
      keybinding,
      command,
      when
    }]));
  }
  addDynamicKeybindings(rules) {
    const entries = rules.map((rule) => {
      var _a;
      const keybinding = decodeKeybinding(rule.keybinding, OS);
      return {
        keybinding,
        command: (_a = rule.command) !== null && _a !== void 0 ? _a : null,
        commandArgs: rule.commandArgs,
        when: rule.when,
        weight1: 1e3,
        weight2: 0,
        extensionId: null,
        isBuiltinExtension: false
      };
    });
    this._dynamicKeybindings = this._dynamicKeybindings.concat(entries);
    this.updateResolver();
    return toDisposable(() => {
      for (let i = 0; i < this._dynamicKeybindings.length; i++) {
        if (this._dynamicKeybindings[i] === entries[0]) {
          this._dynamicKeybindings.splice(i, entries.length);
          this.updateResolver();
          return;
        }
      }
    });
  }
  updateResolver() {
    this._cachedResolver = null;
    this._onDidUpdateKeybindings.fire();
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const defaults = this._toNormalizedKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
      const overrides = this._toNormalizedKeybindingItems(this._dynamicKeybindings, false);
      this._cachedResolver = new KeybindingResolver(defaults, overrides, (str) => this._log(str));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return mainWindow.document.hasFocus();
  }
  _toNormalizedKeybindingItems(items, isDefault) {
    const result = [];
    let resultLen = 0;
    for (const item of items) {
      const when = item.when || void 0;
      const keybinding = item.keybinding;
      if (!keybinding) {
        result[resultLen++] = new ResolvedKeybindingItem(void 0, item.command, item.commandArgs, when, isDefault, null, false);
      } else {
        const resolvedKeybindings = USLayoutResolvedKeybinding.resolveKeybinding(keybinding, OS);
        for (const resolvedKeybinding of resolvedKeybindings) {
          result[resultLen++] = new ResolvedKeybindingItem(resolvedKeybinding, item.command, item.commandArgs, when, isDefault, null, false);
        }
      }
    }
    return result;
  }
  resolveKeyboardEvent(keyboardEvent) {
    const chord = new KeyCodeChord(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode);
    return new USLayoutResolvedKeybinding([chord], OS);
  }
};
StandaloneKeybindingService = __decorate23([
  __param21(0, IContextKeyService),
  __param21(1, ICommandService),
  __param21(2, ITelemetryService),
  __param21(3, INotificationService),
  __param21(4, ILogService),
  __param21(5, ICodeEditorService)
], StandaloneKeybindingService);
var DomNodeListeners = class extends Disposable {
  constructor(domNode, disposables) {
    super();
    this.domNode = domNode;
    this._register(disposables);
  }
};
function isConfigurationOverrides(thing) {
  return thing && typeof thing === "object" && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === "string") && (!thing.resource || thing.resource instanceof URI);
}
var StandaloneConfigurationService = class {
  constructor() {
    this._onDidChangeConfiguration = new Emitter();
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    const defaultConfiguration = new DefaultConfiguration();
    this._configuration = new Configuration(defaultConfiguration.reload(), new ConfigurationModel(), new ConfigurationModel(), new ConfigurationModel());
    defaultConfiguration.dispose();
  }
  getValue(arg1, arg2) {
    const section = typeof arg1 === "string" ? arg1 : void 0;
    const overrides = isConfigurationOverrides(arg1) ? arg1 : isConfigurationOverrides(arg2) ? arg2 : {};
    return this._configuration.getValue(section, overrides, void 0);
  }
  updateValues(values) {
    const previous = { data: this._configuration.toData() };
    const changedKeys = [];
    for (const entry of values) {
      const [key, value] = entry;
      if (this.getValue(key) === value) {
        continue;
      }
      this._configuration.updateValue(key, value);
      changedKeys.push(key);
    }
    if (changedKeys.length > 0) {
      const configurationChangeEvent = new ConfigurationChangeEvent({ keys: changedKeys, overrides: [] }, previous, this._configuration);
      configurationChangeEvent.source = 8;
      configurationChangeEvent.sourceConfig = null;
      this._onDidChangeConfiguration.fire(configurationChangeEvent);
    }
    return Promise.resolve();
  }
  updateValue(key, value, arg3, arg4) {
    return this.updateValues([[key, value]]);
  }
  inspect(key, options = {}) {
    return this._configuration.inspect(key, options, void 0);
  }
};
var StandaloneResourceConfigurationService = class StandaloneResourceConfigurationService2 {
  constructor(configurationService, modelService, languageService) {
    this.configurationService = configurationService;
    this.modelService = modelService;
    this.languageService = languageService;
    this._onDidChangeConfiguration = new Emitter();
    this.configurationService.onDidChangeConfiguration((e) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: e.affectedKeys, affectsConfiguration: (resource, configuration) => e.affectsConfiguration(configuration) });
    });
  }
  getValue(resource, arg2, arg3) {
    const position = Position.isIPosition(arg2) ? arg2 : null;
    const section = position ? typeof arg3 === "string" ? arg3 : void 0 : typeof arg2 === "string" ? arg2 : void 0;
    const language = resource ? this.getLanguage(resource, position) : void 0;
    if (typeof section === "undefined") {
      return this.configurationService.getValue({
        resource,
        overrideIdentifier: language
      });
    }
    return this.configurationService.getValue(section, {
      resource,
      overrideIdentifier: language
    });
  }
  getLanguage(resource, position) {
    const model = this.modelService.getModel(resource);
    if (model) {
      return position ? model.getLanguageIdAtPosition(position.lineNumber, position.column) : model.getLanguageId();
    }
    return this.languageService.guessLanguageIdByFilepathOrFirstLine(resource);
  }
};
StandaloneResourceConfigurationService = __decorate23([
  __param21(0, IConfigurationService),
  __param21(1, IModelService),
  __param21(2, ILanguageService)
], StandaloneResourceConfigurationService);
var StandaloneResourcePropertiesService = class StandaloneResourcePropertiesService2 {
  constructor(configurationService) {
    this.configurationService = configurationService;
  }
  getEOL(resource, language) {
    const eol = this.configurationService.getValue("files.eol", { overrideIdentifier: language, resource });
    if (eol && typeof eol === "string" && eol !== "auto") {
      return eol;
    }
    return isLinux || isMacintosh ? "\n" : "\r\n";
  }
};
StandaloneResourcePropertiesService = __decorate23([
  __param21(0, IConfigurationService)
], StandaloneResourcePropertiesService);
var StandaloneTelemetryService = class {
  publicLog2() {
  }
};
var StandaloneWorkspaceContextService = class _StandaloneWorkspaceContextService {
  constructor() {
    const resource = URI.from({ scheme: _StandaloneWorkspaceContextService.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: STANDALONE_EDITOR_WORKSPACE_ID, folders: [new WorkspaceFolder({ uri: resource, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkspaceFolder(resource) {
    return resource && resource.scheme === _StandaloneWorkspaceContextService.SCHEME ? this.workspace.folders[0] : null;
  }
};
StandaloneWorkspaceContextService.SCHEME = "inmemory";
function updateConfigurationService(configurationService, source, isDiffEditor) {
  if (!source) {
    return;
  }
  if (!(configurationService instanceof StandaloneConfigurationService)) {
    return;
  }
  const toUpdate = [];
  Object.keys(source).forEach((key) => {
    if (isEditorConfigurationKey(key)) {
      toUpdate.push([`editor.${key}`, source[key]]);
    }
    if (isDiffEditor && isDiffEditorConfigurationKey(key)) {
      toUpdate.push([`diffEditor.${key}`, source[key]]);
    }
  });
  if (toUpdate.length > 0) {
    configurationService.updateValues(toUpdate);
  }
}
var StandaloneBulkEditService = class StandaloneBulkEditService2 {
  constructor(_modelService) {
    this._modelService = _modelService;
  }
  hasPreviewHandler() {
    return false;
  }
  async apply(editsIn, _options) {
    const edits = Array.isArray(editsIn) ? editsIn : ResourceEdit.convert(editsIn);
    const textEdits = /* @__PURE__ */ new Map();
    for (const edit of edits) {
      if (!(edit instanceof ResourceTextEdit)) {
        throw new Error("bad edit - only text edits are supported");
      }
      const model = this._modelService.getModel(edit.resource);
      if (!model) {
        throw new Error("bad edit - model not found");
      }
      if (typeof edit.versionId === "number" && model.getVersionId() !== edit.versionId) {
        throw new Error("bad state - model changed in the meantime");
      }
      let array = textEdits.get(model);
      if (!array) {
        array = [];
        textEdits.set(model, array);
      }
      array.push(EditOperation.replaceMove(Range.lift(edit.textEdit.range), edit.textEdit.text));
    }
    let totalEdits = 0;
    let totalFiles = 0;
    for (const [model, edits2] of textEdits) {
      model.pushStackElement();
      model.pushEditOperations([], edits2, () => []);
      model.pushStackElement();
      totalFiles += 1;
      totalEdits += edits2.length;
    }
    return {
      ariaSummary: format(StandaloneServicesNLS.bulkEditServiceSummary, totalEdits, totalFiles),
      isApplied: totalEdits > 0
    };
  }
};
StandaloneBulkEditService = __decorate23([
  __param21(0, IModelService)
], StandaloneBulkEditService);
var StandaloneUriLabelService = class {
  getUriLabel(resource, options) {
    if (resource.scheme === "file") {
      return resource.fsPath;
    }
    return resource.path;
  }
  getUriBasenameLabel(resource) {
    return basename2(resource);
  }
};
var StandaloneContextViewService = class StandaloneContextViewService2 extends ContextViewService {
  constructor(layoutService, _codeEditorService) {
    super(layoutService);
    this._codeEditorService = _codeEditorService;
  }
  showContextView(delegate, container, shadowRoot) {
    if (!container) {
      const codeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
      if (codeEditor) {
        container = codeEditor.getContainerDomNode();
      }
    }
    return super.showContextView(delegate, container, shadowRoot);
  }
};
StandaloneContextViewService = __decorate23([
  __param21(0, ILayoutService),
  __param21(1, ICodeEditorService)
], StandaloneContextViewService);
var StandaloneWorkspaceTrustManagementService = class {
  constructor() {
    this._neverEmitter = new Emitter();
    this.onDidChangeTrust = this._neverEmitter.event;
  }
  isWorkspaceTrusted() {
    return true;
  }
};
var StandaloneLanguageService = class extends LanguageService {
  constructor() {
    super();
  }
};
var StandaloneLogService = class extends LogService {
  constructor() {
    super(new ConsoleLogger());
  }
};
var StandaloneContextMenuService = class StandaloneContextMenuService2 extends ContextMenuService {
  constructor(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService) {
    super(telemetryService, notificationService, contextViewService, keybindingService, menuService, contextKeyService);
    this.configure({ blockMouse: false });
  }
};
StandaloneContextMenuService = __decorate23([
  __param21(0, ITelemetryService),
  __param21(1, INotificationService),
  __param21(2, IContextViewService),
  __param21(3, IKeybindingService),
  __param21(4, IMenuService),
  __param21(5, IContextKeyService)
], StandaloneContextMenuService);
var StandaloneAudioService = class {
  async playAudioCue(cue, options) {
  }
};
var StandaloneAccessibleNotificationService = class {
  notify(event, userGesture) {
  }
};
registerSingleton(
  IConfigurationService,
  StandaloneConfigurationService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ITextResourceConfigurationService,
  StandaloneResourceConfigurationService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ITextResourcePropertiesService,
  StandaloneResourcePropertiesService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IWorkspaceContextService,
  StandaloneWorkspaceContextService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ILabelService,
  StandaloneUriLabelService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ITelemetryService,
  StandaloneTelemetryService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IDialogService,
  StandaloneDialogService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IEnvironmentService,
  StandaloneEnvironmentService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  INotificationService,
  StandaloneNotificationService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IMarkerService,
  MarkerService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ILanguageService,
  StandaloneLanguageService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IStandaloneThemeService,
  StandaloneThemeService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ILogService,
  StandaloneLogService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IModelService,
  ModelService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IMarkerDecorationsService,
  MarkerDecorationsService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IContextKeyService,
  ContextKeyService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IProgressService,
  StandaloneProgressService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IEditorProgressService,
  StandaloneEditorProgressService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IStorageService,
  InMemoryStorageService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IEditorWorkerService,
  EditorWorkerService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IBulkEditService,
  StandaloneBulkEditService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IWorkspaceTrustManagementService,
  StandaloneWorkspaceTrustManagementService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ITextModelService,
  StandaloneTextModelService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IAccessibilityService,
  AccessibilityService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IListService,
  ListService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  ICommandService,
  StandaloneCommandService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IKeybindingService,
  StandaloneKeybindingService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IQuickInputService,
  StandaloneQuickInputService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IContextViewService,
  StandaloneContextViewService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IOpenerService,
  OpenerService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IClipboardService,
  BrowserClipboardService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IContextMenuService,
  StandaloneContextMenuService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IMenuService,
  MenuService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IAudioCueService,
  StandaloneAudioService,
  0
  /* InstantiationType.Eager */
);
registerSingleton(
  IAccessibleNotificationService,
  StandaloneAccessibleNotificationService,
  0
  /* InstantiationType.Eager */
);
var StandaloneServices;
(function(StandaloneServices2) {
  const serviceCollection = new ServiceCollection();
  for (const [id, descriptor] of getSingletonServiceDescriptors()) {
    serviceCollection.set(id, descriptor);
  }
  const instantiationService = new InstantiationService(serviceCollection, true);
  serviceCollection.set(IInstantiationService, instantiationService);
  function get(serviceId) {
    if (!initialized) {
      initialize({});
    }
    const r = serviceCollection.get(serviceId);
    if (!r) {
      throw new Error("Missing service " + serviceId);
    }
    if (r instanceof SyncDescriptor) {
      return instantiationService.invokeFunction((accessor) => accessor.get(serviceId));
    } else {
      return r;
    }
  }
  StandaloneServices2.get = get;
  let initialized = false;
  const onDidInitialize = new Emitter();
  function initialize(overrides) {
    if (initialized) {
      return instantiationService;
    }
    initialized = true;
    for (const [id, descriptor] of getSingletonServiceDescriptors()) {
      if (!serviceCollection.get(id)) {
        serviceCollection.set(id, descriptor);
      }
    }
    for (const serviceId in overrides) {
      if (overrides.hasOwnProperty(serviceId)) {
        const serviceIdentifier = createDecorator(serviceId);
        const r = serviceCollection.get(serviceIdentifier);
        if (r instanceof SyncDescriptor) {
          serviceCollection.set(serviceIdentifier, overrides[serviceId]);
        }
      }
    }
    const editorFeatures2 = getEditorFeatures();
    for (const feature of editorFeatures2) {
      try {
        instantiationService.createInstance(feature);
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    onDidInitialize.fire();
    return instantiationService;
  }
  StandaloneServices2.initialize = initialize;
  function withServices(callback) {
    if (initialized) {
      return callback();
    }
    const disposable = new DisposableStore();
    const listener = disposable.add(onDidInitialize.event(() => {
      listener.dispose();
      disposable.add(callback());
    }));
    return disposable;
  }
  StandaloneServices2.withServices = withServices;
})(StandaloneServices || (StandaloneServices = {}));

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditorWidget.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/style.css";

// node_modules/monaco-editor/esm/vs/base/common/hotReload.js
function isHotReloadEnabled() {
  return env && !!env["VSCODE_DEV"];
}
function registerHotReloadHandler(handler) {
  if (!isHotReloadEnabled()) {
    return { dispose() {
    } };
  } else {
    const handlers = registerGlobalHotReloadHandler();
    handlers.add(handler);
    return {
      dispose() {
        handlers.delete(handler);
      }
    };
  }
}
function registerGlobalHotReloadHandler() {
  if (!hotReloadHandlers) {
    hotReloadHandlers = /* @__PURE__ */ new Set();
  }
  const g = globalThis;
  if (!g.$hotReload_applyNewExports) {
    g.$hotReload_applyNewExports = (oldExports) => {
      for (const h2 of hotReloadHandlers) {
        const result = h2(oldExports);
        if (result) {
          return result;
        }
      }
      return void 0;
    };
  }
  return hotReloadHandlers;
}
var hotReloadHandlers = void 0;
if (isHotReloadEnabled()) {
  registerHotReloadHandler(({ oldExports, newSrc }) => {
    if (newSrc.indexOf("/* hot-reload:patch-prototype-methods */") === -1) {
      return void 0;
    }
    return (newExports) => {
      var _a, _b;
      for (const key in newExports) {
        const exportedItem = newExports[key];
        console.log(`[hot-reload] Patching prototype methods of '${key}'`, { exportedItem });
        if (typeof exportedItem === "function" && exportedItem.prototype) {
          const oldExportedItem = oldExports[key];
          if (oldExportedItem) {
            for (const prop of Object.getOwnPropertyNames(exportedItem.prototype)) {
              const descriptor = Object.getOwnPropertyDescriptor(exportedItem.prototype, prop);
              const oldDescriptor = Object.getOwnPropertyDescriptor(oldExportedItem.prototype, prop);
              if (((_a = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value) === null || _a === void 0 ? void 0 : _a.toString()) !== ((_b = oldDescriptor === null || oldDescriptor === void 0 ? void 0 : oldDescriptor.value) === null || _b === void 0 ? void 0 : _b.toString())) {
                console.log(`[hot-reload] Patching prototype method '${key}.${prop}'`);
              }
              Object.defineProperty(oldExportedItem.prototype, prop, descriptor);
            }
            newExports[key] = oldExportedItem;
          }
        }
      }
      return true;
    };
  });
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/utils.js
function joinCombine(arr1, arr2, keySelector, combine) {
  if (arr1.length === 0) {
    return arr2;
  }
  if (arr2.length === 0) {
    return arr1;
  }
  const result = [];
  let i = 0;
  let j = 0;
  while (i < arr1.length && j < arr2.length) {
    const val1 = arr1[i];
    const val2 = arr2[j];
    const key1 = keySelector(val1);
    const key2 = keySelector(val2);
    if (key1 < key2) {
      result.push(val1);
      i++;
    } else if (key1 > key2) {
      result.push(val2);
      j++;
    } else {
      result.push(combine(val1, val2));
      i++;
      j++;
    }
  }
  while (i < arr1.length) {
    result.push(arr1[i]);
    i++;
  }
  while (j < arr2.length) {
    result.push(arr2[j]);
    j++;
  }
  return result;
}
function applyObservableDecorations(editor2, decorations) {
  const d = new DisposableStore();
  const decorationsCollection = editor2.createDecorationsCollection();
  d.add(autorunOpts({ debugName: () => `Apply decorations from ${decorations.debugName}` }, (reader) => {
    const d2 = decorations.read(reader);
    decorationsCollection.set(d2);
  }));
  d.add({
    dispose: () => {
      decorationsCollection.clear();
    }
  });
  return d;
}
function appendRemoveOnDispose(parent, child) {
  parent.appendChild(child);
  return toDisposable(() => {
    parent.removeChild(child);
  });
}
var ObservableElementSizeObserver = class extends Disposable {
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  constructor(element, dimension) {
    super();
    this.elementSizeObserver = this._register(new ElementSizeObserver(element, dimension));
    this._width = observableValue(this, this.elementSizeObserver.getWidth());
    this._height = observableValue(this, this.elementSizeObserver.getHeight());
    this._register(this.elementSizeObserver.onDidChange((e) => transaction((tx) => {
      this._width.set(this.elementSizeObserver.getWidth(), tx);
      this._height.set(this.elementSizeObserver.getHeight(), tx);
    })));
  }
  observe(dimension) {
    this.elementSizeObserver.observe(dimension);
  }
  setAutomaticLayout(automaticLayout) {
    if (automaticLayout) {
      this.elementSizeObserver.startObserving();
    } else {
      this.elementSizeObserver.stopObserving();
    }
  }
};
function animatedObservable(targetWindow, base, store) {
  let targetVal = base.get();
  let startVal = targetVal;
  let curVal = targetVal;
  const result = observableValue("animatedValue", targetVal);
  let animationStartMs = -1;
  const durationMs = 300;
  let animationFrame = void 0;
  store.add(autorunHandleChanges({
    createEmptyChangeSummary: () => ({ animate: false }),
    handleChange: (ctx, s) => {
      if (ctx.didChange(base)) {
        s.animate = s.animate || ctx.change;
      }
      return true;
    }
  }, (reader, s) => {
    if (animationFrame !== void 0) {
      targetWindow.cancelAnimationFrame(animationFrame);
      animationFrame = void 0;
    }
    startVal = curVal;
    targetVal = base.read(reader);
    animationStartMs = Date.now() - (s.animate ? 0 : durationMs);
    update();
  }));
  function update() {
    const passedMs = Date.now() - animationStartMs;
    curVal = Math.floor(easeOutExpo(passedMs, startVal, targetVal - startVal, durationMs));
    if (passedMs < durationMs) {
      animationFrame = targetWindow.requestAnimationFrame(update);
    } else {
      curVal = targetVal;
    }
    result.set(curVal, void 0);
  }
  return result;
}
function easeOutExpo(t, b, c, d) {
  return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
}
var ViewZoneOverlayWidget = class extends Disposable {
  constructor(editor2, viewZone, htmlElement) {
    super();
    this._register(new ManagedOverlayWidget(editor2, htmlElement));
    this._register(applyStyle(htmlElement, {
      height: viewZone.actualHeight,
      top: viewZone.actualTop
    }));
  }
};
var PlaceholderViewZone = class {
  get afterLineNumber() {
    return this._afterLineNumber.get();
  }
  constructor(_afterLineNumber, heightInPx) {
    this._afterLineNumber = _afterLineNumber;
    this.heightInPx = heightInPx;
    this.domNode = document.createElement("div");
    this._actualTop = observableValue(this, void 0);
    this._actualHeight = observableValue(this, void 0);
    this.actualTop = this._actualTop;
    this.actualHeight = this._actualHeight;
    this.showInHiddenAreas = true;
    this.onChange = this._afterLineNumber;
    this.onDomNodeTop = (top) => {
      this._actualTop.set(top, void 0);
    };
    this.onComputedHeight = (height) => {
      this._actualHeight.set(height, void 0);
    };
  }
};
var ManagedOverlayWidget = class _ManagedOverlayWidget {
  constructor(_editor, _domElement) {
    this._editor = _editor;
    this._domElement = _domElement;
    this._overlayWidgetId = `managedOverlayWidget-${_ManagedOverlayWidget._counter++}`;
    this._overlayWidget = {
      getId: () => this._overlayWidgetId,
      getDomNode: () => this._domElement,
      getPosition: () => null
    };
    this._editor.addOverlayWidget(this._overlayWidget);
  }
  dispose() {
    this._editor.removeOverlayWidget(this._overlayWidget);
  }
};
ManagedOverlayWidget._counter = 0;
function applyStyle(domNode, style) {
  return autorun((reader) => {
    for (let [key, val] of Object.entries(style)) {
      if (val && typeof val === "object" && "read" in val) {
        val = val.read(reader);
      }
      if (typeof val === "number") {
        val = `${val}px`;
      }
      key = key.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());
      domNode.style[key] = val;
    }
  });
}
function readHotReloadableExport(value, reader) {
  observeHotReloadableExports([value], reader);
  return value;
}
function observeHotReloadableExports(values, reader) {
  if (isHotReloadEnabled()) {
    const o = observableSignalFromEvent("reload", (event) => registerHotReloadHandler(({ oldExports }) => {
      if (![...Object.values(oldExports)].some((v) => values.includes(v))) {
        return void 0;
      }
      return (_newExports) => {
        event(void 0);
        return true;
      };
    }));
    o.read(reader);
  }
}
function applyViewZones(editor2, viewZones, setIsUpdating, zoneIds) {
  const store = new DisposableStore();
  const lastViewZoneIds = [];
  store.add(autorunWithStore((reader, store2) => {
    const curViewZones = viewZones.read(reader);
    const viewZonIdsPerViewZone = /* @__PURE__ */ new Map();
    const viewZoneIdPerOnChangeObservable = /* @__PURE__ */ new Map();
    if (setIsUpdating) {
      setIsUpdating(true);
    }
    editor2.changeViewZones((a) => {
      for (const id of lastViewZoneIds) {
        a.removeZone(id);
        zoneIds === null || zoneIds === void 0 ? void 0 : zoneIds.delete(id);
      }
      lastViewZoneIds.length = 0;
      for (const z of curViewZones) {
        const id = a.addZone(z);
        if (z.setZoneId) {
          z.setZoneId(id);
        }
        lastViewZoneIds.push(id);
        zoneIds === null || zoneIds === void 0 ? void 0 : zoneIds.add(id);
        viewZonIdsPerViewZone.set(z, id);
      }
    });
    if (setIsUpdating) {
      setIsUpdating(false);
    }
    store2.add(autorunHandleChanges({
      createEmptyChangeSummary() {
        return { zoneIds: [] };
      },
      handleChange(context, changeSummary) {
        const id = viewZoneIdPerOnChangeObservable.get(context.changedObservable);
        if (id !== void 0) {
          changeSummary.zoneIds.push(id);
        }
        return true;
      }
    }, (reader2, changeSummary) => {
      for (const vz of curViewZones) {
        if (vz.onChange) {
          viewZoneIdPerOnChangeObservable.set(vz.onChange, viewZonIdsPerViewZone.get(vz));
          vz.onChange.read(reader2);
        }
      }
      if (setIsUpdating) {
        setIsUpdating(true);
      }
      editor2.changeViewZones((a) => {
        for (const id of changeSummary.zoneIds) {
          a.layoutZone(id);
        }
      });
      if (setIsUpdating) {
        setIsUpdating(false);
      }
    }));
  }));
  store.add({
    dispose() {
      if (setIsUpdating) {
        setIsUpdating(true);
      }
      editor2.changeViewZones((a) => {
        for (const id of lastViewZoneIds) {
          a.removeZone(id);
        }
      });
      zoneIds === null || zoneIds === void 0 ? void 0 : zoneIds.clear();
      if (setIsUpdating) {
        setIsUpdating(false);
      }
    }
  });
  return store;
}
var DisposableCancellationTokenSource = class extends CancellationTokenSource {
  dispose() {
    super.dispose(true);
  }
};
function translatePosition(posInOriginal, mappings) {
  const mapping = findLast(mappings, (m) => m.original.startLineNumber <= posInOriginal.lineNumber);
  if (!mapping) {
    return Range.fromPositions(posInOriginal);
  }
  if (mapping.original.endLineNumberExclusive <= posInOriginal.lineNumber) {
    const newLineNumber = posInOriginal.lineNumber - mapping.original.endLineNumberExclusive + mapping.modified.endLineNumberExclusive;
    return Range.fromPositions(new Position(newLineNumber, posInOriginal.column));
  }
  if (!mapping.innerChanges) {
    return Range.fromPositions(new Position(mapping.modified.startLineNumber, 1));
  }
  const innerMapping = findLast(mapping.innerChanges, (m) => m.originalRange.getStartPosition().isBeforeOrEqual(posInOriginal));
  if (!innerMapping) {
    const newLineNumber = posInOriginal.lineNumber - mapping.original.startLineNumber + mapping.modified.startLineNumber;
    return Range.fromPositions(new Position(newLineNumber, posInOriginal.column));
  }
  if (innerMapping.originalRange.containsPosition(posInOriginal)) {
    return innerMapping.modifiedRange;
  } else {
    const l = lengthBetweenPositions(innerMapping.originalRange.getEndPosition(), posInOriginal);
    return Range.fromPositions(addLength(innerMapping.modifiedRange.getEndPosition(), l));
  }
}
function lengthBetweenPositions(position1, position2) {
  if (position1.lineNumber === position2.lineNumber) {
    return new LengthObj(0, position2.column - position1.column);
  } else {
    return new LengthObj(position2.lineNumber - position1.lineNumber, position2.column - 1);
  }
}
function addLength(position, length) {
  if (length.lineCount === 0) {
    return new Position(position.lineNumber, position.column + length.columnCount);
  } else {
    return new Position(position.lineNumber + length.lineCount, length.columnCount + 1);
  }
}
function bindContextKey(key, service, computeValue) {
  const boundKey = key.bindTo(service);
  return autorunOpts({ debugName: () => `Update ${key.key}` }, (reader) => {
    boundKey.set(computeValue(reader));
  });
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/accessibleDiffViewer.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/accessibleDiffViewer.css";
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var accessibleDiffViewerInsertIcon = registerIcon("diff-review-insert", Codicon.add, localize("accessibleDiffViewerInsertIcon", "Icon for 'Insert' in accessible diff viewer."));
var accessibleDiffViewerRemoveIcon = registerIcon("diff-review-remove", Codicon.remove, localize("accessibleDiffViewerRemoveIcon", "Icon for 'Remove' in accessible diff viewer."));
var accessibleDiffViewerCloseIcon = registerIcon("diff-review-close", Codicon.close, localize("accessibleDiffViewerCloseIcon", "Icon for 'Close' in accessible diff viewer."));
var AccessibleDiffViewer = class AccessibleDiffViewer2 extends Disposable {
  constructor(_parentNode, _visible, _setVisible, _canClose, _width, _height, _diffs, _editors, _instantiationService) {
    super();
    this._parentNode = _parentNode;
    this._visible = _visible;
    this._setVisible = _setVisible;
    this._canClose = _canClose;
    this._width = _width;
    this._height = _height;
    this._diffs = _diffs;
    this._editors = _editors;
    this._instantiationService = _instantiationService;
    this._state = derivedWithStore(this, (reader, store) => {
      const visible = this._visible.read(reader);
      this._parentNode.style.visibility = visible ? "visible" : "hidden";
      if (!visible) {
        return null;
      }
      const model = store.add(this._instantiationService.createInstance(ViewModel, this._diffs, this._editors, this._setVisible, this._canClose));
      const view = store.add(this._instantiationService.createInstance(View, this._parentNode, model, this._width, this._height, this._editors));
      return { model, view };
    }).recomputeInitiallyAndOnChange(this._store);
  }
  next() {
    transaction((tx) => {
      const isVisible = this._visible.get();
      this._setVisible(true, tx);
      if (isVisible) {
        this._state.get().model.nextGroup(tx);
      }
    });
  }
  prev() {
    transaction((tx) => {
      this._setVisible(true, tx);
      this._state.get().model.previousGroup(tx);
    });
  }
  close() {
    transaction((tx) => {
      this._setVisible(false, tx);
    });
  }
};
AccessibleDiffViewer._ttPolicy = createTrustedTypesPolicy("diffReview", { createHTML: (value) => value });
AccessibleDiffViewer = __decorate24([
  __param22(8, IInstantiationService)
], AccessibleDiffViewer);
var ViewModel = class ViewModel2 extends Disposable {
  constructor(_diffs, _editors, _setVisible, canClose, _audioCueService) {
    super();
    this._diffs = _diffs;
    this._editors = _editors;
    this._setVisible = _setVisible;
    this.canClose = canClose;
    this._audioCueService = _audioCueService;
    this._groups = observableValue(this, []);
    this._currentGroupIdx = observableValue(this, 0);
    this._currentElementIdx = observableValue(this, 0);
    this.groups = this._groups;
    this.currentGroup = this._currentGroupIdx.map((idx, r) => this._groups.read(r)[idx]);
    this.currentGroupIndex = this._currentGroupIdx;
    this.currentElement = this._currentElementIdx.map((idx, r) => {
      var _a;
      return (_a = this.currentGroup.read(r)) === null || _a === void 0 ? void 0 : _a.lines[idx];
    });
    this._register(autorun((reader) => {
      const diffs = this._diffs.read(reader);
      if (!diffs) {
        this._groups.set([], void 0);
        return;
      }
      const groups = computeViewElementGroups(diffs, this._editors.original.getModel().getLineCount(), this._editors.modified.getModel().getLineCount());
      transaction((tx) => {
        const p = this._editors.modified.getPosition();
        if (p) {
          const nextGroup = groups.findIndex((g) => (p === null || p === void 0 ? void 0 : p.lineNumber) < g.range.modified.endLineNumberExclusive);
          if (nextGroup !== -1) {
            this._currentGroupIdx.set(nextGroup, tx);
          }
        }
        this._groups.set(groups, tx);
      });
    }));
    this._register(autorun((reader) => {
      const currentViewItem = this.currentElement.read(reader);
      if ((currentViewItem === null || currentViewItem === void 0 ? void 0 : currentViewItem.type) === LineType.Deleted) {
        this._audioCueService.playAudioCue(AudioCue.diffLineDeleted, { source: "accessibleDiffViewer.currentElementChanged" });
      } else if ((currentViewItem === null || currentViewItem === void 0 ? void 0 : currentViewItem.type) === LineType.Added) {
        this._audioCueService.playAudioCue(AudioCue.diffLineInserted, { source: "accessibleDiffViewer.currentElementChanged" });
      }
    }));
    this._register(autorun((reader) => {
      var _a;
      const currentViewItem = this.currentElement.read(reader);
      if (currentViewItem && currentViewItem.type !== LineType.Header) {
        const lineNumber = (_a = currentViewItem.modifiedLineNumber) !== null && _a !== void 0 ? _a : currentViewItem.diff.modified.startLineNumber;
        this._editors.modified.setSelection(Range.fromPositions(new Position(lineNumber, 1)));
      }
    }));
  }
  _goToGroupDelta(delta, tx) {
    const groups = this.groups.get();
    if (!groups || groups.length <= 1) {
      return;
    }
    subtransaction(tx, (tx2) => {
      this._currentGroupIdx.set(OffsetRange.ofLength(groups.length).clipCyclic(this._currentGroupIdx.get() + delta), tx2);
      this._currentElementIdx.set(0, tx2);
    });
  }
  nextGroup(tx) {
    this._goToGroupDelta(1, tx);
  }
  previousGroup(tx) {
    this._goToGroupDelta(-1, tx);
  }
  _goToLineDelta(delta) {
    const group = this.currentGroup.get();
    if (!group || group.lines.length <= 1) {
      return;
    }
    transaction((tx) => {
      this._currentElementIdx.set(OffsetRange.ofLength(group.lines.length).clip(this._currentElementIdx.get() + delta), tx);
    });
  }
  goToNextLine() {
    this._goToLineDelta(1);
  }
  goToPreviousLine() {
    this._goToLineDelta(-1);
  }
  goToLine(line) {
    const group = this.currentGroup.get();
    if (!group) {
      return;
    }
    const idx = group.lines.indexOf(line);
    if (idx === -1) {
      return;
    }
    transaction((tx) => {
      this._currentElementIdx.set(idx, tx);
    });
  }
  revealCurrentElementInEditor() {
    this._setVisible(false, void 0);
    const curElem = this.currentElement.get();
    if (curElem) {
      if (curElem.type === LineType.Deleted) {
        this._editors.original.setSelection(Range.fromPositions(new Position(curElem.originalLineNumber, 1)));
        this._editors.original.revealLine(curElem.originalLineNumber);
        this._editors.original.focus();
      } else {
        if (curElem.type !== LineType.Header) {
          this._editors.modified.setSelection(Range.fromPositions(new Position(curElem.modifiedLineNumber, 1)));
          this._editors.modified.revealLine(curElem.modifiedLineNumber);
        }
        this._editors.modified.focus();
      }
    }
  }
  close() {
    this._setVisible(false, void 0);
    this._editors.modified.focus();
  }
};
ViewModel = __decorate24([
  __param22(4, IAudioCueService)
], ViewModel);
var viewElementGroupLineMargin = 3;
function computeViewElementGroups(diffs, originalLineCount, modifiedLineCount) {
  const result = [];
  for (const g of groupAdjacentBy(diffs, (a, b) => b.modified.startLineNumber - a.modified.endLineNumberExclusive < 2 * viewElementGroupLineMargin)) {
    const viewElements = [];
    viewElements.push(new HeaderViewElement());
    const origFullRange = new LineRange(Math.max(1, g[0].original.startLineNumber - viewElementGroupLineMargin), Math.min(g[g.length - 1].original.endLineNumberExclusive + viewElementGroupLineMargin, originalLineCount + 1));
    const modifiedFullRange = new LineRange(Math.max(1, g[0].modified.startLineNumber - viewElementGroupLineMargin), Math.min(g[g.length - 1].modified.endLineNumberExclusive + viewElementGroupLineMargin, modifiedLineCount + 1));
    forEachAdjacent(g, (a, b) => {
      const origRange = new LineRange(a ? a.original.endLineNumberExclusive : origFullRange.startLineNumber, b ? b.original.startLineNumber : origFullRange.endLineNumberExclusive);
      const modifiedRange2 = new LineRange(a ? a.modified.endLineNumberExclusive : modifiedFullRange.startLineNumber, b ? b.modified.startLineNumber : modifiedFullRange.endLineNumberExclusive);
      origRange.forEach((origLineNumber) => {
        viewElements.push(new UnchangedLineViewElement(origLineNumber, modifiedRange2.startLineNumber + (origLineNumber - origRange.startLineNumber)));
      });
      if (b) {
        b.original.forEach((origLineNumber) => {
          viewElements.push(new DeletedLineViewElement(b, origLineNumber));
        });
        b.modified.forEach((modifiedLineNumber) => {
          viewElements.push(new AddedLineViewElement(b, modifiedLineNumber));
        });
      }
    });
    const modifiedRange = g[0].modified.join(g[g.length - 1].modified);
    const originalRange = g[0].original.join(g[g.length - 1].original);
    result.push(new ViewElementGroup(new LineRangeMapping(modifiedRange, originalRange), viewElements));
  }
  return result;
}
var LineType;
(function(LineType2) {
  LineType2[LineType2["Header"] = 0] = "Header";
  LineType2[LineType2["Unchanged"] = 1] = "Unchanged";
  LineType2[LineType2["Deleted"] = 2] = "Deleted";
  LineType2[LineType2["Added"] = 3] = "Added";
})(LineType || (LineType = {}));
var ViewElementGroup = class {
  constructor(range2, lines) {
    this.range = range2;
    this.lines = lines;
  }
};
var HeaderViewElement = class {
  constructor() {
    this.type = LineType.Header;
  }
};
var DeletedLineViewElement = class {
  constructor(diff, originalLineNumber) {
    this.diff = diff;
    this.originalLineNumber = originalLineNumber;
    this.type = LineType.Deleted;
    this.modifiedLineNumber = void 0;
  }
};
var AddedLineViewElement = class {
  constructor(diff, modifiedLineNumber) {
    this.diff = diff;
    this.modifiedLineNumber = modifiedLineNumber;
    this.type = LineType.Added;
    this.originalLineNumber = void 0;
  }
};
var UnchangedLineViewElement = class {
  constructor(originalLineNumber, modifiedLineNumber) {
    this.originalLineNumber = originalLineNumber;
    this.modifiedLineNumber = modifiedLineNumber;
    this.type = LineType.Unchanged;
  }
};
var View = class View2 extends Disposable {
  constructor(_element, _model, _width, _height, _editors, _languageService) {
    super();
    this._element = _element;
    this._model = _model;
    this._width = _width;
    this._height = _height;
    this._editors = _editors;
    this._languageService = _languageService;
    this.domNode = this._element;
    this.domNode.className = "diff-review monaco-editor-background";
    const actionBarContainer = document.createElement("div");
    actionBarContainer.className = "diff-review-actions";
    this._actionBar = this._register(new ActionBar(actionBarContainer));
    this._register(autorun((reader) => {
      this._actionBar.clear();
      if (this._model.canClose.read(reader)) {
        this._actionBar.push(new Action("diffreview.close", localize("label.close", "Close"), "close-diff-review " + ThemeIcon.asClassName(accessibleDiffViewerCloseIcon), true, async () => _model.close()), { label: false, icon: true });
      }
    }));
    this._content = document.createElement("div");
    this._content.className = "diff-review-content";
    this._content.setAttribute("role", "code");
    this._scrollbar = this._register(new DomScrollableElement(this._content, {}));
    reset(this.domNode, this._scrollbar.getDomNode(), actionBarContainer);
    this._register(toDisposable(() => {
      reset(this.domNode);
    }));
    this._register(applyStyle(this.domNode, { width: this._width, height: this._height }));
    this._register(applyStyle(this._content, { width: this._width, height: this._height }));
    this._register(autorunWithStore((reader, store) => {
      this._model.currentGroup.read(reader);
      this._render(store);
    }));
    this._register(addStandardDisposableListener(this.domNode, "keydown", (e) => {
      if (e.equals(
        18
        /* KeyCode.DownArrow */
      ) || e.equals(
        2048 | 18
        /* KeyCode.DownArrow */
      ) || e.equals(
        512 | 18
        /* KeyCode.DownArrow */
      )) {
        e.preventDefault();
        this._model.goToNextLine();
      }
      if (e.equals(
        16
        /* KeyCode.UpArrow */
      ) || e.equals(
        2048 | 16
        /* KeyCode.UpArrow */
      ) || e.equals(
        512 | 16
        /* KeyCode.UpArrow */
      )) {
        e.preventDefault();
        this._model.goToPreviousLine();
      }
      if (e.equals(
        9
        /* KeyCode.Escape */
      ) || e.equals(
        2048 | 9
        /* KeyCode.Escape */
      ) || e.equals(
        512 | 9
        /* KeyCode.Escape */
      ) || e.equals(
        1024 | 9
        /* KeyCode.Escape */
      )) {
        e.preventDefault();
        this._model.close();
      }
      if (e.equals(
        10
        /* KeyCode.Space */
      ) || e.equals(
        3
        /* KeyCode.Enter */
      )) {
        e.preventDefault();
        this._model.revealCurrentElementInEditor();
      }
    }));
  }
  _render(store) {
    const originalOptions = this._editors.original.getOptions();
    const modifiedOptions = this._editors.modified.getOptions();
    const container = document.createElement("div");
    container.className = "diff-review-table";
    container.setAttribute("role", "list");
    container.setAttribute("aria-label", localize("ariaLabel", "Accessible Diff Viewer. Use arrow up and down to navigate."));
    applyFontInfo(container, modifiedOptions.get(
      50
      /* EditorOption.fontInfo */
    ));
    reset(this._content, container);
    const originalModel = this._editors.original.getModel();
    const modifiedModel = this._editors.modified.getModel();
    if (!originalModel || !modifiedModel) {
      return;
    }
    const originalModelOpts = originalModel.getOptions();
    const modifiedModelOpts = modifiedModel.getOptions();
    const lineHeight = modifiedOptions.get(
      66
      /* EditorOption.lineHeight */
    );
    const group = this._model.currentGroup.get();
    for (const viewItem of (group === null || group === void 0 ? void 0 : group.lines) || []) {
      if (!group) {
        break;
      }
      let row;
      if (viewItem.type === LineType.Header) {
        const header = document.createElement("div");
        header.className = "diff-review-row";
        header.setAttribute("role", "listitem");
        const r = group.range;
        const diffIndex = this._model.currentGroupIndex.get();
        const diffsLength = this._model.groups.get().length;
        const getAriaLines = (lines) => lines === 0 ? localize("no_lines_changed", "no lines changed") : lines === 1 ? localize("one_line_changed", "1 line changed") : localize("more_lines_changed", "{0} lines changed", lines);
        const originalChangedLinesCntAria = getAriaLines(r.original.length);
        const modifiedChangedLinesCntAria = getAriaLines(r.modified.length);
        header.setAttribute("aria-label", localize({
          key: "header",
          comment: [
            "This is the ARIA label for a git diff header.",
            "A git diff header looks like this: @@ -154,12 +159,39 @@.",
            "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
            "Variables 0 and 1 refer to the diff index out of total number of diffs.",
            "Variables 2 and 4 will be numbers (a line number).",
            'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
          ]
        }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", diffIndex + 1, diffsLength, r.original.startLineNumber, originalChangedLinesCntAria, r.modified.startLineNumber, modifiedChangedLinesCntAria));
        const cell = document.createElement("div");
        cell.className = "diff-review-cell diff-review-summary";
        cell.appendChild(document.createTextNode(`${diffIndex + 1}/${diffsLength}: @@ -${r.original.startLineNumber},${r.original.length} +${r.modified.startLineNumber},${r.modified.length} @@`));
        header.appendChild(cell);
        row = header;
      } else {
        row = this._createRow(viewItem, lineHeight, this._width.get(), originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts);
      }
      container.appendChild(row);
      const isSelectedObs = derived((reader) => (
        /** @description isSelected */
        this._model.currentElement.read(reader) === viewItem
      ));
      store.add(autorun((reader) => {
        const isSelected = isSelectedObs.read(reader);
        row.tabIndex = isSelected ? 0 : -1;
        if (isSelected) {
          row.focus();
        }
      }));
      store.add(addDisposableListener(row, "focus", () => {
        this._model.goToLine(viewItem);
      }));
    }
    this._scrollbar.scanDomNode();
  }
  _createRow(item, lineHeight, width, originalOptions, originalModel, originalModelOpts, modifiedOptions, modifiedModel, modifiedModelOpts) {
    const originalLayoutInfo = originalOptions.get(
      143
      /* EditorOption.layoutInfo */
    );
    const originalLineNumbersWidth = originalLayoutInfo.glyphMarginWidth + originalLayoutInfo.lineNumbersWidth;
    const modifiedLayoutInfo = modifiedOptions.get(
      143
      /* EditorOption.layoutInfo */
    );
    const modifiedLineNumbersWidth = 10 + modifiedLayoutInfo.glyphMarginWidth + modifiedLayoutInfo.lineNumbersWidth;
    let rowClassName = "diff-review-row";
    let lineNumbersExtraClassName = "";
    const spacerClassName = "diff-review-spacer";
    let spacerIcon = null;
    switch (item.type) {
      case LineType.Added:
        rowClassName = "diff-review-row line-insert";
        lineNumbersExtraClassName = " char-insert";
        spacerIcon = accessibleDiffViewerInsertIcon;
        break;
      case LineType.Deleted:
        rowClassName = "diff-review-row line-delete";
        lineNumbersExtraClassName = " char-delete";
        spacerIcon = accessibleDiffViewerRemoveIcon;
        break;
    }
    const row = document.createElement("div");
    row.style.minWidth = width + "px";
    row.className = rowClassName;
    row.setAttribute("role", "listitem");
    row.ariaLevel = "";
    const cell = document.createElement("div");
    cell.className = "diff-review-cell";
    cell.style.height = `${lineHeight}px`;
    row.appendChild(cell);
    const originalLineNumber = document.createElement("span");
    originalLineNumber.style.width = originalLineNumbersWidth + "px";
    originalLineNumber.style.minWidth = originalLineNumbersWidth + "px";
    originalLineNumber.className = "diff-review-line-number" + lineNumbersExtraClassName;
    if (item.originalLineNumber !== void 0) {
      originalLineNumber.appendChild(document.createTextNode(String(item.originalLineNumber)));
    } else {
      originalLineNumber.innerText = " ";
    }
    cell.appendChild(originalLineNumber);
    const modifiedLineNumber = document.createElement("span");
    modifiedLineNumber.style.width = modifiedLineNumbersWidth + "px";
    modifiedLineNumber.style.minWidth = modifiedLineNumbersWidth + "px";
    modifiedLineNumber.style.paddingRight = "10px";
    modifiedLineNumber.className = "diff-review-line-number" + lineNumbersExtraClassName;
    if (item.modifiedLineNumber !== void 0) {
      modifiedLineNumber.appendChild(document.createTextNode(String(item.modifiedLineNumber)));
    } else {
      modifiedLineNumber.innerText = " ";
    }
    cell.appendChild(modifiedLineNumber);
    const spacer = document.createElement("span");
    spacer.className = spacerClassName;
    if (spacerIcon) {
      const spacerCodicon = document.createElement("span");
      spacerCodicon.className = ThemeIcon.asClassName(spacerIcon);
      spacerCodicon.innerText = "  ";
      spacer.appendChild(spacerCodicon);
    } else {
      spacer.innerText = "  ";
    }
    cell.appendChild(spacer);
    let lineContent;
    if (item.modifiedLineNumber !== void 0) {
      let html = this._getLineHtml(modifiedModel, modifiedOptions, modifiedModelOpts.tabSize, item.modifiedLineNumber, this._languageService.languageIdCodec);
      if (AccessibleDiffViewer._ttPolicy) {
        html = AccessibleDiffViewer._ttPolicy.createHTML(html);
      }
      cell.insertAdjacentHTML("beforeend", html);
      lineContent = modifiedModel.getLineContent(item.modifiedLineNumber);
    } else {
      let html = this._getLineHtml(originalModel, originalOptions, originalModelOpts.tabSize, item.originalLineNumber, this._languageService.languageIdCodec);
      if (AccessibleDiffViewer._ttPolicy) {
        html = AccessibleDiffViewer._ttPolicy.createHTML(html);
      }
      cell.insertAdjacentHTML("beforeend", html);
      lineContent = originalModel.getLineContent(item.originalLineNumber);
    }
    if (lineContent.length === 0) {
      lineContent = localize("blankLine", "blank");
    }
    let ariaLabel = "";
    switch (item.type) {
      case LineType.Unchanged:
        if (item.originalLineNumber === item.modifiedLineNumber) {
          ariaLabel = localize({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", lineContent, item.originalLineNumber);
        } else {
          ariaLabel = localize("equalLine", "{0} original line {1} modified line {2}", lineContent, item.originalLineNumber, item.modifiedLineNumber);
        }
        break;
      case LineType.Added:
        ariaLabel = localize("insertLine", "+ {0} modified line {1}", lineContent, item.modifiedLineNumber);
        break;
      case LineType.Deleted:
        ariaLabel = localize("deleteLine", "- {0} original line {1}", lineContent, item.originalLineNumber);
        break;
    }
    row.setAttribute("aria-label", ariaLabel);
    return row;
  }
  _getLineHtml(model, options, tabSize, lineNumber, languageIdCodec) {
    const lineContent = model.getLineContent(lineNumber);
    const fontInfo = options.get(
      50
      /* EditorOption.fontInfo */
    );
    const lineTokens = LineTokens.createEmpty(lineContent, languageIdCodec);
    const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(lineContent, model.mightContainNonBasicASCII());
    const containsRTL = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII2, model.mightContainRTL());
    const r = renderViewLine2(new RenderLineInput(fontInfo.isMonospace && !options.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), fontInfo.canUseHalfwidthRightwardsArrow, lineContent, false, isBasicASCII2, containsRTL, 0, lineTokens, [], tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, options.get(
      116
      /* EditorOption.stopRenderingLineAfter */
    ), options.get(
      98
      /* EditorOption.renderWhitespace */
    ), options.get(
      93
      /* EditorOption.renderControlCharacters */
    ), options.get(
      51
      /* EditorOption.fontLigatures */
    ) !== EditorFontLigatures.OFF, null));
    return r.html;
  }
};
View = __decorate24([
  __param22(5, ILanguageService)
], View);

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/decorations.js
var diffInsertIcon = registerIcon("diff-insert", Codicon.add, localize("diffInsertIcon", "Line decoration for inserts in the diff editor."));
var diffRemoveIcon = registerIcon("diff-remove", Codicon.remove, localize("diffRemoveIcon", "Line decoration for removals in the diff editor."));
var diffLineAddDecorationBackgroundWithIndicator = ModelDecorationOptions.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: true,
  linesDecorationsClassName: "insert-sign " + ThemeIcon.asClassName(diffInsertIcon),
  marginClassName: "gutter-insert"
});
var diffLineDeleteDecorationBackgroundWithIndicator = ModelDecorationOptions.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: true,
  linesDecorationsClassName: "delete-sign " + ThemeIcon.asClassName(diffRemoveIcon),
  marginClassName: "gutter-delete"
});
var diffLineAddDecorationBackground = ModelDecorationOptions.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: true,
  marginClassName: "gutter-insert"
});
var diffLineDeleteDecorationBackground = ModelDecorationOptions.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: true,
  marginClassName: "gutter-delete"
});
var diffAddDecoration = ModelDecorationOptions.register({
  className: "char-insert",
  description: "char-insert",
  shouldFillLineOnLineBreak: true
});
var diffWholeLineAddDecoration = ModelDecorationOptions.register({
  className: "char-insert",
  description: "char-insert",
  isWholeLine: true
});
var diffAddDecorationEmpty = ModelDecorationOptions.register({
  className: "char-insert diff-range-empty",
  description: "char-insert diff-range-empty"
});
var diffDeleteDecoration = ModelDecorationOptions.register({
  className: "char-delete",
  description: "char-delete",
  shouldFillLineOnLineBreak: true
});
var diffWholeLineDeleteDecoration = ModelDecorationOptions.register({
  className: "char-delete",
  description: "char-delete",
  isWholeLine: true
});
var diffDeleteDecorationEmpty = ModelDecorationOptions.register({
  className: "char-delete diff-range-empty",
  description: "char-delete diff-range-empty"
});

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/movedBlocksLines.js
var MovedBlocksLinesPart = class _MovedBlocksLinesPart extends Disposable {
  constructor(_rootElement, _diffModel, _originalEditorLayoutInfo, _modifiedEditorLayoutInfo, _editors) {
    super();
    this._rootElement = _rootElement;
    this._diffModel = _diffModel;
    this._originalEditorLayoutInfo = _originalEditorLayoutInfo;
    this._modifiedEditorLayoutInfo = _modifiedEditorLayoutInfo;
    this._editors = _editors;
    this._originalScrollTop = observableFromEvent(this._editors.original.onDidScrollChange, () => this._editors.original.getScrollTop());
    this._modifiedScrollTop = observableFromEvent(this._editors.modified.onDidScrollChange, () => this._editors.modified.getScrollTop());
    this._viewZonesChanged = observableSignalFromEvent("onDidChangeViewZones", this._editors.modified.onDidChangeViewZones);
    this.width = observableValue(this, 0);
    this._modifiedViewZonesChangedSignal = observableSignalFromEvent("modified.onDidChangeViewZones", this._editors.modified.onDidChangeViewZones);
    this._originalViewZonesChangedSignal = observableSignalFromEvent("original.onDidChangeViewZones", this._editors.original.onDidChangeViewZones);
    this._state = derivedWithStore(this, (reader, store) => {
      var _a;
      this._element.replaceChildren();
      const model = this._diffModel.read(reader);
      const moves = (_a = model === null || model === void 0 ? void 0 : model.diff.read(reader)) === null || _a === void 0 ? void 0 : _a.movedTexts;
      if (!moves || moves.length === 0) {
        this.width.set(0, void 0);
        return;
      }
      this._viewZonesChanged.read(reader);
      const infoOrig = this._originalEditorLayoutInfo.read(reader);
      const infoMod = this._modifiedEditorLayoutInfo.read(reader);
      if (!infoOrig || !infoMod) {
        this.width.set(0, void 0);
        return;
      }
      this._modifiedViewZonesChangedSignal.read(reader);
      this._originalViewZonesChangedSignal.read(reader);
      const lines = moves.map((move) => {
        function computeLineStart(range2, editor2) {
          const t1 = editor2.getTopForLineNumber(range2.startLineNumber, true);
          const t2 = editor2.getTopForLineNumber(range2.endLineNumberExclusive, true);
          return (t1 + t2) / 2;
        }
        const start = computeLineStart(move.lineRangeMapping.original, this._editors.original);
        const startOffset = this._originalScrollTop.read(reader);
        const end = computeLineStart(move.lineRangeMapping.modified, this._editors.modified);
        const endOffset = this._modifiedScrollTop.read(reader);
        const from = start - startOffset;
        const to = end - endOffset;
        const top = Math.min(start, end);
        const bottom = Math.max(start, end);
        return { range: new OffsetRange(top, bottom), from, to, fromWithoutScroll: start, toWithoutScroll: end, move };
      });
      lines.sort(tieBreakComparators(compareBy((l) => l.fromWithoutScroll > l.toWithoutScroll, booleanComparator), compareBy((l) => l.fromWithoutScroll > l.toWithoutScroll ? l.fromWithoutScroll : -l.toWithoutScroll, numberComparator)));
      const layout2 = LinesLayout.compute(lines.map((l) => l.range));
      const padding = 10;
      const lineAreaLeft = infoOrig.verticalScrollbarWidth;
      const lineAreaWidth = (layout2.getTrackCount() - 1) * 10 + padding * 2;
      const width = lineAreaLeft + lineAreaWidth + (infoMod.contentLeft - _MovedBlocksLinesPart.movedCodeBlockPadding);
      let idx = 0;
      for (const line of lines) {
        const track = layout2.getTrack(idx);
        const verticalY = lineAreaLeft + padding + track * 10;
        const arrowHeight = 15;
        const arrowWidth = 15;
        const right = width;
        const rectWidth = infoMod.glyphMarginWidth + infoMod.lineNumbersWidth;
        const rectHeight = 18;
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.classList.add("arrow-rectangle");
        rect.setAttribute("x", `${right - rectWidth}`);
        rect.setAttribute("y", `${line.to - rectHeight / 2}`);
        rect.setAttribute("width", `${rectWidth}`);
        rect.setAttribute("height", `${rectHeight}`);
        this._element.appendChild(rect);
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", `M ${0} ${line.from} L ${verticalY} ${line.from} L ${verticalY} ${line.to} L ${right - arrowWidth} ${line.to}`);
        path.setAttribute("fill", "none");
        g.appendChild(path);
        const arrowRight = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        arrowRight.classList.add("arrow");
        store.add(autorun((reader2) => {
          path.classList.toggle("currentMove", line.move === model.activeMovedText.read(reader2));
          arrowRight.classList.toggle("currentMove", line.move === model.activeMovedText.read(reader2));
        }));
        arrowRight.setAttribute("points", `${right - arrowWidth},${line.to - arrowHeight / 2} ${right},${line.to} ${right - arrowWidth},${line.to + arrowHeight / 2}`);
        g.appendChild(arrowRight);
        this._element.appendChild(g);
        idx++;
      }
      this.width.set(lineAreaWidth, void 0);
    });
    this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this._element.setAttribute("class", "moved-blocks-lines");
    this._rootElement.appendChild(this._element);
    this._register(toDisposable(() => this._element.remove()));
    this._register(autorun((reader) => {
      const info = this._originalEditorLayoutInfo.read(reader);
      const info2 = this._modifiedEditorLayoutInfo.read(reader);
      if (!info || !info2) {
        return;
      }
      this._element.style.left = `${info.width - info.verticalScrollbarWidth}px`;
      this._element.style.height = `${info.height}px`;
      this._element.style.width = `${info.verticalScrollbarWidth + info.contentLeft - _MovedBlocksLinesPart.movedCodeBlockPadding + this.width.read(reader)}px`;
    }));
    this._register(recomputeInitiallyAndOnChange(this._state));
    const movedBlockViewZones = derived((reader) => {
      const model = this._diffModel.read(reader);
      const d = model === null || model === void 0 ? void 0 : model.diff.read(reader);
      if (!d) {
        return [];
      }
      return d.movedTexts.map((move) => ({
        move,
        original: new PlaceholderViewZone(constObservable(move.lineRangeMapping.original.startLineNumber - 1), 18),
        modified: new PlaceholderViewZone(constObservable(move.lineRangeMapping.modified.startLineNumber - 1), 18)
      }));
    });
    this._register(applyViewZones(this._editors.original, movedBlockViewZones.map((zones) => (
      /** @description movedBlockViewZones.original */
      zones.map((z) => z.original)
    ))));
    this._register(applyViewZones(this._editors.modified, movedBlockViewZones.map((zones) => (
      /** @description movedBlockViewZones.modified */
      zones.map((z) => z.modified)
    ))));
    this._register(autorunWithStore((reader, store) => {
      const blocks = movedBlockViewZones.read(reader);
      for (const b of blocks) {
        store.add(new MovedBlockOverlayWidget(this._editors.original, b.original, b.move, "original", this._diffModel.get()));
        store.add(new MovedBlockOverlayWidget(this._editors.modified, b.modified, b.move, "modified", this._diffModel.get()));
      }
    }));
    const originalCursorPosition = observableFromEvent(this._editors.original.onDidChangeCursorPosition, () => this._editors.original.getPosition());
    const modifiedCursorPosition = observableFromEvent(this._editors.modified.onDidChangeCursorPosition, () => this._editors.modified.getPosition());
    const originalHasFocus = observableSignalFromEvent("original.onDidFocusEditorWidget", (e) => this._editors.original.onDidFocusEditorWidget(() => setTimeout(() => e(void 0), 0)));
    const modifiedHasFocus = observableSignalFromEvent("modified.onDidFocusEditorWidget", (e) => this._editors.modified.onDidFocusEditorWidget(() => setTimeout(() => e(void 0), 0)));
    let lastChangedEditor = "modified";
    this._register(autorunHandleChanges({
      createEmptyChangeSummary: () => void 0,
      handleChange: (ctx, summary) => {
        if (ctx.didChange(originalHasFocus)) {
          lastChangedEditor = "original";
        }
        if (ctx.didChange(modifiedHasFocus)) {
          lastChangedEditor = "modified";
        }
        return true;
      }
    }, (reader) => {
      originalHasFocus.read(reader);
      modifiedHasFocus.read(reader);
      const m = this._diffModel.read(reader);
      if (!m) {
        return;
      }
      const diff = m.diff.read(reader);
      let movedText = void 0;
      if (diff && lastChangedEditor === "original") {
        const originalPos = originalCursorPosition.read(reader);
        if (originalPos) {
          movedText = diff.movedTexts.find((m2) => m2.lineRangeMapping.original.contains(originalPos.lineNumber));
        }
      }
      if (diff && lastChangedEditor === "modified") {
        const modifiedPos = modifiedCursorPosition.read(reader);
        if (modifiedPos) {
          movedText = diff.movedTexts.find((m2) => m2.lineRangeMapping.modified.contains(modifiedPos.lineNumber));
        }
      }
      if (movedText !== m.movedTextToCompare.get()) {
        m.movedTextToCompare.set(void 0, void 0);
      }
      m.setActiveMovedText(movedText);
    }));
  }
};
MovedBlocksLinesPart.movedCodeBlockPadding = 4;
var LinesLayout = class _LinesLayout {
  static compute(lines) {
    const setsPerTrack = [];
    const trackPerLineIdx = [];
    for (const line of lines) {
      let trackIdx = setsPerTrack.findIndex((set) => !set.intersectsStrict(line));
      if (trackIdx === -1) {
        const maxTrackCount = 6;
        if (setsPerTrack.length >= maxTrackCount) {
          trackIdx = findMaxIdxBy(setsPerTrack, compareBy((set) => set.intersectWithRangeLength(line), numberComparator));
        } else {
          trackIdx = setsPerTrack.length;
          setsPerTrack.push(new OffsetRangeSet());
        }
      }
      setsPerTrack[trackIdx].addRange(line);
      trackPerLineIdx.push(trackIdx);
    }
    return new _LinesLayout(setsPerTrack.length, trackPerLineIdx);
  }
  constructor(_trackCount, trackPerLineIdx) {
    this._trackCount = _trackCount;
    this.trackPerLineIdx = trackPerLineIdx;
  }
  getTrack(lineIdx) {
    return this.trackPerLineIdx[lineIdx];
  }
  getTrackCount() {
    return this._trackCount;
  }
};
var MovedBlockOverlayWidget = class extends ViewZoneOverlayWidget {
  constructor(_editor, _viewZone, _move, _kind, _diffModel) {
    const root = h("div.diff-hidden-lines-widget");
    super(_editor, _viewZone, root.root);
    this._editor = _editor;
    this._move = _move;
    this._kind = _kind;
    this._diffModel = _diffModel;
    this._nodes = h("div.diff-moved-code-block", { style: { marginRight: "4px" } }, [
      h("div.text-content@textContent"),
      h("div.action-bar@actionBar")
    ]);
    root.root.appendChild(this._nodes.root);
    const editorLayout = observableFromEvent(this._editor.onDidLayoutChange, () => this._editor.getLayoutInfo());
    this._register(applyStyle(this._nodes.root, {
      paddingRight: editorLayout.map((l) => l.verticalScrollbarWidth)
    }));
    let text;
    if (_move.changes.length > 0) {
      text = this._kind === "original" ? localize("codeMovedToWithChanges", "Code moved with changes to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : localize("codeMovedFromWithChanges", "Code moved with changes from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
    } else {
      text = this._kind === "original" ? localize("codeMovedTo", "Code moved to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : localize("codeMovedFrom", "Code moved from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
    }
    const actionBar = this._register(new ActionBar(this._nodes.actionBar, {
      highlightToggledItems: true
    }));
    const caption = new Action("", text, "", false);
    actionBar.push(caption, { icon: false, label: true });
    const actionCompare = new Action("", "Compare", ThemeIcon.asClassName(Codicon.compareChanges), true, () => {
      this._editor.focus();
      this._diffModel.movedTextToCompare.set(this._diffModel.movedTextToCompare.get() === _move ? void 0 : this._move, void 0);
    });
    this._register(autorun((reader) => {
      const isActive = this._diffModel.movedTextToCompare.read(reader) === _move;
      actionCompare.checked = isActive;
    }));
    actionBar.push(actionCompare, { icon: false, label: true });
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditorDecorations.js
var DiffEditorDecorations = class extends Disposable {
  constructor(_editors, _diffModel, _options, widget) {
    super();
    this._editors = _editors;
    this._diffModel = _diffModel;
    this._options = _options;
    this._decorations = derived(this, (reader) => {
      var _a;
      const diff = (_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.diff.read(reader);
      if (!diff) {
        return null;
      }
      const movedTextToCompare = this._diffModel.read(reader).movedTextToCompare.read(reader);
      const renderIndicators = this._options.renderIndicators.read(reader);
      const showEmptyDecorations = this._options.showEmptyDecorations.read(reader);
      const originalDecorations = [];
      const modifiedDecorations = [];
      if (!movedTextToCompare) {
        for (const m of diff.mappings) {
          if (!m.lineRangeMapping.original.isEmpty) {
            originalDecorations.push({ range: m.lineRangeMapping.original.toInclusiveRange(), options: renderIndicators ? diffLineDeleteDecorationBackgroundWithIndicator : diffLineDeleteDecorationBackground });
          }
          if (!m.lineRangeMapping.modified.isEmpty) {
            modifiedDecorations.push({ range: m.lineRangeMapping.modified.toInclusiveRange(), options: renderIndicators ? diffLineAddDecorationBackgroundWithIndicator : diffLineAddDecorationBackground });
          }
          if (m.lineRangeMapping.modified.isEmpty || m.lineRangeMapping.original.isEmpty) {
            if (!m.lineRangeMapping.original.isEmpty) {
              originalDecorations.push({ range: m.lineRangeMapping.original.toInclusiveRange(), options: diffWholeLineDeleteDecoration });
            }
            if (!m.lineRangeMapping.modified.isEmpty) {
              modifiedDecorations.push({ range: m.lineRangeMapping.modified.toInclusiveRange(), options: diffWholeLineAddDecoration });
            }
          } else {
            for (const i of m.lineRangeMapping.innerChanges || []) {
              if (m.lineRangeMapping.original.contains(i.originalRange.startLineNumber)) {
                originalDecorations.push({ range: i.originalRange, options: i.originalRange.isEmpty() && showEmptyDecorations ? diffDeleteDecorationEmpty : diffDeleteDecoration });
              }
              if (m.lineRangeMapping.modified.contains(i.modifiedRange.startLineNumber)) {
                modifiedDecorations.push({ range: i.modifiedRange, options: i.modifiedRange.isEmpty() && showEmptyDecorations ? diffAddDecorationEmpty : diffAddDecoration });
              }
            }
          }
        }
      }
      if (movedTextToCompare) {
        for (const m of movedTextToCompare.changes) {
          const fullRangeOriginal = m.original.toInclusiveRange();
          if (fullRangeOriginal) {
            originalDecorations.push({ range: fullRangeOriginal, options: renderIndicators ? diffLineDeleteDecorationBackgroundWithIndicator : diffLineDeleteDecorationBackground });
          }
          const fullRangeModified = m.modified.toInclusiveRange();
          if (fullRangeModified) {
            modifiedDecorations.push({ range: fullRangeModified, options: renderIndicators ? diffLineAddDecorationBackgroundWithIndicator : diffLineAddDecorationBackground });
          }
          for (const i of m.innerChanges || []) {
            originalDecorations.push({ range: i.originalRange, options: diffDeleteDecoration });
            modifiedDecorations.push({ range: i.modifiedRange, options: diffAddDecoration });
          }
        }
      }
      const activeMovedText = this._diffModel.read(reader).activeMovedText.read(reader);
      for (const m of diff.movedTexts) {
        originalDecorations.push({
          range: m.lineRangeMapping.original.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedOriginal" + (m === activeMovedText ? " currentMove" : ""),
            blockPadding: [MovedBlocksLinesPart.movedCodeBlockPadding, 0, MovedBlocksLinesPart.movedCodeBlockPadding, MovedBlocksLinesPart.movedCodeBlockPadding]
          }
        });
        modifiedDecorations.push({
          range: m.lineRangeMapping.modified.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedModified" + (m === activeMovedText ? " currentMove" : ""),
            blockPadding: [4, 0, 4, 4]
          }
        });
      }
      return { originalDecorations, modifiedDecorations };
    });
    this._register(new RevertButtonsFeature(_editors, _diffModel, _options, widget));
    this._register(applyObservableDecorations(this._editors.original, this._decorations.map((d) => (d === null || d === void 0 ? void 0 : d.originalDecorations) || [])));
    this._register(applyObservableDecorations(this._editors.modified, this._decorations.map((d) => (d === null || d === void 0 ? void 0 : d.modifiedDecorations) || [])));
  }
};
var RevertButtonsFeature = class extends Disposable {
  constructor(_editors, _diffModel, _options, _widget) {
    super();
    this._editors = _editors;
    this._diffModel = _diffModel;
    this._options = _options;
    this._widget = _widget;
    const emptyArr = [];
    const selectedDiffs = derived(this, (reader) => {
      const model = this._diffModel.read(reader);
      const diff = model === null || model === void 0 ? void 0 : model.diff.read(reader);
      if (!diff) {
        return emptyArr;
      }
      const selections = this._editors.modifiedSelections.read(reader);
      if (selections.every((s) => s.isEmpty())) {
        return emptyArr;
      }
      const lineRanges = new LineRangeSet(selections.map((s) => LineRange.fromRangeInclusive(s)));
      const mappings = diff.mappings.filter((m) => m.lineRangeMapping.innerChanges && lineRanges.intersects(m.lineRangeMapping.modified));
      const result = mappings.map((mapping) => ({
        mapping,
        rangeMappings: mapping.lineRangeMapping.innerChanges.filter((c) => selections.some((s) => Range.areIntersecting(c.modifiedRange, s)))
      }));
      if (result.length === 0 || result.every((r) => r.rangeMappings.length === 0)) {
        return emptyArr;
      }
      return result;
    });
    this._register(autorunWithStore((reader, store) => {
      const model = this._diffModel.read(reader);
      const diff = model === null || model === void 0 ? void 0 : model.diff.read(reader);
      if (!model || !diff) {
        return;
      }
      const movedTextToCompare = this._diffModel.read(reader).movedTextToCompare.read(reader);
      if (movedTextToCompare) {
        return;
      }
      if (!this._options.shouldRenderRevertArrows.read(reader)) {
        return;
      }
      const glyphWidgetsModified = [];
      const selectedDiffs_ = selectedDiffs.read(reader);
      const diffsSet = new Set(selectedDiffs_.map((d) => d.mapping));
      if (selectedDiffs_.length > 0) {
        const selections = this._editors.modifiedSelections.read(reader);
        const btn = new RevertButton(selections[selections.length - 1].positionLineNumber, this._widget, selectedDiffs_.flatMap((d) => d.rangeMappings), true);
        this._editors.modified.addGlyphMarginWidget(btn);
        glyphWidgetsModified.push(btn);
      }
      for (const m of diff.mappings) {
        if (diffsSet.has(m)) {
          continue;
        }
        if (!m.lineRangeMapping.modified.isEmpty && m.lineRangeMapping.innerChanges) {
          const btn = new RevertButton(m.lineRangeMapping.modified.startLineNumber, this._widget, m.lineRangeMapping.innerChanges, false);
          this._editors.modified.addGlyphMarginWidget(btn);
          glyphWidgetsModified.push(btn);
        }
      }
      store.add(toDisposable(() => {
        for (const w of glyphWidgetsModified) {
          this._editors.modified.removeGlyphMarginWidget(w);
        }
      }));
    }));
  }
};
var RevertButton = class _RevertButton {
  getId() {
    return this._id;
  }
  constructor(_lineNumber, _widget, _diffs, _selection) {
    this._lineNumber = _lineNumber;
    this._widget = _widget;
    this._diffs = _diffs;
    this._selection = _selection;
    this._id = `revertButton${_RevertButton.counter++}`;
    this._domNode = h("div.revertButton", {
      title: this._selection ? localize("revertSelectedChanges", "Revert Selected Changes") : localize("revertChange", "Revert Change")
    }, [renderIcon(Codicon.arrowRight)]).root;
    this._domNode.onmousedown = (e) => {
      if (e.button !== 2) {
        e.stopPropagation();
        e.preventDefault();
      }
    };
    this._domNode.onmouseup = (e) => {
      e.stopPropagation();
      e.preventDefault();
    };
    this._domNode.onclick = (e) => {
      this._widget.revertRangeMappings(this._diffs);
      e.stopPropagation();
      e.preventDefault();
    };
  }
  /**
   * Get the dom node of the glyph widget.
   */
  getDomNode() {
    return this._domNode;
  }
  /**
   * Get the placement of the glyph widget.
   */
  getPosition() {
    return {
      lane: GlyphMarginLane.Right,
      range: {
        startColumn: 1,
        startLineNumber: this._lineNumber,
        endColumn: 1,
        endLineNumber: this._lineNumber
      },
      zIndex: 10001
    };
  }
};
RevertButton.counter = 0;

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditorSash.js
var DiffEditorSash = class extends Disposable {
  constructor(_options, _domNode, _dimensions, _sashes) {
    super();
    this._options = _options;
    this._domNode = _domNode;
    this._dimensions = _dimensions;
    this._sashes = _sashes;
    this._sashRatio = observableValue(this, void 0);
    this.sashLeft = derived(this, (reader) => {
      var _a;
      const ratio = (_a = this._sashRatio.read(reader)) !== null && _a !== void 0 ? _a : this._options.splitViewDefaultRatio.read(reader);
      return this._computeSashLeft(ratio, reader);
    });
    this._sash = this._register(new Sash(this._domNode, {
      getVerticalSashTop: (_sash) => 0,
      getVerticalSashLeft: (_sash) => this.sashLeft.get(),
      getVerticalSashHeight: (_sash) => this._dimensions.height.get()
    }, {
      orientation: 0
      /* Orientation.VERTICAL */
    }));
    this._startSashPosition = void 0;
    this._register(this._sash.onDidStart(() => {
      this._startSashPosition = this.sashLeft.get();
    }));
    this._register(this._sash.onDidChange((e) => {
      const contentWidth = this._dimensions.width.get();
      const sashPosition = this._computeSashLeft((this._startSashPosition + (e.currentX - e.startX)) / contentWidth, void 0);
      this._sashRatio.set(sashPosition / contentWidth, void 0);
    }));
    this._register(this._sash.onDidEnd(() => this._sash.layout()));
    this._register(this._sash.onDidReset(() => this._sashRatio.set(void 0, void 0)));
    this._register(autorun((reader) => {
      const sashes = this._sashes.read(reader);
      if (sashes) {
        this._sash.orthogonalEndSash = sashes.bottom;
      }
    }));
    this._register(autorun((reader) => {
      const enabled = this._options.enableSplitViewResizing.read(reader);
      this._sash.state = enabled ? 3 : 0;
      this.sashLeft.read(reader);
      this._dimensions.height.read(reader);
      this._sash.layout();
    }));
  }
  /** @pure */
  _computeSashLeft(desiredRatio, reader) {
    const contentWidth = this._dimensions.width.read(reader);
    const midPoint = Math.floor(this._options.splitViewDefaultRatio.read(reader) * contentWidth);
    const sashLeft = this._options.enableSplitViewResizing.read(reader) ? Math.floor(desiredRatio * contentWidth) : midPoint;
    const MINIMUM_EDITOR_WIDTH = 100;
    if (contentWidth <= MINIMUM_EDITOR_WIDTH * 2) {
      return midPoint;
    }
    if (sashLeft < MINIMUM_EDITOR_WIDTH) {
      return MINIMUM_EDITOR_WIDTH;
    }
    if (sashLeft > contentWidth - MINIMUM_EDITOR_WIDTH) {
      return contentWidth - MINIMUM_EDITOR_WIDTH;
    }
    return sashLeft;
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/outlineModel.js
var TreeElement = class {
  remove() {
    var _a;
    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.delete(this.id);
  }
  static findId(candidate, container) {
    let candidateId;
    if (typeof candidate === "string") {
      candidateId = `${container.id}/${candidate}`;
    } else {
      candidateId = `${container.id}/${candidate.name}`;
      if (container.children.get(candidateId) !== void 0) {
        candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;
      }
    }
    let id = candidateId;
    for (let i = 0; container.children.get(id) !== void 0; i++) {
      id = `${candidateId}_${i}`;
    }
    return id;
  }
  static empty(element) {
    return element.children.size === 0;
  }
};
var OutlineElement = class extends TreeElement {
  constructor(id, parent, symbol) {
    super();
    this.id = id;
    this.parent = parent;
    this.symbol = symbol;
    this.children = /* @__PURE__ */ new Map();
  }
};
var OutlineGroup = class extends TreeElement {
  constructor(id, parent, label, order) {
    super();
    this.id = id;
    this.parent = parent;
    this.label = label;
    this.order = order;
    this.children = /* @__PURE__ */ new Map();
  }
};
var OutlineModel = class _OutlineModel extends TreeElement {
  static create(registry, textModel, token) {
    const cts = new CancellationTokenSource(token);
    const result = new _OutlineModel(textModel.uri);
    const provider = registry.ordered(textModel);
    const promises = provider.map((provider2, index) => {
      var _a;
      const id = TreeElement.findId(`provider_${index}`, result);
      const group = new OutlineGroup(id, result, (_a = provider2.displayName) !== null && _a !== void 0 ? _a : "Unknown Outline Provider", index);
      return Promise.resolve(provider2.provideDocumentSymbols(textModel, cts.token)).then((result2) => {
        for (const info of result2 || []) {
          _OutlineModel._makeOutlineElement(info, group);
        }
        return group;
      }, (err) => {
        onUnexpectedExternalError(err);
        return group;
      }).then((group2) => {
        if (!TreeElement.empty(group2)) {
          result._groups.set(id, group2);
        } else {
          group2.remove();
        }
      });
    });
    const listener = registry.onDidChange(() => {
      const newProvider = registry.ordered(textModel);
      if (!equals(newProvider, provider)) {
        cts.cancel();
      }
    });
    return Promise.all(promises).then(() => {
      if (cts.token.isCancellationRequested && !token.isCancellationRequested) {
        return _OutlineModel.create(registry, textModel, token);
      } else {
        return result._compact();
      }
    }).finally(() => {
      cts.dispose();
      listener.dispose();
    });
  }
  static _makeOutlineElement(info, container) {
    const id = TreeElement.findId(info, container);
    const res = new OutlineElement(id, container, info);
    if (info.children) {
      for (const childInfo of info.children) {
        _OutlineModel._makeOutlineElement(childInfo, res);
      }
    }
    container.children.set(res.id, res);
  }
  constructor(uri) {
    super();
    this.uri = uri;
    this.id = "root";
    this.parent = void 0;
    this._groups = /* @__PURE__ */ new Map();
    this.children = /* @__PURE__ */ new Map();
    this.id = "root";
    this.parent = void 0;
  }
  _compact() {
    let count = 0;
    for (const [key, group] of this._groups) {
      if (group.children.size === 0) {
        this._groups.delete(key);
      } else {
        count += 1;
      }
    }
    if (count !== 1) {
      this.children = this._groups;
    } else {
      const group = Iterable.first(this._groups.values());
      for (const [, child] of group.children) {
        child.parent = this;
        this.children.set(child.id, child);
      }
    }
    return this;
  }
  getTopLevelSymbols() {
    const roots = [];
    for (const child of this.children.values()) {
      if (child instanceof OutlineElement) {
        roots.push(child.symbol);
      } else {
        roots.push(...Iterable.map(child.children.values(), (child2) => child2.symbol));
      }
    }
    return roots.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
  }
  asListOfDocumentSymbols() {
    const roots = this.getTopLevelSymbols();
    const bucket = [];
    _OutlineModel._flattenDocumentSymbols(bucket, roots, "");
    return bucket.sort((a, b) => Position.compare(Range.getStartPosition(a.range), Range.getStartPosition(b.range)) || Position.compare(Range.getEndPosition(b.range), Range.getEndPosition(a.range)));
  }
  static _flattenDocumentSymbols(bucket, entries, overrideContainerLabel) {
    for (const entry of entries) {
      bucket.push({
        kind: entry.kind,
        tags: entry.tags,
        name: entry.name,
        detail: entry.detail,
        containerName: entry.containerName || overrideContainerLabel,
        range: entry.range,
        selectionRange: entry.selectionRange,
        children: void 0
        // we flatten it...
      });
      if (entry.children) {
        _OutlineModel._flattenDocumentSymbols(bucket, entry.children, entry.name);
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/hideUnchangedRegionsFeature.js
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var HideUnchangedRegionsFeature = class HideUnchangedRegionsFeature2 extends Disposable {
  get isUpdatingHiddenAreas() {
    return this._isUpdatingHiddenAreas;
  }
  constructor(_editors, _diffModel, _options, _languageFeaturesService) {
    super();
    this._editors = _editors;
    this._diffModel = _diffModel;
    this._options = _options;
    this._languageFeaturesService = _languageFeaturesService;
    this._modifiedOutlineSource = derivedDisposable(this, (reader) => {
      const m = this._editors.modifiedModel.read(reader);
      return !m ? void 0 : new OutlineSource(this._languageFeaturesService, m);
    });
    this._isUpdatingHiddenAreas = false;
    this._register(this._editors.original.onDidChangeCursorPosition((e) => {
      if (e.reason === 3) {
        const m = this._diffModel.get();
        transaction((tx) => {
          for (const s of this._editors.original.getSelections() || []) {
            m === null || m === void 0 ? void 0 : m.ensureOriginalLineIsVisible(s.getStartPosition().lineNumber, tx);
            m === null || m === void 0 ? void 0 : m.ensureOriginalLineIsVisible(s.getEndPosition().lineNumber, tx);
          }
        });
      }
    }));
    this._register(this._editors.modified.onDidChangeCursorPosition((e) => {
      if (e.reason === 3) {
        const m = this._diffModel.get();
        transaction((tx) => {
          for (const s of this._editors.modified.getSelections() || []) {
            m === null || m === void 0 ? void 0 : m.ensureModifiedLineIsVisible(s.getStartPosition().lineNumber, tx);
            m === null || m === void 0 ? void 0 : m.ensureModifiedLineIsVisible(s.getEndPosition().lineNumber, tx);
          }
        });
      }
    }));
    const unchangedRegions = this._diffModel.map((m, reader) => {
      var _a, _b;
      return ((_a = m === null || m === void 0 ? void 0 : m.diff.read(reader)) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0 ? [] : (_b = m === null || m === void 0 ? void 0 : m.unchangedRegions.read(reader)) !== null && _b !== void 0 ? _b : [];
    });
    this.viewZones = derivedWithStore(this, (reader, store) => {
      const modifiedOutlineSource = this._modifiedOutlineSource.read(reader);
      if (!modifiedOutlineSource) {
        return { origViewZones: [], modViewZones: [] };
      }
      const origViewZones = [];
      const modViewZones = [];
      const sideBySide = this._options.renderSideBySide.read(reader);
      const curUnchangedRegions = unchangedRegions.read(reader);
      for (const r of curUnchangedRegions) {
        if (r.shouldHideControls(reader)) {
          continue;
        }
        {
          const d = derived(this, (reader2) => (
            /** @description hiddenOriginalRangeStart */
            r.getHiddenOriginalRange(reader2).startLineNumber - 1
          ));
          const origVz = new PlaceholderViewZone(d, 24);
          origViewZones.push(origVz);
          store.add(new CollapsedCodeOverlayWidget(this._editors.original, origVz, r, r.originalUnchangedRange, !sideBySide, modifiedOutlineSource, (l) => this._diffModel.get().ensureModifiedLineIsVisible(l, void 0), this._options));
        }
        {
          const d = derived(this, (reader2) => (
            /** @description hiddenModifiedRangeStart */
            r.getHiddenModifiedRange(reader2).startLineNumber - 1
          ));
          const modViewZone = new PlaceholderViewZone(d, 24);
          modViewZones.push(modViewZone);
          store.add(new CollapsedCodeOverlayWidget(this._editors.modified, modViewZone, r, r.modifiedUnchangedRange, false, modifiedOutlineSource, (l) => this._diffModel.get().ensureModifiedLineIsVisible(l, void 0), this._options));
        }
      }
      return { origViewZones, modViewZones };
    });
    const unchangedLinesDecoration = {
      description: "unchanged lines",
      className: "diff-unchanged-lines",
      isWholeLine: true
    };
    const unchangedLinesDecorationShow = {
      description: "Fold Unchanged",
      glyphMarginHoverMessage: new MarkdownString(void 0, { isTrusted: true, supportThemeIcons: true }).appendMarkdown(localize("foldUnchanged", "Fold Unchanged Region")),
      glyphMarginClassName: "fold-unchanged " + ThemeIcon.asClassName(Codicon.fold),
      zIndex: 10001
    };
    this._register(applyObservableDecorations(this._editors.original, derived(this, (reader) => {
      const curUnchangedRegions = unchangedRegions.read(reader);
      const result = curUnchangedRegions.map((r) => ({
        range: r.originalUnchangedRange.toInclusiveRange(),
        options: unchangedLinesDecoration
      }));
      for (const r of curUnchangedRegions) {
        if (r.shouldHideControls(reader)) {
          result.push({
            range: Range.fromPositions(new Position(r.originalLineNumber, 1)),
            options: unchangedLinesDecorationShow
          });
        }
      }
      return result;
    })));
    this._register(applyObservableDecorations(this._editors.modified, derived(this, (reader) => {
      const curUnchangedRegions = unchangedRegions.read(reader);
      const result = curUnchangedRegions.map((r) => ({
        range: r.modifiedUnchangedRange.toInclusiveRange(),
        options: unchangedLinesDecoration
      }));
      for (const r of curUnchangedRegions) {
        if (r.shouldHideControls(reader)) {
          result.push({
            range: LineRange.ofLength(r.modifiedLineNumber, 1).toInclusiveRange(),
            options: unchangedLinesDecorationShow
          });
        }
      }
      return result;
    })));
    this._register(autorun((reader) => {
      const curUnchangedRegions = unchangedRegions.read(reader);
      this._isUpdatingHiddenAreas = true;
      try {
        this._editors.original.setHiddenAreas(curUnchangedRegions.map((r) => r.getHiddenOriginalRange(reader).toInclusiveRange()).filter(isDefined));
        this._editors.modified.setHiddenAreas(curUnchangedRegions.map((r) => r.getHiddenModifiedRange(reader).toInclusiveRange()).filter(isDefined));
      } finally {
        this._isUpdatingHiddenAreas = false;
      }
    }));
    this._register(this._editors.modified.onMouseUp((event) => {
      var _a;
      if (!event.event.rightButton && event.target.position && ((_a = event.target.element) === null || _a === void 0 ? void 0 : _a.className.includes("fold-unchanged"))) {
        const lineNumber = event.target.position.lineNumber;
        const model = this._diffModel.get();
        if (!model) {
          return;
        }
        const region = model.unchangedRegions.get().find((r) => r.modifiedUnchangedRange.includes(lineNumber));
        if (!region) {
          return;
        }
        region.collapseAll(void 0);
        event.event.stopPropagation();
        event.event.preventDefault();
      }
    }));
    this._register(this._editors.original.onMouseUp((event) => {
      var _a;
      if (!event.event.rightButton && event.target.position && ((_a = event.target.element) === null || _a === void 0 ? void 0 : _a.className.includes("fold-unchanged"))) {
        const lineNumber = event.target.position.lineNumber;
        const model = this._diffModel.get();
        if (!model) {
          return;
        }
        const region = model.unchangedRegions.get().find((r) => r.originalUnchangedRange.includes(lineNumber));
        if (!region) {
          return;
        }
        region.collapseAll(void 0);
        event.event.stopPropagation();
        event.event.preventDefault();
      }
    }));
  }
};
HideUnchangedRegionsFeature = __decorate25([
  __param23(3, ILanguageFeaturesService)
], HideUnchangedRegionsFeature);
var CollapsedCodeOverlayWidget = class extends ViewZoneOverlayWidget {
  constructor(_editor, _viewZone, _unchangedRegion, _unchangedRegionRange, _hide, _modifiedOutlineSource, _revealModifiedHiddenLine, _options) {
    const root = h("div.diff-hidden-lines-widget");
    super(_editor, _viewZone, root.root);
    this._editor = _editor;
    this._unchangedRegion = _unchangedRegion;
    this._unchangedRegionRange = _unchangedRegionRange;
    this._hide = _hide;
    this._modifiedOutlineSource = _modifiedOutlineSource;
    this._revealModifiedHiddenLine = _revealModifiedHiddenLine;
    this._options = _options;
    this._nodes = h("div.diff-hidden-lines", [
      h("div.top@top", { title: localize("diff.hiddenLines.top", "Click or drag to show more above") }),
      h("div.center@content", { style: { display: "flex" } }, [
        h("div@first", { style: { display: "flex", justifyContent: "center", alignItems: "center", flexShrink: "0" } }, [$("a", { title: localize("showUnchangedRegion", "Show Unchanged Region"), role: "button", onclick: () => {
          this._unchangedRegion.showAll(void 0);
        } }, ...renderLabelWithIcons("$(unfold)"))]),
        h("div@others", { style: { display: "flex", justifyContent: "center", alignItems: "center" } })
      ]),
      h("div.bottom@bottom", { title: localize("diff.bottom", "Click or drag to show more below"), role: "button" })
    ]);
    root.root.appendChild(this._nodes.root);
    const layoutInfo = observableFromEvent(this._editor.onDidLayoutChange, () => this._editor.getLayoutInfo());
    if (!this._hide) {
      this._register(applyStyle(this._nodes.first, { width: layoutInfo.map((l) => l.contentLeft) }));
    } else {
      reset(this._nodes.first);
    }
    this._register(autorun((reader) => {
      const isFullyRevealed = this._unchangedRegion.visibleLineCountTop.read(reader) + this._unchangedRegion.visibleLineCountBottom.read(reader) === this._unchangedRegion.lineCount;
      this._nodes.bottom.classList.toggle("canMoveTop", !isFullyRevealed);
      this._nodes.bottom.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(reader) > 0);
      this._nodes.top.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(reader) > 0);
      this._nodes.top.classList.toggle("canMoveBottom", !isFullyRevealed);
      const isDragged = this._unchangedRegion.isDragged.read(reader);
      const domNode = this._editor.getDomNode();
      if (domNode) {
        domNode.classList.toggle("draggingUnchangedRegion", !!isDragged);
        if (isDragged === "top") {
          domNode.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(reader) > 0);
          domNode.classList.toggle("canMoveBottom", !isFullyRevealed);
        } else if (isDragged === "bottom") {
          domNode.classList.toggle("canMoveTop", !isFullyRevealed);
          domNode.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(reader) > 0);
        } else {
          domNode.classList.toggle("canMoveTop", false);
          domNode.classList.toggle("canMoveBottom", false);
        }
      }
    }));
    const editor2 = this._editor;
    this._register(addDisposableListener(this._nodes.top, "mousedown", (e) => {
      if (e.button !== 0) {
        return;
      }
      this._nodes.top.classList.toggle("dragging", true);
      this._nodes.root.classList.toggle("dragging", true);
      e.preventDefault();
      const startTop = e.clientY;
      let didMove = false;
      const cur = this._unchangedRegion.visibleLineCountTop.get();
      this._unchangedRegion.isDragged.set("top", void 0);
      const window = getWindow(this._nodes.top);
      const mouseMoveListener = addDisposableListener(window, "mousemove", (e2) => {
        const currentTop = e2.clientY;
        const delta = currentTop - startTop;
        didMove = didMove || Math.abs(delta) > 2;
        const lineDelta = Math.round(delta / editor2.getOption(
          66
          /* EditorOption.lineHeight */
        ));
        const newVal = Math.max(0, Math.min(cur + lineDelta, this._unchangedRegion.getMaxVisibleLineCountTop()));
        this._unchangedRegion.visibleLineCountTop.set(newVal, void 0);
      });
      const mouseUpListener = addDisposableListener(window, "mouseup", (e2) => {
        if (!didMove) {
          this._unchangedRegion.showMoreAbove(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0);
        }
        this._nodes.top.classList.toggle("dragging", false);
        this._nodes.root.classList.toggle("dragging", false);
        this._unchangedRegion.isDragged.set(void 0, void 0);
        mouseMoveListener.dispose();
        mouseUpListener.dispose();
      });
    }));
    this._register(addDisposableListener(this._nodes.bottom, "mousedown", (e) => {
      if (e.button !== 0) {
        return;
      }
      this._nodes.bottom.classList.toggle("dragging", true);
      this._nodes.root.classList.toggle("dragging", true);
      e.preventDefault();
      const startTop = e.clientY;
      let didMove = false;
      const cur = this._unchangedRegion.visibleLineCountBottom.get();
      this._unchangedRegion.isDragged.set("bottom", void 0);
      const window = getWindow(this._nodes.bottom);
      const mouseMoveListener = addDisposableListener(window, "mousemove", (e2) => {
        const currentTop = e2.clientY;
        const delta = currentTop - startTop;
        didMove = didMove || Math.abs(delta) > 2;
        const lineDelta = Math.round(delta / editor2.getOption(
          66
          /* EditorOption.lineHeight */
        ));
        const newVal = Math.max(0, Math.min(cur - lineDelta, this._unchangedRegion.getMaxVisibleLineCountBottom()));
        const top = editor2.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        this._unchangedRegion.visibleLineCountBottom.set(newVal, void 0);
        const top2 = editor2.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        editor2.setScrollTop(editor2.getScrollTop() + (top2 - top));
      });
      const mouseUpListener = addDisposableListener(window, "mouseup", (e2) => {
        this._unchangedRegion.isDragged.set(void 0, void 0);
        if (!didMove) {
          const top = editor2.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          this._unchangedRegion.showMoreBelow(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0);
          const top2 = editor2.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          editor2.setScrollTop(editor2.getScrollTop() + (top2 - top));
        }
        this._nodes.bottom.classList.toggle("dragging", false);
        this._nodes.root.classList.toggle("dragging", false);
        mouseMoveListener.dispose();
        mouseUpListener.dispose();
      });
    }));
    this._register(autorun((reader) => {
      const children = [];
      if (!this._hide) {
        const lineCount = _unchangedRegion.getHiddenModifiedRange(reader).length;
        const linesHiddenText = localize("hiddenLines", "{0} hidden lines", lineCount);
        const span = $("span", { title: localize("diff.hiddenLines.expandAll", "Double click to unfold") }, linesHiddenText);
        span.addEventListener("dblclick", (e) => {
          if (e.button !== 0) {
            return;
          }
          e.preventDefault();
          this._unchangedRegion.showAll(void 0);
        });
        children.push(span);
        const range2 = this._unchangedRegion.getHiddenModifiedRange(reader);
        const items = this._modifiedOutlineSource.getBreadcrumbItems(range2, reader);
        if (items.length > 0) {
          children.push($("span", void 0, "  |  "));
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const icon = SymbolKinds.toIcon(item.kind);
            const divItem = h("div.breadcrumb-item", {
              style: { display: "flex", alignItems: "center" }
            }, [
              renderIcon(icon),
              " ",
              item.name,
              ...i === items.length - 1 ? [] : [renderIcon(Codicon.chevronRight)]
            ]).root;
            children.push(divItem);
            divItem.onclick = () => {
              this._revealModifiedHiddenLine(item.startLineNumber);
            };
          }
        }
      }
      reset(this._nodes.others, ...children);
    }));
  }
};
var OutlineSource = class OutlineSource2 extends Disposable {
  constructor(_languageFeaturesService, _textModel) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
    this._textModel = _textModel;
    this._currentModel = observableValue(this, void 0);
    const documentSymbolProviderChanged = observableSignalFromEvent("documentSymbolProvider.onDidChange", this._languageFeaturesService.documentSymbolProvider.onDidChange);
    const textModelChanged = observableSignalFromEvent("_textModel.onDidChangeContent", Event.debounce((e) => this._textModel.onDidChangeContent(e), () => void 0, 100));
    this._register(autorunWithStore(async (reader, store) => {
      documentSymbolProviderChanged.read(reader);
      textModelChanged.read(reader);
      const src = store.add(new DisposableCancellationTokenSource());
      const model = await OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, this._textModel, src.token);
      if (store.isDisposed) {
        return;
      }
      this._currentModel.set(model, void 0);
    }));
  }
  getBreadcrumbItems(startRange, reader) {
    const m = this._currentModel.read(reader);
    if (!m) {
      return [];
    }
    const symbols = m.asListOfDocumentSymbols().filter((s) => startRange.contains(s.range.startLineNumber) && !startRange.contains(s.range.endLineNumber));
    symbols.sort(reverseOrder(compareBy((s) => s.range.endLineNumber - s.range.startLineNumber, numberComparator)));
    return symbols.map((s) => ({ name: s.name, kind: s.kind, startLineNumber: s.range.startLineNumber }));
  }
};
OutlineSource = __decorate25([
  __param23(0, ILanguageFeaturesService)
], OutlineSource);

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/workerBasedDocumentDiffProvider.js
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var WorkerBasedDocumentDiffProvider_1;
var WorkerBasedDocumentDiffProvider = WorkerBasedDocumentDiffProvider_1 = class WorkerBasedDocumentDiffProvider2 {
  constructor(options, editorWorkerService, telemetryService) {
    this.editorWorkerService = editorWorkerService;
    this.telemetryService = telemetryService;
    this.onDidChangeEventEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEventEmitter.event;
    this.diffAlgorithm = "advanced";
    this.diffAlgorithmOnDidChangeSubscription = void 0;
    this.setOptions(options);
  }
  dispose() {
    var _a;
    (_a = this.diffAlgorithmOnDidChangeSubscription) === null || _a === void 0 ? void 0 : _a.dispose();
  }
  async computeDiff(original, modified, options, cancellationToken) {
    var _a, _b;
    if (typeof this.diffAlgorithm !== "string") {
      return this.diffAlgorithm.computeDiff(original, modified, options, cancellationToken);
    }
    if (original.getLineCount() === 1 && original.getLineMaxColumn(1) === 1) {
      if (modified.getLineCount() === 1 && modified.getLineMaxColumn(1) === 1) {
        return {
          changes: [],
          identical: true,
          quitEarly: false,
          moves: []
        };
      }
      return {
        changes: [
          new DetailedLineRangeMapping(new LineRange(1, 2), new LineRange(1, modified.getLineCount() + 1), [
            new RangeMapping(original.getFullModelRange(), modified.getFullModelRange())
          ])
        ],
        identical: false,
        quitEarly: false,
        moves: []
      };
    }
    const uriKey = JSON.stringify([original.uri.toString(), modified.uri.toString()]);
    const context = JSON.stringify([original.id, modified.id, original.getAlternativeVersionId(), modified.getAlternativeVersionId(), JSON.stringify(options)]);
    const c = WorkerBasedDocumentDiffProvider_1.diffCache.get(uriKey);
    if (c && c.context === context) {
      return c.result;
    }
    const sw = StopWatch.create();
    const result = await this.editorWorkerService.computeDiff(original.uri, modified.uri, options, this.diffAlgorithm);
    const timeMs = sw.elapsed();
    this.telemetryService.publicLog2("diffEditor.computeDiff", {
      timeMs,
      timedOut: (_a = result === null || result === void 0 ? void 0 : result.quitEarly) !== null && _a !== void 0 ? _a : true,
      detectedMoves: options.computeMoves ? (_b = result === null || result === void 0 ? void 0 : result.moves.length) !== null && _b !== void 0 ? _b : 0 : -1
    });
    if (cancellationToken.isCancellationRequested) {
      return {
        changes: [],
        identical: false,
        quitEarly: true,
        moves: []
      };
    }
    if (!result) {
      throw new Error("no diff result available");
    }
    if (WorkerBasedDocumentDiffProvider_1.diffCache.size > 10) {
      WorkerBasedDocumentDiffProvider_1.diffCache.delete(WorkerBasedDocumentDiffProvider_1.diffCache.keys().next().value);
    }
    WorkerBasedDocumentDiffProvider_1.diffCache.set(uriKey, { result, context });
    return result;
  }
  setOptions(newOptions) {
    var _a;
    let didChange = false;
    if (newOptions.diffAlgorithm) {
      if (this.diffAlgorithm !== newOptions.diffAlgorithm) {
        (_a = this.diffAlgorithmOnDidChangeSubscription) === null || _a === void 0 ? void 0 : _a.dispose();
        this.diffAlgorithmOnDidChangeSubscription = void 0;
        this.diffAlgorithm = newOptions.diffAlgorithm;
        if (typeof newOptions.diffAlgorithm !== "string") {
          this.diffAlgorithmOnDidChangeSubscription = newOptions.diffAlgorithm.onDidChange(() => this.onDidChangeEventEmitter.fire());
        }
        didChange = true;
      }
    }
    if (didChange) {
      this.onDidChangeEventEmitter.fire();
    }
  }
};
WorkerBasedDocumentDiffProvider.diffCache = /* @__PURE__ */ new Map();
WorkerBasedDocumentDiffProvider = WorkerBasedDocumentDiffProvider_1 = __decorate26([
  __param24(1, IEditorWorkerService),
  __param24(2, ITelemetryService)
], WorkerBasedDocumentDiffProvider);

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffProviderFactoryService.js
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var IDiffProviderFactoryService = createDecorator("diffProviderFactoryService");
var DiffProviderFactoryService = class DiffProviderFactoryService2 {
  constructor(instantiationService) {
    this.instantiationService = instantiationService;
  }
  createDiffProvider(options) {
    return this.instantiationService.createInstance(WorkerBasedDocumentDiffProvider, options);
  }
};
DiffProviderFactoryService = __decorate27([
  __param25(0, IInstantiationService)
], DiffProviderFactoryService);
registerSingleton(
  IDiffProviderFactoryService,
  DiffProviderFactoryService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditorViewModel.js
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DiffEditorViewModel = class DiffEditorViewModel2 extends Disposable {
  setActiveMovedText(movedText) {
    this._activeMovedText.set(movedText, void 0);
  }
  constructor(model, _options, _diffProviderFactoryService) {
    super();
    this.model = model;
    this._options = _options;
    this._diffProviderFactoryService = _diffProviderFactoryService;
    this._isDiffUpToDate = observableValue(this, false);
    this.isDiffUpToDate = this._isDiffUpToDate;
    this._diff = observableValue(this, void 0);
    this.diff = this._diff;
    this._unchangedRegions = observableValue(this, { regions: [], originalDecorationIds: [], modifiedDecorationIds: [] });
    this.unchangedRegions = derived(this, (r) => {
      if (this._options.hideUnchangedRegions.read(r)) {
        return this._unchangedRegions.read(r).regions;
      } else {
        transaction((tx) => {
          for (const r2 of this._unchangedRegions.get().regions) {
            r2.collapseAll(tx);
          }
        });
        return [];
      }
    });
    this.movedTextToCompare = observableValue(this, void 0);
    this._activeMovedText = observableValue(this, void 0);
    this._hoveredMovedText = observableValue(this, void 0);
    this.activeMovedText = derived(this, (r) => {
      var _a, _b;
      return (_b = (_a = this.movedTextToCompare.read(r)) !== null && _a !== void 0 ? _a : this._hoveredMovedText.read(r)) !== null && _b !== void 0 ? _b : this._activeMovedText.read(r);
    });
    this._cancellationTokenSource = new CancellationTokenSource();
    this._diffProvider = derived(this, (reader) => {
      const diffProvider = this._diffProviderFactoryService.createDiffProvider({
        diffAlgorithm: this._options.diffAlgorithm.read(reader)
      });
      const onChangeSignal = observableSignalFromEvent("onDidChange", diffProvider.onDidChange);
      return {
        diffProvider,
        onChangeSignal
      };
    });
    this._register(toDisposable(() => this._cancellationTokenSource.cancel()));
    const contentChangedSignal = observableSignal("contentChangedSignal");
    const debouncer = this._register(new RunOnceScheduler(() => contentChangedSignal.trigger(void 0), 200));
    const updateUnchangedRegions = (result, tx, reader) => {
      const newUnchangedRegions = UnchangedRegion.fromDiffs(result.changes, model.original.getLineCount(), model.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(reader), this._options.hideUnchangedRegionsContextLineCount.read(reader));
      const lastUnchangedRegions = this._unchangedRegions.get();
      const lastUnchangedRegionsOrigRanges = lastUnchangedRegions.originalDecorationIds.map((id) => model.original.getDecorationRange(id)).map((r) => r ? LineRange.fromRange(r) : void 0);
      const lastUnchangedRegionsModRanges = lastUnchangedRegions.modifiedDecorationIds.map((id) => model.modified.getDecorationRange(id)).map((r) => r ? LineRange.fromRange(r) : void 0);
      const originalDecorationIds = model.original.deltaDecorations(lastUnchangedRegions.originalDecorationIds, newUnchangedRegions.map((r) => ({ range: r.originalUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
      const modifiedDecorationIds = model.modified.deltaDecorations(lastUnchangedRegions.modifiedDecorationIds, newUnchangedRegions.map((r) => ({ range: r.modifiedUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
      for (const r of newUnchangedRegions) {
        for (let i = 0; i < lastUnchangedRegions.regions.length; i++) {
          if (lastUnchangedRegionsOrigRanges[i] && r.originalUnchangedRange.intersectsStrict(lastUnchangedRegionsOrigRanges[i]) && lastUnchangedRegionsModRanges[i] && r.modifiedUnchangedRange.intersectsStrict(lastUnchangedRegionsModRanges[i])) {
            r.setHiddenModifiedRange(lastUnchangedRegions.regions[i].getHiddenModifiedRange(void 0), tx);
            break;
          }
        }
      }
      this._unchangedRegions.set({
        regions: newUnchangedRegions,
        originalDecorationIds,
        modifiedDecorationIds
      }, tx);
    };
    this._register(model.modified.onDidChangeContent((e) => {
      const diff = this._diff.get();
      if (diff) {
        const textEdits = TextEditInfo.fromModelContentChanges(e.changes);
        const result = applyModifiedEdits(this._lastDiff, textEdits, model.original, model.modified);
        if (result) {
          this._lastDiff = result;
          transaction((tx) => {
            this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);
            updateUnchangedRegions(result, tx);
            const currentSyncedMovedText = this.movedTextToCompare.get();
            this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find((m) => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : void 0, tx);
          });
        }
      }
      this._isDiffUpToDate.set(false, void 0);
      debouncer.schedule();
    }));
    this._register(model.original.onDidChangeContent((e) => {
      const diff = this._diff.get();
      if (diff) {
        const textEdits = TextEditInfo.fromModelContentChanges(e.changes);
        const result = applyOriginalEdits(this._lastDiff, textEdits, model.original, model.modified);
        if (result) {
          this._lastDiff = result;
          transaction((tx) => {
            this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);
            updateUnchangedRegions(result, tx);
            const currentSyncedMovedText = this.movedTextToCompare.get();
            this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find((m) => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : void 0, tx);
          });
        }
      }
      this._isDiffUpToDate.set(false, void 0);
      debouncer.schedule();
    }));
    this._register(autorunWithStore(async (reader, store) => {
      var _a, _b;
      this._options.hideUnchangedRegionsMinimumLineCount.read(reader);
      this._options.hideUnchangedRegionsContextLineCount.read(reader);
      debouncer.cancel();
      contentChangedSignal.read(reader);
      const documentDiffProvider = this._diffProvider.read(reader);
      documentDiffProvider.onChangeSignal.read(reader);
      readHotReloadableExport(DefaultLinesDiffComputer, reader);
      readHotReloadableExport(optimizeSequenceDiffs, reader);
      this._isDiffUpToDate.set(false, void 0);
      let originalTextEditInfos = [];
      store.add(model.original.onDidChangeContent((e) => {
        const edits = TextEditInfo.fromModelContentChanges(e.changes);
        originalTextEditInfos = combineTextEditInfos(originalTextEditInfos, edits);
      }));
      let modifiedTextEditInfos = [];
      store.add(model.modified.onDidChangeContent((e) => {
        const edits = TextEditInfo.fromModelContentChanges(e.changes);
        modifiedTextEditInfos = combineTextEditInfos(modifiedTextEditInfos, edits);
      }));
      let result = await documentDiffProvider.diffProvider.computeDiff(model.original, model.modified, {
        ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(reader),
        maxComputationTimeMs: this._options.maxComputationTimeMs.read(reader),
        computeMoves: this._options.showMoves.read(reader)
      }, this._cancellationTokenSource.token);
      if (this._cancellationTokenSource.token.isCancellationRequested) {
        return;
      }
      result = normalizeDocumentDiff(result, model.original, model.modified);
      result = (_a = applyOriginalEdits(result, originalTextEditInfos, model.original, model.modified)) !== null && _a !== void 0 ? _a : result;
      result = (_b = applyModifiedEdits(result, modifiedTextEditInfos, model.original, model.modified)) !== null && _b !== void 0 ? _b : result;
      transaction((tx) => {
        updateUnchangedRegions(result, tx);
        this._lastDiff = result;
        const state = DiffState.fromDiffResult(result);
        this._diff.set(state, tx);
        this._isDiffUpToDate.set(true, tx);
        const currentSyncedMovedText = this.movedTextToCompare.get();
        this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find((m) => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : void 0, tx);
      });
    }));
  }
  ensureModifiedLineIsVisible(lineNumber, tx) {
    var _a;
    if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {
      return;
    }
    const unchangedRegions = this._unchangedRegions.get().regions;
    for (const r of unchangedRegions) {
      if (r.getHiddenModifiedRange(void 0).contains(lineNumber)) {
        r.showModifiedLine(lineNumber, tx);
        return;
      }
    }
  }
  ensureOriginalLineIsVisible(lineNumber, tx) {
    var _a;
    if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {
      return;
    }
    const unchangedRegions = this._unchangedRegions.get().regions;
    for (const r of unchangedRegions) {
      if (r.getHiddenOriginalRange(void 0).contains(lineNumber)) {
        r.showOriginalLine(lineNumber, tx);
        return;
      }
    }
  }
  async waitForDiff() {
    await waitForState(this.isDiffUpToDate, (s) => s);
  }
  serializeState() {
    const regions = this._unchangedRegions.get();
    return {
      collapsedRegions: regions.regions.map((r) => ({ range: r.getHiddenModifiedRange(void 0).serialize() }))
    };
  }
  restoreSerializedState(state) {
    const ranges = state.collapsedRegions.map((r) => LineRange.deserialize(r.range));
    const regions = this._unchangedRegions.get();
    transaction((tx) => {
      for (const r of regions.regions) {
        for (const range2 of ranges) {
          if (r.modifiedUnchangedRange.intersect(range2)) {
            r.setHiddenModifiedRange(range2, tx);
            break;
          }
        }
      }
    });
  }
};
DiffEditorViewModel = __decorate28([
  __param26(2, IDiffProviderFactoryService)
], DiffEditorViewModel);
function normalizeDocumentDiff(diff, original, modified) {
  return {
    changes: diff.changes.map((c) => new DetailedLineRangeMapping(c.original, c.modified, c.innerChanges ? c.innerChanges.map((i) => normalizeRangeMapping(i, original, modified)) : void 0)),
    moves: diff.moves,
    identical: diff.identical,
    quitEarly: diff.quitEarly
  };
}
function normalizeRangeMapping(rangeMapping, original, modified) {
  let originalRange = rangeMapping.originalRange;
  let modifiedRange = rangeMapping.modifiedRange;
  if ((originalRange.endColumn !== 1 || modifiedRange.endColumn !== 1) && originalRange.endColumn === original.getLineMaxColumn(originalRange.endLineNumber) && modifiedRange.endColumn === modified.getLineMaxColumn(modifiedRange.endLineNumber) && originalRange.endLineNumber < original.getLineCount() && modifiedRange.endLineNumber < modified.getLineCount()) {
    originalRange = originalRange.setEndPosition(originalRange.endLineNumber + 1, 1);
    modifiedRange = modifiedRange.setEndPosition(modifiedRange.endLineNumber + 1, 1);
  }
  return new RangeMapping(originalRange, modifiedRange);
}
var DiffState = class _DiffState {
  static fromDiffResult(result) {
    return new _DiffState(result.changes.map((c) => new DiffMapping(c)), result.moves || [], result.identical, result.quitEarly);
  }
  constructor(mappings, movedTexts, identical, quitEarly) {
    this.mappings = mappings;
    this.movedTexts = movedTexts;
    this.identical = identical;
    this.quitEarly = quitEarly;
  }
};
var DiffMapping = class {
  constructor(lineRangeMapping) {
    this.lineRangeMapping = lineRangeMapping;
  }
};
var UnchangedRegion = class _UnchangedRegion {
  static fromDiffs(changes, originalLineCount, modifiedLineCount, minHiddenLineCount, minContext) {
    const inversedMappings = DetailedLineRangeMapping.inverse(changes, originalLineCount, modifiedLineCount);
    const result = [];
    for (const mapping of inversedMappings) {
      let origStart = mapping.original.startLineNumber;
      let modStart = mapping.modified.startLineNumber;
      let length = mapping.original.length;
      const atStart = origStart === 1 && modStart === 1;
      const atEnd = origStart + length === originalLineCount + 1 && modStart + length === modifiedLineCount + 1;
      if ((atStart || atEnd) && length >= minContext + minHiddenLineCount) {
        if (atStart && !atEnd) {
          length -= minContext;
        }
        if (atEnd && !atStart) {
          origStart += minContext;
          modStart += minContext;
          length -= minContext;
        }
        result.push(new _UnchangedRegion(origStart, modStart, length, 0, 0));
      } else if (length >= minContext * 2 + minHiddenLineCount) {
        origStart += minContext;
        modStart += minContext;
        length -= minContext * 2;
        result.push(new _UnchangedRegion(origStart, modStart, length, 0, 0));
      }
    }
    return result;
  }
  get originalUnchangedRange() {
    return LineRange.ofLength(this.originalLineNumber, this.lineCount);
  }
  get modifiedUnchangedRange() {
    return LineRange.ofLength(this.modifiedLineNumber, this.lineCount);
  }
  constructor(originalLineNumber, modifiedLineNumber, lineCount, visibleLineCountTop, visibleLineCountBottom) {
    this.originalLineNumber = originalLineNumber;
    this.modifiedLineNumber = modifiedLineNumber;
    this.lineCount = lineCount;
    this._visibleLineCountTop = observableValue(this, 0);
    this.visibleLineCountTop = this._visibleLineCountTop;
    this._visibleLineCountBottom = observableValue(this, 0);
    this.visibleLineCountBottom = this._visibleLineCountBottom;
    this._shouldHideControls = derived(this, (reader) => (
      /** @description isVisible */
      this.visibleLineCountTop.read(reader) + this.visibleLineCountBottom.read(reader) === this.lineCount && !this.isDragged.read(reader)
    ));
    this.isDragged = observableValue(this, void 0);
    this._visibleLineCountTop.set(visibleLineCountTop, void 0);
    this._visibleLineCountBottom.set(visibleLineCountBottom, void 0);
  }
  shouldHideControls(reader) {
    return this._shouldHideControls.read(reader);
  }
  getHiddenOriginalRange(reader) {
    return LineRange.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));
  }
  getHiddenModifiedRange(reader) {
    return LineRange.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));
  }
  setHiddenModifiedRange(range2, tx) {
    const visibleLineCountTop = range2.startLineNumber - this.modifiedLineNumber;
    const visibleLineCountBottom = this.modifiedLineNumber + this.lineCount - range2.endLineNumberExclusive;
    this.setState(visibleLineCountTop, visibleLineCountBottom, tx);
  }
  getMaxVisibleLineCountTop() {
    return this.lineCount - this._visibleLineCountBottom.get();
  }
  getMaxVisibleLineCountBottom() {
    return this.lineCount - this._visibleLineCountTop.get();
  }
  showMoreAbove(count = 10, tx) {
    const maxVisibleLineCountTop = this.getMaxVisibleLineCountTop();
    this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + count, maxVisibleLineCountTop), tx);
  }
  showMoreBelow(count = 10, tx) {
    const maxVisibleLineCountBottom = this.lineCount - this._visibleLineCountTop.get();
    this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + count, maxVisibleLineCountBottom), tx);
  }
  showAll(tx) {
    this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), tx);
  }
  showModifiedLine(lineNumber, tx) {
    const top = lineNumber + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get());
    const bottom = this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount - lineNumber;
    if (top < bottom) {
      this._visibleLineCountTop.set(this._visibleLineCountTop.get() + top, tx);
    } else {
      this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + bottom, tx);
    }
  }
  showOriginalLine(lineNumber, tx) {
    const top = lineNumber - this.originalLineNumber;
    const bottom = this.originalLineNumber + this.lineCount - lineNumber;
    if (top < bottom) {
      this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + bottom - top, this.getMaxVisibleLineCountTop()), tx);
    } else {
      this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + top - bottom, this.getMaxVisibleLineCountBottom()), tx);
    }
  }
  collapseAll(tx) {
    this._visibleLineCountTop.set(0, tx);
    this._visibleLineCountBottom.set(0, tx);
  }
  setState(visibleLineCountTop, visibleLineCountBottom, tx) {
    visibleLineCountTop = Math.max(Math.min(visibleLineCountTop, this.lineCount), 0);
    visibleLineCountBottom = Math.max(Math.min(visibleLineCountBottom, this.lineCount - visibleLineCountTop), 0);
    this._visibleLineCountTop.set(visibleLineCountTop, tx);
    this._visibleLineCountBottom.set(visibleLineCountBottom, tx);
  }
};
function applyOriginalEdits(diff, textEdits, originalTextModel, modifiedTextModel) {
  return void 0;
}
function applyModifiedEdits(diff, textEdits, originalTextModel, modifiedTextModel) {
  return void 0;
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/inlineDiffDeletedCodeMargin.js
var InlineDiffDeletedCodeMargin = class extends Disposable {
  get visibility() {
    return this._visibility;
  }
  set visibility(_visibility) {
    if (this._visibility !== _visibility) {
      this._visibility = _visibility;
      this._diffActions.style.visibility = _visibility ? "visible" : "hidden";
    }
  }
  constructor(_getViewZoneId, _marginDomNode, _modifiedEditor, _diff, _editor, _viewLineCounts, _originalTextModel, _contextMenuService, _clipboardService) {
    super();
    this._getViewZoneId = _getViewZoneId;
    this._marginDomNode = _marginDomNode;
    this._modifiedEditor = _modifiedEditor;
    this._diff = _diff;
    this._editor = _editor;
    this._viewLineCounts = _viewLineCounts;
    this._originalTextModel = _originalTextModel;
    this._contextMenuService = _contextMenuService;
    this._clipboardService = _clipboardService;
    this._visibility = false;
    this._marginDomNode.style.zIndex = "10";
    this._diffActions = document.createElement("div");
    this._diffActions.className = ThemeIcon.asClassName(Codicon.lightBulb) + " lightbulb-glyph";
    this._diffActions.style.position = "absolute";
    const lineHeight = this._modifiedEditor.getOption(
      66
      /* EditorOption.lineHeight */
    );
    this._diffActions.style.right = "0px";
    this._diffActions.style.visibility = "hidden";
    this._diffActions.style.height = `${lineHeight}px`;
    this._diffActions.style.lineHeight = `${lineHeight}px`;
    this._marginDomNode.appendChild(this._diffActions);
    let currentLineNumberOffset = 0;
    const useShadowDOM = _modifiedEditor.getOption(
      126
      /* EditorOption.useShadowDOM */
    ) && !isIOS;
    const showContextMenu = (x, y) => {
      var _a;
      this._contextMenuService.showContextMenu({
        domForShadowRoot: useShadowDOM ? (_a = _modifiedEditor.getDomNode()) !== null && _a !== void 0 ? _a : void 0 : void 0,
        getAnchor: () => ({ x, y }),
        getActions: () => {
          const actions = [];
          const isDeletion = _diff.modified.isEmpty;
          actions.push(new Action("diff.clipboard.copyDeletedContent", isDeletion ? _diff.original.length > 1 ? localize("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : localize("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line") : _diff.original.length > 1 ? localize("diff.clipboard.copyChangedLinesContent.label", "Copy changed lines") : localize("diff.clipboard.copyChangedLinesContent.single.label", "Copy changed line"), void 0, true, async () => {
            const originalText = this._originalTextModel.getValueInRange(_diff.original.toExclusiveRange());
            await this._clipboardService.writeText(originalText);
          }));
          if (_diff.original.length > 1) {
            actions.push(new Action("diff.clipboard.copyDeletedLineContent", isDeletion ? localize("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", _diff.original.startLineNumber + currentLineNumberOffset) : localize("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", _diff.original.startLineNumber + currentLineNumberOffset), void 0, true, async () => {
              let lineContent = this._originalTextModel.getLineContent(_diff.original.startLineNumber + currentLineNumberOffset);
              if (lineContent === "") {
                const eof = this._originalTextModel.getEndOfLineSequence();
                lineContent = eof === 0 ? "\n" : "\r\n";
              }
              await this._clipboardService.writeText(lineContent);
            }));
          }
          const readOnly = _modifiedEditor.getOption(
            90
            /* EditorOption.readOnly */
          );
          if (!readOnly) {
            actions.push(new Action("diff.inline.revertChange", localize("diff.inline.revertChange.label", "Revert this change"), void 0, true, async () => {
              this._editor.revert(this._diff);
            }));
          }
          return actions;
        },
        autoSelectFirstItem: true
      });
    };
    this._register(addStandardDisposableListener(this._diffActions, "mousedown", (e) => {
      if (!e.leftButton) {
        return;
      }
      const { top, height } = getDomNodePagePosition(this._diffActions);
      const pad = Math.floor(lineHeight / 3);
      e.preventDefault();
      showContextMenu(e.posx, top + height + pad);
    }));
    this._register(_modifiedEditor.onMouseMove((e) => {
      if ((e.target.type === 8 || e.target.type === 5) && e.target.detail.viewZoneId === this._getViewZoneId()) {
        currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);
        this.visibility = true;
      } else {
        this.visibility = false;
      }
    }));
    this._register(_modifiedEditor.onMouseDown((e) => {
      if (!e.event.leftButton) {
        return;
      }
      if (e.target.type === 8 || e.target.type === 5) {
        const viewZoneId = e.target.detail.viewZoneId;
        if (viewZoneId === this._getViewZoneId()) {
          e.event.preventDefault();
          currentLineNumberOffset = this._updateLightBulbPosition(this._marginDomNode, e.event.browserEvent.y, lineHeight);
          showContextMenu(e.event.posx, e.event.posy + lineHeight);
        }
      }
    }));
  }
  _updateLightBulbPosition(marginDomNode, y, lineHeight) {
    const { top } = getDomNodePagePosition(marginDomNode);
    const offset = y - top;
    const lineNumberOffset = Math.floor(offset / lineHeight);
    const newTop = lineNumberOffset * lineHeight;
    this._diffActions.style.top = `${newTop}px`;
    if (this._viewLineCounts) {
      let acc = 0;
      for (let i = 0; i < this._viewLineCounts.length; i++) {
        acc += this._viewLineCounts[i];
        if (lineNumberOffset < acc) {
          return i;
        }
      }
    }
    return lineNumberOffset;
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/renderLines.js
var ttPolicy3 = createTrustedTypesPolicy("diffEditorWidget", { createHTML: (value) => value });
function renderLines(source, options, decorations, domNode) {
  applyFontInfo(domNode, options.fontInfo);
  const hasCharChanges = decorations.length > 0;
  const sb = new StringBuilder(1e4);
  let maxCharsPerLine = 0;
  let renderedLineCount = 0;
  const viewLineCounts = [];
  for (let lineIndex = 0; lineIndex < source.lineTokens.length; lineIndex++) {
    const lineNumber = lineIndex + 1;
    const lineTokens = source.lineTokens[lineIndex];
    const lineBreakData = source.lineBreakData[lineIndex];
    const actualDecorations = LineDecoration.filter(decorations, lineNumber, 1, Number.MAX_SAFE_INTEGER);
    if (lineBreakData) {
      let lastBreakOffset = 0;
      for (const breakOffset of lineBreakData.breakOffsets) {
        const viewLineTokens = lineTokens.sliceAndInflate(lastBreakOffset, breakOffset, 0);
        maxCharsPerLine = Math.max(maxCharsPerLine, renderOriginalLine(renderedLineCount, viewLineTokens, LineDecoration.extractWrapped(actualDecorations, lastBreakOffset, breakOffset), hasCharChanges, source.mightContainNonBasicASCII, source.mightContainRTL, options, sb));
        renderedLineCount++;
        lastBreakOffset = breakOffset;
      }
      viewLineCounts.push(lineBreakData.breakOffsets.length);
    } else {
      viewLineCounts.push(1);
      maxCharsPerLine = Math.max(maxCharsPerLine, renderOriginalLine(renderedLineCount, lineTokens, actualDecorations, hasCharChanges, source.mightContainNonBasicASCII, source.mightContainRTL, options, sb));
      renderedLineCount++;
    }
  }
  maxCharsPerLine += options.scrollBeyondLastColumn;
  const html = sb.build();
  const trustedhtml = ttPolicy3 ? ttPolicy3.createHTML(html) : html;
  domNode.innerHTML = trustedhtml;
  const minWidthInPx = maxCharsPerLine * options.typicalHalfwidthCharacterWidth;
  return {
    heightInLines: renderedLineCount,
    minWidthInPx,
    viewLineCounts
  };
}
var LineSource = class {
  constructor(lineTokens, lineBreakData, mightContainNonBasicASCII, mightContainRTL) {
    this.lineTokens = lineTokens;
    this.lineBreakData = lineBreakData;
    this.mightContainNonBasicASCII = mightContainNonBasicASCII;
    this.mightContainRTL = mightContainRTL;
  }
};
var RenderOptions = class _RenderOptions {
  static fromEditor(editor2) {
    var _a;
    const modifiedEditorOptions = editor2.getOptions();
    const fontInfo = modifiedEditorOptions.get(
      50
      /* EditorOption.fontInfo */
    );
    const layoutInfo = modifiedEditorOptions.get(
      143
      /* EditorOption.layoutInfo */
    );
    return new _RenderOptions(((_a = editor2.getModel()) === null || _a === void 0 ? void 0 : _a.getOptions().tabSize) || 0, fontInfo, modifiedEditorOptions.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), fontInfo.typicalHalfwidthCharacterWidth, modifiedEditorOptions.get(
      103
      /* EditorOption.scrollBeyondLastColumn */
    ), modifiedEditorOptions.get(
      66
      /* EditorOption.lineHeight */
    ), layoutInfo.decorationsWidth, modifiedEditorOptions.get(
      116
      /* EditorOption.stopRenderingLineAfter */
    ), modifiedEditorOptions.get(
      98
      /* EditorOption.renderWhitespace */
    ), modifiedEditorOptions.get(
      93
      /* EditorOption.renderControlCharacters */
    ), modifiedEditorOptions.get(
      51
      /* EditorOption.fontLigatures */
    ));
  }
  constructor(tabSize, fontInfo, disableMonospaceOptimizations, typicalHalfwidthCharacterWidth, scrollBeyondLastColumn, lineHeight, lineDecorationsWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures) {
    this.tabSize = tabSize;
    this.fontInfo = fontInfo;
    this.disableMonospaceOptimizations = disableMonospaceOptimizations;
    this.typicalHalfwidthCharacterWidth = typicalHalfwidthCharacterWidth;
    this.scrollBeyondLastColumn = scrollBeyondLastColumn;
    this.lineHeight = lineHeight;
    this.lineDecorationsWidth = lineDecorationsWidth;
    this.stopRenderingLineAfter = stopRenderingLineAfter;
    this.renderWhitespace = renderWhitespace;
    this.renderControlCharacters = renderControlCharacters;
    this.fontLigatures = fontLigatures;
  }
};
function renderOriginalLine(viewLineIdx, lineTokens, decorations, hasCharChanges, mightContainNonBasicASCII, mightContainRTL, options, sb) {
  sb.appendString('<div class="view-line');
  if (!hasCharChanges) {
    sb.appendString(" char-delete");
  }
  sb.appendString('" style="top:');
  sb.appendString(String(viewLineIdx * options.lineHeight));
  sb.appendString('px;width:1000000px;">');
  const lineContent = lineTokens.getLineContent();
  const isBasicASCII2 = ViewLineRenderingData.isBasicASCII(lineContent, mightContainNonBasicASCII);
  const containsRTL = ViewLineRenderingData.containsRTL(lineContent, isBasicASCII2, mightContainRTL);
  const output = renderViewLine(new RenderLineInput(
    options.fontInfo.isMonospace && !options.disableMonospaceOptimizations,
    options.fontInfo.canUseHalfwidthRightwardsArrow,
    lineContent,
    false,
    isBasicASCII2,
    containsRTL,
    0,
    lineTokens,
    decorations,
    options.tabSize,
    0,
    options.fontInfo.spaceWidth,
    options.fontInfo.middotWidth,
    options.fontInfo.wsmiddotWidth,
    options.stopRenderingLineAfter,
    options.renderWhitespace,
    options.renderControlCharacters,
    options.fontLigatures !== EditorFontLigatures.OFF,
    null
    // Send no selections, original line cannot be selected
  ), sb);
  sb.appendString("</div>");
  return output.characterMapping.getHorizontalOffset(output.characterMapping.length);
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/lineAlignment.js
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ViewZoneManager = class ViewZoneManager2 extends Disposable {
  constructor(_targetWindow, _editors, _diffModel, _options, _diffEditorWidget, _canIgnoreViewZoneUpdateEvent, _origViewZonesToIgnore, _modViewZonesToIgnore, _clipboardService, _contextMenuService) {
    super();
    this._targetWindow = _targetWindow;
    this._editors = _editors;
    this._diffModel = _diffModel;
    this._options = _options;
    this._diffEditorWidget = _diffEditorWidget;
    this._canIgnoreViewZoneUpdateEvent = _canIgnoreViewZoneUpdateEvent;
    this._origViewZonesToIgnore = _origViewZonesToIgnore;
    this._modViewZonesToIgnore = _modViewZonesToIgnore;
    this._clipboardService = _clipboardService;
    this._contextMenuService = _contextMenuService;
    this._originalTopPadding = observableValue(this, 0);
    this._originalScrollOffset = observableValue(this, 0);
    this._originalScrollOffsetAnimated = animatedObservable(this._targetWindow, this._originalScrollOffset, this._store);
    this._modifiedTopPadding = observableValue(this, 0);
    this._modifiedScrollOffset = observableValue(this, 0);
    this._modifiedScrollOffsetAnimated = animatedObservable(this._targetWindow, this._modifiedScrollOffset, this._store);
    const state = observableValue("invalidateAlignmentsState", 0);
    const updateImmediately = this._register(new RunOnceScheduler(() => {
      state.set(state.get() + 1, void 0);
    }, 0));
    this._register(this._editors.original.onDidChangeViewZones((_args) => {
      if (!this._canIgnoreViewZoneUpdateEvent()) {
        updateImmediately.schedule();
      }
    }));
    this._register(this._editors.modified.onDidChangeViewZones((_args) => {
      if (!this._canIgnoreViewZoneUpdateEvent()) {
        updateImmediately.schedule();
      }
    }));
    this._register(this._editors.original.onDidChangeConfiguration((args) => {
      if (args.hasChanged(
        144
        /* EditorOption.wrappingInfo */
      ) || args.hasChanged(
        66
        /* EditorOption.lineHeight */
      )) {
        updateImmediately.schedule();
      }
    }));
    this._register(this._editors.modified.onDidChangeConfiguration((args) => {
      if (args.hasChanged(
        144
        /* EditorOption.wrappingInfo */
      ) || args.hasChanged(
        66
        /* EditorOption.lineHeight */
      )) {
        updateImmediately.schedule();
      }
    }));
    const originalModelTokenizationCompleted = this._diffModel.map((m) => m ? observableFromEvent(
      m.model.original.onDidChangeTokens,
      () => m.model.original.tokenization.backgroundTokenizationState === 2
      /* BackgroundTokenizationState.Completed */
    ) : void 0).map((m, reader) => m === null || m === void 0 ? void 0 : m.read(reader));
    const alignments = derived((reader) => {
      const diffModel = this._diffModel.read(reader);
      const diff = diffModel === null || diffModel === void 0 ? void 0 : diffModel.diff.read(reader);
      if (!diffModel || !diff) {
        return null;
      }
      state.read(reader);
      const renderSideBySide = this._options.renderSideBySide.read(reader);
      const innerHunkAlignment = renderSideBySide;
      return computeRangeAlignment(this._editors.original, this._editors.modified, diff.mappings, this._origViewZonesToIgnore, this._modViewZonesToIgnore, innerHunkAlignment);
    });
    const alignmentsSyncedMovedText = derived((reader) => {
      var _a;
      const syncedMovedText = (_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.movedTextToCompare.read(reader);
      if (!syncedMovedText) {
        return null;
      }
      state.read(reader);
      const mappings = syncedMovedText.changes.map((c) => new DiffMapping(c));
      return computeRangeAlignment(this._editors.original, this._editors.modified, mappings, this._origViewZonesToIgnore, this._modViewZonesToIgnore, true);
    });
    function createFakeLinesDiv() {
      const r = document.createElement("div");
      r.className = "diagonal-fill";
      return r;
    }
    const alignmentViewZonesDisposables = this._register(new DisposableStore());
    this.viewZones = derivedWithStore(this, (reader, store) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      alignmentViewZonesDisposables.clear();
      const alignmentsVal = alignments.read(reader) || [];
      const origViewZones = [];
      const modViewZones = [];
      const modifiedTopPaddingVal = this._modifiedTopPadding.read(reader);
      if (modifiedTopPaddingVal > 0) {
        modViewZones.push({
          afterLineNumber: 0,
          domNode: document.createElement("div"),
          heightInPx: modifiedTopPaddingVal,
          showInHiddenAreas: true,
          suppressMouseDown: true
        });
      }
      const originalTopPaddingVal = this._originalTopPadding.read(reader);
      if (originalTopPaddingVal > 0) {
        origViewZones.push({
          afterLineNumber: 0,
          domNode: document.createElement("div"),
          heightInPx: originalTopPaddingVal,
          showInHiddenAreas: true,
          suppressMouseDown: true
        });
      }
      const renderSideBySide = this._options.renderSideBySide.read(reader);
      const deletedCodeLineBreaksComputer = !renderSideBySide ? (_a = this._editors.modified._getViewModel()) === null || _a === void 0 ? void 0 : _a.createLineBreaksComputer() : void 0;
      if (deletedCodeLineBreaksComputer) {
        for (const a of alignmentsVal) {
          if (a.diff) {
            for (let i = a.originalRange.startLineNumber; i < a.originalRange.endLineNumberExclusive; i++) {
              deletedCodeLineBreaksComputer === null || deletedCodeLineBreaksComputer === void 0 ? void 0 : deletedCodeLineBreaksComputer.addRequest(this._editors.original.getModel().getLineContent(i), null, null);
            }
          }
        }
      }
      const lineBreakData = (_b = deletedCodeLineBreaksComputer === null || deletedCodeLineBreaksComputer === void 0 ? void 0 : deletedCodeLineBreaksComputer.finalize()) !== null && _b !== void 0 ? _b : [];
      let lineBreakDataIdx = 0;
      const modLineHeight = this._editors.modified.getOption(
        66
        /* EditorOption.lineHeight */
      );
      const syncedMovedText = (_c = this._diffModel.read(reader)) === null || _c === void 0 ? void 0 : _c.movedTextToCompare.read(reader);
      const mightContainNonBasicASCII = (_e = (_d = this._editors.original.getModel()) === null || _d === void 0 ? void 0 : _d.mightContainNonBasicASCII()) !== null && _e !== void 0 ? _e : false;
      const mightContainRTL = (_g = (_f = this._editors.original.getModel()) === null || _f === void 0 ? void 0 : _f.mightContainRTL()) !== null && _g !== void 0 ? _g : false;
      const renderOptions = RenderOptions.fromEditor(this._editors.modified);
      for (const a of alignmentsVal) {
        if (a.diff && !renderSideBySide) {
          if (!a.originalRange.isEmpty) {
            originalModelTokenizationCompleted.read(reader);
            const deletedCodeDomNode = document.createElement("div");
            deletedCodeDomNode.classList.add("view-lines", "line-delete", "monaco-mouse-cursor-text");
            const source = new LineSource(a.originalRange.mapToLineArray((l) => this._editors.original.getModel().tokenization.getLineTokens(l)), a.originalRange.mapToLineArray((_) => lineBreakData[lineBreakDataIdx++]), mightContainNonBasicASCII, mightContainRTL);
            const decorations = [];
            for (const i of a.diff.innerChanges || []) {
              decorations.push(new InlineDecoration(
                i.originalRange.delta(-(a.diff.original.startLineNumber - 1)),
                diffDeleteDecoration.className,
                0
                /* InlineDecorationType.Regular */
              ));
            }
            const result = renderLines(source, renderOptions, decorations, deletedCodeDomNode);
            const marginDomNode2 = document.createElement("div");
            marginDomNode2.className = "inline-deleted-margin-view-zone";
            applyFontInfo(marginDomNode2, renderOptions.fontInfo);
            if (this._options.renderIndicators.read(reader)) {
              for (let i = 0; i < result.heightInLines; i++) {
                const marginElement = document.createElement("div");
                marginElement.className = `delete-sign ${ThemeIcon.asClassName(diffRemoveIcon)}`;
                marginElement.setAttribute("style", `position:absolute;top:${i * modLineHeight}px;width:${renderOptions.lineDecorationsWidth}px;height:${modLineHeight}px;right:0;`);
                marginDomNode2.appendChild(marginElement);
              }
            }
            let zoneId = void 0;
            alignmentViewZonesDisposables.add(new InlineDiffDeletedCodeMargin(() => assertIsDefined(zoneId), marginDomNode2, this._editors.modified, a.diff, this._diffEditorWidget, result.viewLineCounts, this._editors.original.getModel(), this._contextMenuService, this._clipboardService));
            for (let i = 0; i < result.viewLineCounts.length; i++) {
              const count = result.viewLineCounts[i];
              if (count > 1) {
                origViewZones.push({
                  afterLineNumber: a.originalRange.startLineNumber + i,
                  domNode: createFakeLinesDiv(),
                  heightInPx: (count - 1) * modLineHeight,
                  showInHiddenAreas: true,
                  suppressMouseDown: true
                });
              }
            }
            modViewZones.push({
              afterLineNumber: a.modifiedRange.startLineNumber - 1,
              domNode: deletedCodeDomNode,
              heightInPx: result.heightInLines * modLineHeight,
              minWidthInPx: result.minWidthInPx,
              marginDomNode: marginDomNode2,
              setZoneId(id) {
                zoneId = id;
              },
              showInHiddenAreas: true,
              suppressMouseDown: true
            });
          }
          const marginDomNode = document.createElement("div");
          marginDomNode.className = "gutter-delete";
          origViewZones.push({
            afterLineNumber: a.originalRange.endLineNumberExclusive - 1,
            domNode: createFakeLinesDiv(),
            heightInPx: a.modifiedHeightInPx,
            marginDomNode,
            showInHiddenAreas: true,
            suppressMouseDown: true
          });
        } else {
          const delta = a.modifiedHeightInPx - a.originalHeightInPx;
          if (delta > 0) {
            if (syncedMovedText === null || syncedMovedText === void 0 ? void 0 : syncedMovedText.lineRangeMapping.original.delta(-1).deltaLength(2).contains(a.originalRange.endLineNumberExclusive - 1)) {
              continue;
            }
            origViewZones.push({
              afterLineNumber: a.originalRange.endLineNumberExclusive - 1,
              domNode: createFakeLinesDiv(),
              heightInPx: delta,
              showInHiddenAreas: true,
              suppressMouseDown: true
            });
          } else {
            let createViewZoneMarginArrow = function() {
              const arrow = document.createElement("div");
              arrow.className = "arrow-revert-change " + ThemeIcon.asClassName(Codicon.arrowRight);
              store.add(addDisposableListener(arrow, "mousedown", (e) => e.stopPropagation()));
              store.add(addDisposableListener(arrow, "click", (e) => {
                e.stopPropagation();
                _diffEditorWidget.revert(a.diff);
              }));
              return $("div", {}, arrow);
            };
            if (syncedMovedText === null || syncedMovedText === void 0 ? void 0 : syncedMovedText.lineRangeMapping.modified.delta(-1).deltaLength(2).contains(a.modifiedRange.endLineNumberExclusive - 1)) {
              continue;
            }
            let marginDomNode = void 0;
            if (a.diff && a.diff.modified.isEmpty && this._options.shouldRenderRevertArrows.read(reader)) {
              marginDomNode = createViewZoneMarginArrow();
            }
            modViewZones.push({
              afterLineNumber: a.modifiedRange.endLineNumberExclusive - 1,
              domNode: createFakeLinesDiv(),
              heightInPx: -delta,
              marginDomNode,
              showInHiddenAreas: true,
              suppressMouseDown: true
            });
          }
        }
      }
      for (const a of (_h = alignmentsSyncedMovedText.read(reader)) !== null && _h !== void 0 ? _h : []) {
        if (!(syncedMovedText === null || syncedMovedText === void 0 ? void 0 : syncedMovedText.lineRangeMapping.original.intersect(a.originalRange)) || !(syncedMovedText === null || syncedMovedText === void 0 ? void 0 : syncedMovedText.lineRangeMapping.modified.intersect(a.modifiedRange))) {
          continue;
        }
        const delta = a.modifiedHeightInPx - a.originalHeightInPx;
        if (delta > 0) {
          origViewZones.push({
            afterLineNumber: a.originalRange.endLineNumberExclusive - 1,
            domNode: createFakeLinesDiv(),
            heightInPx: delta,
            showInHiddenAreas: true,
            suppressMouseDown: true
          });
        } else {
          modViewZones.push({
            afterLineNumber: a.modifiedRange.endLineNumberExclusive - 1,
            domNode: createFakeLinesDiv(),
            heightInPx: -delta,
            showInHiddenAreas: true,
            suppressMouseDown: true
          });
        }
      }
      return { orig: origViewZones, mod: modViewZones };
    });
    let ignoreChange = false;
    this._register(this._editors.original.onDidScrollChange((e) => {
      if (e.scrollLeftChanged && !ignoreChange) {
        ignoreChange = true;
        this._editors.modified.setScrollLeft(e.scrollLeft);
        ignoreChange = false;
      }
    }));
    this._register(this._editors.modified.onDidScrollChange((e) => {
      if (e.scrollLeftChanged && !ignoreChange) {
        ignoreChange = true;
        this._editors.original.setScrollLeft(e.scrollLeft);
        ignoreChange = false;
      }
    }));
    this._originalScrollTop = observableFromEvent(this._editors.original.onDidScrollChange, () => (
      /** @description original.getScrollTop */
      this._editors.original.getScrollTop()
    ));
    this._modifiedScrollTop = observableFromEvent(this._editors.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this._editors.modified.getScrollTop()
    ));
    this._register(autorun((reader) => {
      const newScrollTopModified = this._originalScrollTop.read(reader) - (this._originalScrollOffsetAnimated.get() - this._modifiedScrollOffsetAnimated.read(reader)) - (this._originalTopPadding.get() - this._modifiedTopPadding.read(reader));
      if (newScrollTopModified !== this._editors.modified.getScrollTop()) {
        this._editors.modified.setScrollTop(
          newScrollTopModified,
          1
          /* ScrollType.Immediate */
        );
      }
    }));
    this._register(autorun((reader) => {
      const newScrollTopOriginal = this._modifiedScrollTop.read(reader) - (this._modifiedScrollOffsetAnimated.get() - this._originalScrollOffsetAnimated.read(reader)) - (this._modifiedTopPadding.get() - this._originalTopPadding.read(reader));
      if (newScrollTopOriginal !== this._editors.original.getScrollTop()) {
        this._editors.original.setScrollTop(
          newScrollTopOriginal,
          1
          /* ScrollType.Immediate */
        );
      }
    }));
    this._register(autorun((reader) => {
      var _a;
      const m = (_a = this._diffModel.read(reader)) === null || _a === void 0 ? void 0 : _a.movedTextToCompare.read(reader);
      let deltaOrigToMod = 0;
      if (m) {
        const trueTopOriginal = this._editors.original.getTopForLineNumber(m.lineRangeMapping.original.startLineNumber, true) - this._originalTopPadding.get();
        const trueTopModified = this._editors.modified.getTopForLineNumber(m.lineRangeMapping.modified.startLineNumber, true) - this._modifiedTopPadding.get();
        deltaOrigToMod = trueTopModified - trueTopOriginal;
      }
      if (deltaOrigToMod > 0) {
        this._modifiedTopPadding.set(0, void 0);
        this._originalTopPadding.set(deltaOrigToMod, void 0);
      } else if (deltaOrigToMod < 0) {
        this._modifiedTopPadding.set(-deltaOrigToMod, void 0);
        this._originalTopPadding.set(0, void 0);
      } else {
        setTimeout(() => {
          this._modifiedTopPadding.set(0, void 0);
          this._originalTopPadding.set(0, void 0);
        }, 400);
      }
      if (this._editors.modified.hasTextFocus()) {
        this._originalScrollOffset.set(this._modifiedScrollOffset.get() - deltaOrigToMod, void 0, true);
      } else {
        this._modifiedScrollOffset.set(this._originalScrollOffset.get() + deltaOrigToMod, void 0, true);
      }
    }));
  }
};
ViewZoneManager = __decorate29([
  __param27(8, IClipboardService),
  __param27(9, IContextMenuService)
], ViewZoneManager);
function computeRangeAlignment(originalEditor, modifiedEditor, diffs, originalEditorAlignmentViewZones, modifiedEditorAlignmentViewZones, innerHunkAlignment) {
  const originalLineHeightOverrides = new ArrayQueue(getAdditionalLineHeights(originalEditor, originalEditorAlignmentViewZones));
  const modifiedLineHeightOverrides = new ArrayQueue(getAdditionalLineHeights(modifiedEditor, modifiedEditorAlignmentViewZones));
  const origLineHeight = originalEditor.getOption(
    66
    /* EditorOption.lineHeight */
  );
  const modLineHeight = modifiedEditor.getOption(
    66
    /* EditorOption.lineHeight */
  );
  const result = [];
  let lastOriginalLineNumber = 0;
  let lastModifiedLineNumber = 0;
  function handleAlignmentsOutsideOfDiffs(untilOriginalLineNumberExclusive, untilModifiedLineNumberExclusive) {
    while (true) {
      let origNext = originalLineHeightOverrides.peek();
      let modNext = modifiedLineHeightOverrides.peek();
      if (origNext && origNext.lineNumber >= untilOriginalLineNumberExclusive) {
        origNext = void 0;
      }
      if (modNext && modNext.lineNumber >= untilModifiedLineNumberExclusive) {
        modNext = void 0;
      }
      if (!origNext && !modNext) {
        break;
      }
      const distOrig = origNext ? origNext.lineNumber - lastOriginalLineNumber : Number.MAX_VALUE;
      const distNext = modNext ? modNext.lineNumber - lastModifiedLineNumber : Number.MAX_VALUE;
      if (distOrig < distNext) {
        originalLineHeightOverrides.dequeue();
        modNext = {
          lineNumber: origNext.lineNumber - lastOriginalLineNumber + lastModifiedLineNumber,
          heightInPx: 0
        };
      } else if (distOrig > distNext) {
        modifiedLineHeightOverrides.dequeue();
        origNext = {
          lineNumber: modNext.lineNumber - lastModifiedLineNumber + lastOriginalLineNumber,
          heightInPx: 0
        };
      } else {
        originalLineHeightOverrides.dequeue();
        modifiedLineHeightOverrides.dequeue();
      }
      result.push({
        originalRange: LineRange.ofLength(origNext.lineNumber, 1),
        modifiedRange: LineRange.ofLength(modNext.lineNumber, 1),
        originalHeightInPx: origLineHeight + origNext.heightInPx,
        modifiedHeightInPx: modLineHeight + modNext.heightInPx,
        diff: void 0
      });
    }
  }
  for (const m of diffs) {
    let emitAlignment = function(origLineNumberExclusive, modLineNumberExclusive) {
      var _a, _b, _c, _d;
      if (origLineNumberExclusive < lastOrigLineNumber || modLineNumberExclusive < lastModLineNumber) {
        return;
      }
      if (first) {
        first = false;
      } else if (origLineNumberExclusive === lastOrigLineNumber || modLineNumberExclusive === lastModLineNumber) {
        return;
      }
      const originalRange = new LineRange(lastOrigLineNumber, origLineNumberExclusive);
      const modifiedRange = new LineRange(lastModLineNumber, modLineNumberExclusive);
      if (originalRange.isEmpty && modifiedRange.isEmpty) {
        return;
      }
      const originalAdditionalHeight = (_b = (_a = originalLineHeightOverrides.takeWhile((v) => v.lineNumber < origLineNumberExclusive)) === null || _a === void 0 ? void 0 : _a.reduce((p, c2) => p + c2.heightInPx, 0)) !== null && _b !== void 0 ? _b : 0;
      const modifiedAdditionalHeight = (_d = (_c = modifiedLineHeightOverrides.takeWhile((v) => v.lineNumber < modLineNumberExclusive)) === null || _c === void 0 ? void 0 : _c.reduce((p, c2) => p + c2.heightInPx, 0)) !== null && _d !== void 0 ? _d : 0;
      result.push({
        originalRange,
        modifiedRange,
        originalHeightInPx: originalRange.length * origLineHeight + originalAdditionalHeight,
        modifiedHeightInPx: modifiedRange.length * modLineHeight + modifiedAdditionalHeight,
        diff: m.lineRangeMapping
      });
      lastOrigLineNumber = origLineNumberExclusive;
      lastModLineNumber = modLineNumberExclusive;
    };
    const c = m.lineRangeMapping;
    handleAlignmentsOutsideOfDiffs(c.original.startLineNumber, c.modified.startLineNumber);
    let first = true;
    let lastModLineNumber = c.modified.startLineNumber;
    let lastOrigLineNumber = c.original.startLineNumber;
    if (innerHunkAlignment) {
      for (const i of c.innerChanges || []) {
        if (i.originalRange.startColumn > 1 && i.modifiedRange.startColumn > 1) {
          emitAlignment(i.originalRange.startLineNumber, i.modifiedRange.startLineNumber);
        }
        if (i.originalRange.endColumn < originalEditor.getModel().getLineMaxColumn(i.originalRange.endLineNumber)) {
          emitAlignment(i.originalRange.endLineNumber, i.modifiedRange.endLineNumber);
        }
      }
    }
    emitAlignment(c.original.endLineNumberExclusive, c.modified.endLineNumberExclusive);
    lastOriginalLineNumber = c.original.endLineNumberExclusive;
    lastModifiedLineNumber = c.modified.endLineNumberExclusive;
  }
  handleAlignmentsOutsideOfDiffs(Number.MAX_VALUE, Number.MAX_VALUE);
  return result;
}
function getAdditionalLineHeights(editor2, viewZonesToIgnore) {
  const viewZoneHeights = [];
  const wrappingZoneHeights = [];
  const hasWrapping = editor2.getOption(
    144
    /* EditorOption.wrappingInfo */
  ).wrappingColumn !== -1;
  const coordinatesConverter = editor2._getViewModel().coordinatesConverter;
  const editorLineHeight = editor2.getOption(
    66
    /* EditorOption.lineHeight */
  );
  if (hasWrapping) {
    for (let i = 1; i <= editor2.getModel().getLineCount(); i++) {
      const lineCount = coordinatesConverter.getModelLineViewLineCount(i);
      if (lineCount > 1) {
        wrappingZoneHeights.push({ lineNumber: i, heightInPx: editorLineHeight * (lineCount - 1) });
      }
    }
  }
  for (const w of editor2.getWhitespaces()) {
    if (viewZonesToIgnore.has(w.id)) {
      continue;
    }
    const modelLineNumber = w.afterLineNumber === 0 ? 0 : coordinatesConverter.convertViewPositionToModelPosition(new Position(w.afterLineNumber, 1)).lineNumber;
    viewZoneHeights.push({ lineNumber: modelLineNumber, heightInPx: w.height });
  }
  const result = joinCombine(viewZoneHeights, wrappingZoneHeights, (v) => v.lineNumber, (v1, v2) => ({ lineNumber: v1.lineNumber, heightInPx: v1.heightInPx + v2.heightInPx }));
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/overviewRulerPart.js
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var OverviewRulerPart_1;
var OverviewRulerPart = OverviewRulerPart_1 = class OverviewRulerPart2 extends Disposable {
  constructor(_editors, _rootElement, _diffModel, _rootWidth, _rootHeight, _modifiedEditorLayoutInfo, _themeService) {
    super();
    this._editors = _editors;
    this._rootElement = _rootElement;
    this._diffModel = _diffModel;
    this._rootWidth = _rootWidth;
    this._rootHeight = _rootHeight;
    this._modifiedEditorLayoutInfo = _modifiedEditorLayoutInfo;
    this._themeService = _themeService;
    this.width = OverviewRulerPart_1.ENTIRE_DIFF_OVERVIEW_WIDTH;
    const currentColorTheme = observableFromEvent(this._themeService.onDidColorThemeChange, () => this._themeService.getColorTheme());
    const currentColors = derived((reader) => {
      const theme = currentColorTheme.read(reader);
      const insertColor = theme.getColor(diffOverviewRulerInserted) || (theme.getColor(diffInserted) || defaultInsertColor).transparent(2);
      const removeColor = theme.getColor(diffOverviewRulerRemoved) || (theme.getColor(diffRemoved) || defaultRemoveColor).transparent(2);
      return { insertColor, removeColor };
    });
    const viewportDomElement = createFastDomNode(document.createElement("div"));
    viewportDomElement.setClassName("diffViewport");
    viewportDomElement.setPosition("absolute");
    const diffOverviewRoot = h("div.diffOverview", {
      style: { position: "absolute", top: "0px", width: OverviewRulerPart_1.ENTIRE_DIFF_OVERVIEW_WIDTH + "px" }
    }).root;
    this._register(appendRemoveOnDispose(diffOverviewRoot, viewportDomElement.domNode));
    this._register(addStandardDisposableListener(diffOverviewRoot, EventType.POINTER_DOWN, (e) => {
      this._editors.modified.delegateVerticalScrollbarPointerDown(e);
    }));
    this._register(addDisposableListener(diffOverviewRoot, EventType.MOUSE_WHEEL, (e) => {
      this._editors.modified.delegateScrollFromMouseWheelEvent(e);
    }, { passive: false }));
    this._register(appendRemoveOnDispose(this._rootElement, diffOverviewRoot));
    this._register(autorunWithStore((reader, store) => {
      const m = this._diffModel.read(reader);
      const originalOverviewRuler = this._editors.original.createOverviewRuler("original diffOverviewRuler");
      if (originalOverviewRuler) {
        store.add(originalOverviewRuler);
        store.add(appendRemoveOnDispose(diffOverviewRoot, originalOverviewRuler.getDomNode()));
      }
      const modifiedOverviewRuler = this._editors.modified.createOverviewRuler("modified diffOverviewRuler");
      if (modifiedOverviewRuler) {
        store.add(modifiedOverviewRuler);
        store.add(appendRemoveOnDispose(diffOverviewRoot, modifiedOverviewRuler.getDomNode()));
      }
      if (!originalOverviewRuler || !modifiedOverviewRuler) {
        return;
      }
      const origViewZonesChanged = observableSignalFromEvent("viewZoneChanged", this._editors.original.onDidChangeViewZones);
      const modViewZonesChanged = observableSignalFromEvent("viewZoneChanged", this._editors.modified.onDidChangeViewZones);
      const origHiddenRangesChanged = observableSignalFromEvent("hiddenRangesChanged", this._editors.original.onDidChangeHiddenAreas);
      const modHiddenRangesChanged = observableSignalFromEvent("hiddenRangesChanged", this._editors.modified.onDidChangeHiddenAreas);
      store.add(autorun((reader2) => {
        var _a;
        origViewZonesChanged.read(reader2);
        modViewZonesChanged.read(reader2);
        origHiddenRangesChanged.read(reader2);
        modHiddenRangesChanged.read(reader2);
        const colors = currentColors.read(reader2);
        const diff = (_a = m === null || m === void 0 ? void 0 : m.diff.read(reader2)) === null || _a === void 0 ? void 0 : _a.mappings;
        function createZones(ranges, color, editor2) {
          const vm = editor2._getViewModel();
          if (!vm) {
            return [];
          }
          return ranges.filter((d) => d.length > 0).map((r) => {
            const start = vm.coordinatesConverter.convertModelPositionToViewPosition(new Position(r.startLineNumber, 1));
            const end = vm.coordinatesConverter.convertModelPositionToViewPosition(new Position(r.endLineNumberExclusive, 1));
            const lineCount = end.lineNumber - start.lineNumber;
            return new OverviewRulerZone(start.lineNumber, end.lineNumber, lineCount, color.toString());
          });
        }
        const originalZones = createZones((diff || []).map((d) => d.lineRangeMapping.original), colors.removeColor, this._editors.original);
        const modifiedZones = createZones((diff || []).map((d) => d.lineRangeMapping.modified), colors.insertColor, this._editors.modified);
        originalOverviewRuler === null || originalOverviewRuler === void 0 ? void 0 : originalOverviewRuler.setZones(originalZones);
        modifiedOverviewRuler === null || modifiedOverviewRuler === void 0 ? void 0 : modifiedOverviewRuler.setZones(modifiedZones);
      }));
      store.add(autorun((reader2) => {
        const height = this._rootHeight.read(reader2);
        const width = this._rootWidth.read(reader2);
        const layoutInfo = this._modifiedEditorLayoutInfo.read(reader2);
        if (layoutInfo) {
          const freeSpace = OverviewRulerPart_1.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * OverviewRulerPart_1.ONE_OVERVIEW_WIDTH;
          originalOverviewRuler.setLayout({
            top: 0,
            height,
            right: freeSpace + OverviewRulerPart_1.ONE_OVERVIEW_WIDTH,
            width: OverviewRulerPart_1.ONE_OVERVIEW_WIDTH
          });
          modifiedOverviewRuler.setLayout({
            top: 0,
            height,
            right: 0,
            width: OverviewRulerPart_1.ONE_OVERVIEW_WIDTH
          });
          const scrollTop = this._editors.modifiedScrollTop.read(reader2);
          const scrollHeight = this._editors.modifiedScrollHeight.read(reader2);
          const scrollBarOptions = this._editors.modified.getOption(
            102
            /* EditorOption.scrollbar */
          );
          const state = new ScrollbarState(scrollBarOptions.verticalHasArrows ? scrollBarOptions.arrowSize : 0, scrollBarOptions.verticalScrollbarSize, 0, layoutInfo.height, scrollHeight, scrollTop);
          viewportDomElement.setTop(state.getSliderPosition());
          viewportDomElement.setHeight(state.getSliderSize());
        } else {
          viewportDomElement.setTop(0);
          viewportDomElement.setHeight(0);
        }
        diffOverviewRoot.style.height = height + "px";
        diffOverviewRoot.style.left = width - OverviewRulerPart_1.ENTIRE_DIFF_OVERVIEW_WIDTH + "px";
        viewportDomElement.setWidth(OverviewRulerPart_1.ENTIRE_DIFF_OVERVIEW_WIDTH);
      }));
    }));
  }
};
OverviewRulerPart.ONE_OVERVIEW_WIDTH = 15;
OverviewRulerPart.ENTIRE_DIFF_OVERVIEW_WIDTH = OverviewRulerPart_1.ONE_OVERVIEW_WIDTH * 2;
OverviewRulerPart = OverviewRulerPart_1 = __decorate30([
  __param28(6, IThemeService)
], OverviewRulerPart);

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/colors.js
var diffMoveBorder = registerColor("diffEditor.move.border", { dark: "#8b8b8b9c", light: "#8b8b8b9c", hcDark: "#8b8b8b9c", hcLight: "#8b8b8b9c" }, localize("diffEditor.move.border", "The border color for text that got moved in the diff editor."));
var diffMoveBorderActive = registerColor("diffEditor.moveActive.border", { dark: "#FFA500", light: "#FFA500", hcDark: "#FFA500", hcLight: "#FFA500" }, localize("diffEditor.moveActive.border", "The active border color for text that got moved in the diff editor."));
var diffEditorUnchangedRegionShadow = registerColor("diffEditor.unchangedRegionShadow", { dark: "#000000", light: "#737373BF", hcDark: "#000000", hcLight: "#737373BF" }, localize("diffEditor.unchangedRegionShadow", "The color of the shadow around unchanged region widgets."));

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/delegatingEditorImpl.js
var DelegatingEditor = class _DelegatingEditor extends Disposable {
  constructor() {
    super(...arguments);
    this._id = ++_DelegatingEditor.idCounter;
    this._onDidDispose = this._register(new Emitter());
    this.onDidDispose = this._onDidDispose.event;
  }
  getId() {
    return this.getEditorType() + ":v2:" + this._id;
  }
  // #region editorBrowser.IDiffEditor: Delegating to modified Editor
  getVisibleColumnFromPosition(position) {
    return this._targetEditor.getVisibleColumnFromPosition(position);
  }
  getPosition() {
    return this._targetEditor.getPosition();
  }
  setPosition(position, source = "api") {
    this._targetEditor.setPosition(position, source);
  }
  revealLine(lineNumber, scrollType = 0) {
    this._targetEditor.revealLine(lineNumber, scrollType);
  }
  revealLineInCenter(lineNumber, scrollType = 0) {
    this._targetEditor.revealLineInCenter(lineNumber, scrollType);
  }
  revealLineInCenterIfOutsideViewport(lineNumber, scrollType = 0) {
    this._targetEditor.revealLineInCenterIfOutsideViewport(lineNumber, scrollType);
  }
  revealLineNearTop(lineNumber, scrollType = 0) {
    this._targetEditor.revealLineNearTop(lineNumber, scrollType);
  }
  revealPosition(position, scrollType = 0) {
    this._targetEditor.revealPosition(position, scrollType);
  }
  revealPositionInCenter(position, scrollType = 0) {
    this._targetEditor.revealPositionInCenter(position, scrollType);
  }
  revealPositionInCenterIfOutsideViewport(position, scrollType = 0) {
    this._targetEditor.revealPositionInCenterIfOutsideViewport(position, scrollType);
  }
  revealPositionNearTop(position, scrollType = 0) {
    this._targetEditor.revealPositionNearTop(position, scrollType);
  }
  getSelection() {
    return this._targetEditor.getSelection();
  }
  getSelections() {
    return this._targetEditor.getSelections();
  }
  setSelection(something, source = "api") {
    this._targetEditor.setSelection(something, source);
  }
  setSelections(ranges, source = "api") {
    this._targetEditor.setSelections(ranges, source);
  }
  revealLines(startLineNumber, endLineNumber, scrollType = 0) {
    this._targetEditor.revealLines(startLineNumber, endLineNumber, scrollType);
  }
  revealLinesInCenter(startLineNumber, endLineNumber, scrollType = 0) {
    this._targetEditor.revealLinesInCenter(startLineNumber, endLineNumber, scrollType);
  }
  revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType = 0) {
    this._targetEditor.revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber, scrollType);
  }
  revealLinesNearTop(startLineNumber, endLineNumber, scrollType = 0) {
    this._targetEditor.revealLinesNearTop(startLineNumber, endLineNumber, scrollType);
  }
  revealRange(range2, scrollType = 0, revealVerticalInCenter = false, revealHorizontal = true) {
    this._targetEditor.revealRange(range2, scrollType, revealVerticalInCenter, revealHorizontal);
  }
  revealRangeInCenter(range2, scrollType = 0) {
    this._targetEditor.revealRangeInCenter(range2, scrollType);
  }
  revealRangeInCenterIfOutsideViewport(range2, scrollType = 0) {
    this._targetEditor.revealRangeInCenterIfOutsideViewport(range2, scrollType);
  }
  revealRangeNearTop(range2, scrollType = 0) {
    this._targetEditor.revealRangeNearTop(range2, scrollType);
  }
  revealRangeNearTopIfOutsideViewport(range2, scrollType = 0) {
    this._targetEditor.revealRangeNearTopIfOutsideViewport(range2, scrollType);
  }
  revealRangeAtTop(range2, scrollType = 0) {
    this._targetEditor.revealRangeAtTop(range2, scrollType);
  }
  getSupportedActions() {
    return this._targetEditor.getSupportedActions();
  }
  focus() {
    this._targetEditor.focus();
  }
  trigger(source, handlerId, payload) {
    this._targetEditor.trigger(source, handlerId, payload);
  }
  createDecorationsCollection(decorations) {
    return this._targetEditor.createDecorationsCollection(decorations);
  }
  changeDecorations(callback) {
    return this._targetEditor.changeDecorations(callback);
  }
};
DelegatingEditor.idCounter = 0;

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditorEditors.js
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DiffEditorEditors = class DiffEditorEditors2 extends Disposable {
  get onDidContentSizeChange() {
    return this._onDidContentSizeChange.event;
  }
  constructor(originalEditorElement, modifiedEditorElement, _options, codeEditorWidgetOptions, _createInnerEditor, _instantiationService, _keybindingService) {
    super();
    this.originalEditorElement = originalEditorElement;
    this.modifiedEditorElement = modifiedEditorElement;
    this._options = _options;
    this._createInnerEditor = _createInnerEditor;
    this._instantiationService = _instantiationService;
    this._keybindingService = _keybindingService;
    this._onDidContentSizeChange = this._register(new Emitter());
    this.original = this._register(this._createLeftHandSideEditor(_options.editorOptions.get(), codeEditorWidgetOptions.originalEditor || {}));
    this.modified = this._register(this._createRightHandSideEditor(_options.editorOptions.get(), codeEditorWidgetOptions.modifiedEditor || {}));
    this.modifiedModel = observableFromEvent(this.modified.onDidChangeModel, () => (
      /** @description modified.model */
      this.modified.getModel()
    ));
    this.modifiedScrollTop = observableFromEvent(this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this.modified.getScrollTop()
    ));
    this.modifiedScrollHeight = observableFromEvent(this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollHeight */
      this.modified.getScrollHeight()
    ));
    this.modifiedSelections = observableFromEvent(this.modified.onDidChangeCursorSelection, () => {
      var _a;
      return (_a = this.modified.getSelections()) !== null && _a !== void 0 ? _a : [];
    });
    this.modifiedCursor = observableFromEvent(this.modified.onDidChangeCursorPosition, () => {
      var _a;
      return (_a = this.modified.getPosition()) !== null && _a !== void 0 ? _a : new Position(1, 1);
    });
    this._register(autorunHandleChanges({
      createEmptyChangeSummary: () => ({}),
      handleChange: (ctx, changeSummary) => {
        if (ctx.didChange(_options.editorOptions)) {
          Object.assign(changeSummary, ctx.change.changedOptions);
        }
        return true;
      }
    }, (reader, changeSummary) => {
      _options.editorOptions.read(reader);
      this._options.renderSideBySide.read(reader);
      this.modified.updateOptions(this._adjustOptionsForRightHandSide(reader, changeSummary));
      this.original.updateOptions(this._adjustOptionsForLeftHandSide(reader, changeSummary));
    }));
  }
  _createLeftHandSideEditor(options, codeEditorWidgetOptions) {
    const leftHandSideOptions = this._adjustOptionsForLeftHandSide(void 0, options);
    const editor2 = this._constructInnerEditor(this._instantiationService, this.originalEditorElement, leftHandSideOptions, codeEditorWidgetOptions);
    editor2.setContextValue("isInDiffLeftEditor", true);
    return editor2;
  }
  _createRightHandSideEditor(options, codeEditorWidgetOptions) {
    const rightHandSideOptions = this._adjustOptionsForRightHandSide(void 0, options);
    const editor2 = this._constructInnerEditor(this._instantiationService, this.modifiedEditorElement, rightHandSideOptions, codeEditorWidgetOptions);
    editor2.setContextValue("isInDiffRightEditor", true);
    return editor2;
  }
  _constructInnerEditor(instantiationService, container, options, editorWidgetOptions) {
    const editor2 = this._createInnerEditor(instantiationService, container, options, editorWidgetOptions);
    this._register(editor2.onDidContentSizeChange((e) => {
      const width = this.original.getContentWidth() + this.modified.getContentWidth() + OverviewRulerPart.ENTIRE_DIFF_OVERVIEW_WIDTH;
      const height = Math.max(this.modified.getContentHeight(), this.original.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: height,
        contentWidth: width,
        contentHeightChanged: e.contentHeightChanged,
        contentWidthChanged: e.contentWidthChanged
      });
    }));
    return editor2;
  }
  _adjustOptionsForLeftHandSide(_reader, changedOptions) {
    const result = this._adjustOptionsForSubEditor(changedOptions);
    if (!this._options.renderSideBySide.get()) {
      result.wordWrapOverride1 = "off";
      result.wordWrapOverride2 = "off";
      result.stickyScroll = { enabled: false };
      result.unicodeHighlight = { nonBasicASCII: false, ambiguousCharacters: false, invisibleCharacters: false };
    } else {
      result.unicodeHighlight = this._options.editorOptions.get().unicodeHighlight || {};
      result.wordWrapOverride1 = this._options.diffWordWrap.get();
    }
    result.glyphMargin = this._options.renderSideBySide.get();
    if (changedOptions.originalAriaLabel) {
      result.ariaLabel = changedOptions.originalAriaLabel;
    }
    result.ariaLabel = this._updateAriaLabel(result.ariaLabel);
    result.readOnly = !this._options.originalEditable.get();
    result.dropIntoEditor = { enabled: !result.readOnly };
    result.extraEditorClassName = "original-in-monaco-diff-editor";
    return result;
  }
  _adjustOptionsForRightHandSide(reader, changedOptions) {
    const result = this._adjustOptionsForSubEditor(changedOptions);
    if (changedOptions.modifiedAriaLabel) {
      result.ariaLabel = changedOptions.modifiedAriaLabel;
    }
    result.ariaLabel = this._updateAriaLabel(result.ariaLabel);
    result.wordWrapOverride1 = this._options.diffWordWrap.get();
    result.revealHorizontalRightPadding = EditorOptions.revealHorizontalRightPadding.defaultValue + OverviewRulerPart.ENTIRE_DIFF_OVERVIEW_WIDTH;
    result.scrollbar.verticalHasArrows = false;
    result.extraEditorClassName = "modified-in-monaco-diff-editor";
    return result;
  }
  _adjustOptionsForSubEditor(options) {
    const clonedOptions = {
      ...options,
      dimension: {
        height: 0,
        width: 0
      }
    };
    clonedOptions.inDiffEditor = true;
    clonedOptions.automaticLayout = false;
    clonedOptions.scrollbar = { ...clonedOptions.scrollbar || {} };
    clonedOptions.folding = false;
    clonedOptions.codeLens = this._options.diffCodeLens.get();
    clonedOptions.fixedOverflowWidgets = true;
    clonedOptions.minimap = { ...clonedOptions.minimap || {} };
    clonedOptions.minimap.enabled = false;
    if (this._options.hideUnchangedRegions.get()) {
      clonedOptions.stickyScroll = { enabled: false };
    } else {
      clonedOptions.stickyScroll = this._options.editorOptions.get().stickyScroll;
    }
    return clonedOptions;
  }
  _updateAriaLabel(ariaLabel) {
    var _a;
    if (!ariaLabel) {
      ariaLabel = "";
    }
    const ariaNavigationTip = localize("diff-aria-navigation-tip", " use {0} to open the accessibility help.", (_a = this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp")) === null || _a === void 0 ? void 0 : _a.getAriaLabel());
    if (this._options.accessibilityVerbose.get()) {
      return ariaLabel + ariaNavigationTip;
    } else if (ariaLabel) {
      return ariaLabel.replaceAll(ariaNavigationTip, "");
    }
    return "";
  }
};
DiffEditorEditors = __decorate31([
  __param29(5, IInstantiationService),
  __param29(6, IKeybindingService)
], DiffEditorEditors);

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditorOptions.js
var DiffEditorOptions = class {
  get editorOptions() {
    return this._options;
  }
  constructor(options) {
    this._diffEditorWidth = observableValue(this, 0);
    this.couldShowInlineViewBecauseOfSize = derived(this, (reader) => this._options.read(reader).renderSideBySide && this._diffEditorWidth.read(reader) <= this._options.read(reader).renderSideBySideInlineBreakpoint);
    this.renderOverviewRuler = derived(this, (reader) => this._options.read(reader).renderOverviewRuler);
    this.renderSideBySide = derived(this, (reader) => this._options.read(reader).renderSideBySide && !(this._options.read(reader).useInlineViewWhenSpaceIsLimited && this.couldShowInlineViewBecauseOfSize.read(reader)));
    this.readOnly = derived(this, (reader) => this._options.read(reader).readOnly);
    this.shouldRenderRevertArrows = derived(this, (reader) => {
      if (!this._options.read(reader).renderMarginRevertIcon) {
        return false;
      }
      if (!this.renderSideBySide.read(reader)) {
        return false;
      }
      if (this.readOnly.read(reader)) {
        return false;
      }
      return true;
    });
    this.renderIndicators = derived(this, (reader) => this._options.read(reader).renderIndicators);
    this.enableSplitViewResizing = derived(this, (reader) => this._options.read(reader).enableSplitViewResizing);
    this.splitViewDefaultRatio = derived(this, (reader) => this._options.read(reader).splitViewDefaultRatio);
    this.ignoreTrimWhitespace = derived(this, (reader) => this._options.read(reader).ignoreTrimWhitespace);
    this.maxComputationTimeMs = derived(this, (reader) => this._options.read(reader).maxComputationTime);
    this.showMoves = derived(this, (reader) => this._options.read(reader).experimental.showMoves && this.renderSideBySide.read(reader));
    this.isInEmbeddedEditor = derived(this, (reader) => this._options.read(reader).isInEmbeddedEditor);
    this.diffWordWrap = derived(this, (reader) => this._options.read(reader).diffWordWrap);
    this.originalEditable = derived(this, (reader) => this._options.read(reader).originalEditable);
    this.diffCodeLens = derived(this, (reader) => this._options.read(reader).diffCodeLens);
    this.accessibilityVerbose = derived(this, (reader) => this._options.read(reader).accessibilityVerbose);
    this.diffAlgorithm = derived(this, (reader) => this._options.read(reader).diffAlgorithm);
    this.showEmptyDecorations = derived(this, (reader) => this._options.read(reader).experimental.showEmptyDecorations);
    this.onlyShowAccessibleDiffViewer = derived(this, (reader) => this._options.read(reader).onlyShowAccessibleDiffViewer);
    this.hideUnchangedRegions = derived(this, (reader) => this._options.read(reader).hideUnchangedRegions.enabled);
    this.hideUnchangedRegionsRevealLineCount = derived(this, (reader) => this._options.read(reader).hideUnchangedRegions.revealLineCount);
    this.hideUnchangedRegionsContextLineCount = derived(this, (reader) => this._options.read(reader).hideUnchangedRegions.contextLineCount);
    this.hideUnchangedRegionsMinimumLineCount = derived(this, (reader) => this._options.read(reader).hideUnchangedRegions.minimumLineCount);
    const optionsCopy = { ...options, ...validateDiffEditorOptions(options, diffEditorDefaultOptions) };
    this._options = observableValue(this, optionsCopy);
  }
  updateOptions(changedOptions) {
    const newDiffEditorOptions = validateDiffEditorOptions(changedOptions, this._options.get());
    const newOptions = { ...this._options.get(), ...changedOptions, ...newDiffEditorOptions };
    this._options.set(newOptions, void 0, { changedOptions });
  }
  setWidth(width) {
    this._diffEditorWidth.set(width, void 0);
  }
};
function validateDiffEditorOptions(options, defaults) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  return {
    enableSplitViewResizing: boolean(options.enableSplitViewResizing, defaults.enableSplitViewResizing),
    splitViewDefaultRatio: clampedFloat(options.splitViewDefaultRatio, 0.5, 0.1, 0.9),
    renderSideBySide: boolean(options.renderSideBySide, defaults.renderSideBySide),
    renderMarginRevertIcon: boolean(options.renderMarginRevertIcon, defaults.renderMarginRevertIcon),
    maxComputationTime: clampedInt(
      options.maxComputationTime,
      defaults.maxComputationTime,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    maxFileSize: clampedInt(
      options.maxFileSize,
      defaults.maxFileSize,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    ignoreTrimWhitespace: boolean(options.ignoreTrimWhitespace, defaults.ignoreTrimWhitespace),
    renderIndicators: boolean(options.renderIndicators, defaults.renderIndicators),
    originalEditable: boolean(options.originalEditable, defaults.originalEditable),
    diffCodeLens: boolean(options.diffCodeLens, defaults.diffCodeLens),
    renderOverviewRuler: boolean(options.renderOverviewRuler, defaults.renderOverviewRuler),
    diffWordWrap: stringSet(options.diffWordWrap, defaults.diffWordWrap, ["off", "on", "inherit"]),
    diffAlgorithm: stringSet(options.diffAlgorithm, defaults.diffAlgorithm, ["legacy", "advanced"], { "smart": "legacy", "experimental": "advanced" }),
    accessibilityVerbose: boolean(options.accessibilityVerbose, defaults.accessibilityVerbose),
    experimental: {
      showMoves: boolean((_a = options.experimental) === null || _a === void 0 ? void 0 : _a.showMoves, defaults.experimental.showMoves),
      showEmptyDecorations: boolean((_b = options.experimental) === null || _b === void 0 ? void 0 : _b.showEmptyDecorations, defaults.experimental.showEmptyDecorations)
    },
    hideUnchangedRegions: {
      enabled: boolean((_d = (_c = options.hideUnchangedRegions) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : (_e = options.experimental) === null || _e === void 0 ? void 0 : _e.collapseUnchangedRegions, defaults.hideUnchangedRegions.enabled),
      contextLineCount: clampedInt(
        (_f = options.hideUnchangedRegions) === null || _f === void 0 ? void 0 : _f.contextLineCount,
        defaults.hideUnchangedRegions.contextLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      minimumLineCount: clampedInt(
        (_g = options.hideUnchangedRegions) === null || _g === void 0 ? void 0 : _g.minimumLineCount,
        defaults.hideUnchangedRegions.minimumLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      revealLineCount: clampedInt(
        (_h = options.hideUnchangedRegions) === null || _h === void 0 ? void 0 : _h.revealLineCount,
        defaults.hideUnchangedRegions.revealLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      )
    },
    isInEmbeddedEditor: boolean(options.isInEmbeddedEditor, defaults.isInEmbeddedEditor),
    onlyShowAccessibleDiffViewer: boolean(options.onlyShowAccessibleDiffViewer, defaults.onlyShowAccessibleDiffViewer),
    renderSideBySideInlineBreakpoint: clampedInt(
      options.renderSideBySideInlineBreakpoint,
      defaults.renderSideBySideInlineBreakpoint,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    useInlineViewWhenSpaceIsLimited: boolean(options.useInlineViewWhenSpaceIsLimited, defaults.useInlineViewWhenSpaceIsLimited)
  };
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditorWidget.js
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DiffEditorWidget = class DiffEditorWidget2 extends DelegatingEditor {
  get onDidContentSizeChange() {
    return this._editors.onDidContentSizeChange;
  }
  constructor(_domElement, options, codeEditorWidgetOptions, _parentContextKeyService, _parentInstantiationService, codeEditorService, _audioCueService, _editorProgressService) {
    var _a;
    super();
    this._domElement = _domElement;
    this._parentContextKeyService = _parentContextKeyService;
    this._parentInstantiationService = _parentInstantiationService;
    this._audioCueService = _audioCueService;
    this._editorProgressService = _editorProgressService;
    this.elements = h("div.monaco-diff-editor.side-by-side", { style: { position: "relative", height: "100%" } }, [
      h("div.noModificationsOverlay@overlay", { style: { position: "absolute", height: "100%", visibility: "hidden" } }, [$("span", {}, "No Changes")]),
      h("div.editor.original@original", { style: { position: "absolute", height: "100%" } }),
      h("div.editor.modified@modified", { style: { position: "absolute", height: "100%" } }),
      h("div.accessibleDiffViewer@accessibleDiffViewer", { style: { position: "absolute", height: "100%" } })
    ]);
    this._diffModel = observableValue(this, void 0);
    this._shouldDisposeDiffModel = false;
    this.onDidChangeModel = Event.fromObservableLight(this._diffModel);
    this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._domElement));
    this._instantiationService = this._parentInstantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));
    this._boundarySashes = observableValue(this, void 0);
    this._accessibleDiffViewerShouldBeVisible = observableValue(this, false);
    this._accessibleDiffViewerVisible = derived(this, (reader) => this._options.onlyShowAccessibleDiffViewer.read(reader) ? true : this._accessibleDiffViewerShouldBeVisible.read(reader));
    this._movedBlocksLinesPart = observableValue(this, void 0);
    this._layoutInfo = derived(this, (reader) => {
      var _a2, _b, _c, _d, _e;
      const width = this._rootSizeObserver.width.read(reader);
      const height = this._rootSizeObserver.height.read(reader);
      const sashLeft = (_a2 = this._sash.read(reader)) === null || _a2 === void 0 ? void 0 : _a2.sashLeft.read(reader);
      const originalWidth = sashLeft !== null && sashLeft !== void 0 ? sashLeft : Math.max(5, this._editors.original.getLayoutInfo().decorationsLeft);
      const modifiedWidth = width - originalWidth - ((_c = (_b = this._overviewRulerPart.read(reader)) === null || _b === void 0 ? void 0 : _b.width) !== null && _c !== void 0 ? _c : 0);
      const movedBlocksLinesWidth = (_e = (_d = this._movedBlocksLinesPart.read(reader)) === null || _d === void 0 ? void 0 : _d.width.read(reader)) !== null && _e !== void 0 ? _e : 0;
      const originalWidthWithoutMovedBlockLines = originalWidth - movedBlocksLinesWidth;
      this.elements.original.style.width = originalWidthWithoutMovedBlockLines + "px";
      this.elements.original.style.left = "0px";
      this.elements.modified.style.width = modifiedWidth + "px";
      this.elements.modified.style.left = originalWidth + "px";
      this._editors.original.layout({ width: originalWidthWithoutMovedBlockLines, height }, true);
      this._editors.modified.layout({ width: modifiedWidth, height }, true);
      return {
        modifiedEditor: this._editors.modified.getLayoutInfo(),
        originalEditor: this._editors.original.getLayoutInfo()
      };
    });
    this._diffValue = this._diffModel.map((m, r) => m === null || m === void 0 ? void 0 : m.diff.read(r));
    this.onDidUpdateDiff = Event.fromObservableLight(this._diffValue);
    codeEditorService.willCreateDiffEditor();
    this._contextKeyService.createKey("isInDiffEditor", true);
    this._domElement.appendChild(this.elements.root);
    this._register(toDisposable(() => this._domElement.removeChild(this.elements.root)));
    this._rootSizeObserver = this._register(new ObservableElementSizeObserver(this.elements.root, options.dimension));
    this._rootSizeObserver.setAutomaticLayout((_a = options.automaticLayout) !== null && _a !== void 0 ? _a : false);
    this._options = new DiffEditorOptions(options);
    this._register(autorun((reader) => {
      this._options.setWidth(this._rootSizeObserver.width.read(reader));
    }));
    this._contextKeyService.createKey(EditorContextKeys.isEmbeddedDiffEditor.key, false);
    this._register(bindContextKey(EditorContextKeys.isEmbeddedDiffEditor, this._contextKeyService, (reader) => this._options.isInEmbeddedEditor.read(reader)));
    this._register(bindContextKey(EditorContextKeys.comparingMovedCode, this._contextKeyService, (reader) => {
      var _a2;
      return !!((_a2 = this._diffModel.read(reader)) === null || _a2 === void 0 ? void 0 : _a2.movedTextToCompare.read(reader));
    }));
    this._register(bindContextKey(EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached, this._contextKeyService, (reader) => this._options.couldShowInlineViewBecauseOfSize.read(reader)));
    this._register(bindContextKey(EditorContextKeys.hasChanges, this._contextKeyService, (reader) => {
      var _a2, _b, _c;
      return ((_c = (_b = (_a2 = this._diffModel.read(reader)) === null || _a2 === void 0 ? void 0 : _a2.diff.read(reader)) === null || _b === void 0 ? void 0 : _b.mappings.length) !== null && _c !== void 0 ? _c : 0) > 0;
    }));
    this._editors = this._register(this._instantiationService.createInstance(DiffEditorEditors, this.elements.original, this.elements.modified, this._options, codeEditorWidgetOptions, (i, c, o, o2) => this._createInnerEditor(i, c, o, o2)));
    this._overviewRulerPart = derivedDisposable(this, (reader) => !this._options.renderOverviewRuler.read(reader) ? void 0 : this._instantiationService.createInstance(readHotReloadableExport(OverviewRulerPart, reader), this._editors, this.elements.root, this._diffModel, this._rootSizeObserver.width, this._rootSizeObserver.height, this._layoutInfo.map((i) => i.modifiedEditor))).recomputeInitiallyAndOnChange(this._store);
    this._sash = derivedDisposable(this, (reader) => {
      const showSash = this._options.renderSideBySide.read(reader);
      this.elements.root.classList.toggle("side-by-side", showSash);
      return !showSash ? void 0 : new DiffEditorSash(this._options, this.elements.root, {
        height: this._rootSizeObserver.height,
        width: this._rootSizeObserver.width.map((w, reader2) => {
          var _a2, _b;
          return w - ((_b = (_a2 = this._overviewRulerPart.read(reader2)) === null || _a2 === void 0 ? void 0 : _a2.width) !== null && _b !== void 0 ? _b : 0);
        })
      }, this._boundarySashes);
    }).recomputeInitiallyAndOnChange(this._store);
    const unchangedRangesFeature = derivedDisposable(this, (reader) => (
      /** @description UnchangedRangesFeature */
      this._instantiationService.createInstance(readHotReloadableExport(HideUnchangedRegionsFeature, reader), this._editors, this._diffModel, this._options)
    )).recomputeInitiallyAndOnChange(this._store);
    derivedDisposable(this, (reader) => (
      /** @description DiffEditorDecorations */
      this._instantiationService.createInstance(readHotReloadableExport(DiffEditorDecorations, reader), this._editors, this._diffModel, this._options, this)
    )).recomputeInitiallyAndOnChange(this._store);
    const origViewZoneIdsToIgnore = /* @__PURE__ */ new Set();
    const modViewZoneIdsToIgnore = /* @__PURE__ */ new Set();
    let isUpdatingViewZones = false;
    const viewZoneManager = derivedDisposable(this, (reader) => (
      /** @description ViewZoneManager */
      this._instantiationService.createInstance(readHotReloadableExport(ViewZoneManager, reader), getWindow(this._domElement), this._editors, this._diffModel, this._options, this, () => isUpdatingViewZones || unchangedRangesFeature.get().isUpdatingHiddenAreas, origViewZoneIdsToIgnore, modViewZoneIdsToIgnore)
    )).recomputeInitiallyAndOnChange(this._store);
    const originalViewZones = derived(this, (reader) => {
      const orig = viewZoneManager.read(reader).viewZones.read(reader).orig;
      const orig2 = unchangedRangesFeature.read(reader).viewZones.read(reader).origViewZones;
      return orig.concat(orig2);
    });
    const modifiedViewZones = derived(this, (reader) => {
      const mod = viewZoneManager.read(reader).viewZones.read(reader).mod;
      const mod2 = unchangedRangesFeature.read(reader).viewZones.read(reader).modViewZones;
      return mod.concat(mod2);
    });
    this._register(applyViewZones(this._editors.original, originalViewZones, (isUpdatingOrigViewZones) => {
      isUpdatingViewZones = isUpdatingOrigViewZones;
    }, origViewZoneIdsToIgnore));
    let scrollState;
    this._register(applyViewZones(this._editors.modified, modifiedViewZones, (isUpdatingModViewZones) => {
      isUpdatingViewZones = isUpdatingModViewZones;
      if (isUpdatingViewZones) {
        scrollState = StableEditorScrollState.capture(this._editors.modified);
      } else {
        scrollState === null || scrollState === void 0 ? void 0 : scrollState.restore(this._editors.modified);
        scrollState = void 0;
      }
    }, modViewZoneIdsToIgnore));
    this._accessibleDiffViewer = derivedDisposable(this, (reader) => this._instantiationService.createInstance(readHotReloadableExport(AccessibleDiffViewer, reader), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (visible, tx) => this._accessibleDiffViewerShouldBeVisible.set(visible, tx), this._options.onlyShowAccessibleDiffViewer.map((v) => !v), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((m, r) => {
      var _a2;
      return (_a2 = m === null || m === void 0 ? void 0 : m.diff.read(r)) === null || _a2 === void 0 ? void 0 : _a2.mappings.map((m2) => m2.lineRangeMapping);
    }), this._editors)).recomputeInitiallyAndOnChange(this._store);
    const visibility = this._accessibleDiffViewerVisible.map((v) => v ? "hidden" : "visible");
    this._register(applyStyle(this.elements.modified, { visibility }));
    this._register(applyStyle(this.elements.original, { visibility }));
    this._createDiffEditorContributions();
    codeEditorService.addDiffEditor(this);
    this._register(recomputeInitiallyAndOnChange(this._layoutInfo));
    derivedDisposable(this, (reader) => (
      /** @description MovedBlocksLinesPart */
      new (readHotReloadableExport(MovedBlocksLinesPart, reader))(this.elements.root, this._diffModel, this._layoutInfo.map((i) => i.originalEditor), this._layoutInfo.map((i) => i.modifiedEditor), this._editors)
    )).recomputeInitiallyAndOnChange(this._store, (value) => {
      this._movedBlocksLinesPart.set(value, void 0);
    });
    this._register(applyStyle(this.elements.overlay, {
      width: this._layoutInfo.map((i, r) => i.originalEditor.width + (this._options.renderSideBySide.read(r) ? 0 : i.modifiedEditor.width)),
      visibility: derived((reader) => {
        var _a2, _b;
        return this._options.hideUnchangedRegions.read(reader) && ((_b = (_a2 = this._diffModel.read(reader)) === null || _a2 === void 0 ? void 0 : _a2.diff.read(reader)) === null || _b === void 0 ? void 0 : _b.mappings.length) === 0 ? "visible" : "hidden";
      })
    }));
    this._register(Event.runAndSubscribe(this._editors.modified.onDidChangeCursorPosition, (e) => {
      var _a2, _b;
      if ((e === null || e === void 0 ? void 0 : e.reason) === 3) {
        const diff = (_b = (_a2 = this._diffModel.get()) === null || _a2 === void 0 ? void 0 : _a2.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings.find((m) => m.lineRangeMapping.modified.contains(e.position.lineNumber));
        if (diff === null || diff === void 0 ? void 0 : diff.lineRangeMapping.modified.isEmpty) {
          this._audioCueService.playAudioCue(AudioCue.diffLineDeleted, { source: "diffEditor.cursorPositionChanged" });
        } else if (diff === null || diff === void 0 ? void 0 : diff.lineRangeMapping.original.isEmpty) {
          this._audioCueService.playAudioCue(AudioCue.diffLineInserted, { source: "diffEditor.cursorPositionChanged" });
        } else if (diff) {
          this._audioCueService.playAudioCue(AudioCue.diffLineModified, { source: "diffEditor.cursorPositionChanged" });
        }
      }
    }));
    const isInitializingDiff = this._diffModel.map(this, (m, reader) => {
      if (!m) {
        return void 0;
      }
      return m.diff.read(reader) === void 0 && !m.isDiffUpToDate.read(reader);
    });
    this._register(autorunWithStore((reader, store) => {
      if (isInitializingDiff.read(reader) === true) {
        const r = this._editorProgressService.show(true, 1e3);
        store.add(toDisposable(() => r.done()));
      }
    }));
    this._register(toDisposable(() => {
      var _a2;
      if (this._shouldDisposeDiffModel) {
        (_a2 = this._diffModel.get()) === null || _a2 === void 0 ? void 0 : _a2.dispose();
      }
    }));
  }
  _createInnerEditor(instantiationService, container, options, editorWidgetOptions) {
    const editor2 = instantiationService.createInstance(CodeEditorWidget, container, options, editorWidgetOptions);
    return editor2;
  }
  _createDiffEditorContributions() {
    const contributions = EditorExtensionsRegistry.getDiffEditorContributions();
    for (const desc of contributions) {
      try {
        this._register(this._instantiationService.createInstance(desc.ctor, this));
      } catch (err) {
        onUnexpectedError(err);
      }
    }
  }
  get _targetEditor() {
    return this._editors.modified;
  }
  getEditorType() {
    return EditorType.IDiffEditor;
  }
  layout(dimension) {
    this._rootSizeObserver.observe(dimension);
  }
  hasTextFocus() {
    return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus();
  }
  saveViewState() {
    var _a;
    const originalViewState = this._editors.original.saveViewState();
    const modifiedViewState = this._editors.modified.saveViewState();
    return {
      original: originalViewState,
      modified: modifiedViewState,
      modelState: (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.serializeState()
    };
  }
  restoreViewState(s) {
    var _a;
    if (s && s.original && s.modified) {
      const diffEditorState = s;
      this._editors.original.restoreViewState(diffEditorState.original);
      this._editors.modified.restoreViewState(diffEditorState.modified);
      if (diffEditorState.modelState) {
        (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.restoreSerializedState(diffEditorState.modelState);
      }
    }
  }
  handleInitialized() {
    this._editors.original.handleInitialized();
    this._editors.modified.handleInitialized();
  }
  createViewModel(model) {
    return this._instantiationService.createInstance(DiffEditorViewModel, model, this._options);
  }
  getModel() {
    var _a, _b;
    return (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.model) !== null && _b !== void 0 ? _b : null;
  }
  setModel(model, tx) {
    if (!model && this._diffModel.get()) {
      this._accessibleDiffViewer.get().close();
    }
    const vm = model ? "model" in model ? { model, shouldDispose: false } : { model: this.createViewModel(model), shouldDispose: true } : void 0;
    if (this._diffModel.get() !== (vm === null || vm === void 0 ? void 0 : vm.model)) {
      subtransaction(tx, (tx2) => {
        var _a;
        observableFromEvent.batchEventsGlobally(tx2, () => {
          this._editors.original.setModel(vm ? vm.model.model.original : null);
          this._editors.modified.setModel(vm ? vm.model.model.modified : null);
        });
        const prevValue = this._diffModel.get();
        const shouldDispose = this._shouldDisposeDiffModel;
        this._shouldDisposeDiffModel = (_a = vm === null || vm === void 0 ? void 0 : vm.shouldDispose) !== null && _a !== void 0 ? _a : false;
        this._diffModel.set(vm === null || vm === void 0 ? void 0 : vm.model, tx2);
        if (shouldDispose) {
          prevValue === null || prevValue === void 0 ? void 0 : prevValue.dispose();
        }
      });
    }
  }
  /**
   * @param changedOptions Only has values for top-level options that have actually changed.
   */
  updateOptions(changedOptions) {
    this._options.updateOptions(changedOptions);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getOriginalEditor() {
    return this._editors.original;
  }
  getModifiedEditor() {
    return this._editors.modified;
  }
  /**
   * @deprecated Use `this.getDiffComputationResult().changes2` instead.
   */
  getLineChanges() {
    var _a;
    const diffState = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get();
    if (!diffState) {
      return null;
    }
    return toLineChanges(diffState);
  }
  revert(diff) {
    var _a;
    if (diff.innerChanges) {
      this.revertRangeMappings(diff.innerChanges);
      return;
    }
    const model = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.model;
    if (!model) {
      return;
    }
    this._editors.modified.executeEdits("diffEditor", [
      {
        range: diff.modified.toExclusiveRange(),
        text: model.original.getValueInRange(diff.original.toExclusiveRange())
      }
    ]);
  }
  revertRangeMappings(diffs) {
    const model = this._diffModel.get();
    if (!model || !model.isDiffUpToDate.get()) {
      return;
    }
    const changes = diffs.map((c) => ({
      range: c.modifiedRange,
      text: model.model.original.getValueInRange(c.originalRange)
    }));
    this._editors.modified.executeEdits("diffEditor", changes);
  }
  _goTo(diff) {
    this._editors.modified.setPosition(new Position(diff.lineRangeMapping.modified.startLineNumber, 1));
    this._editors.modified.revealRangeInCenter(diff.lineRangeMapping.modified.toExclusiveRange());
  }
  goToDiff(target) {
    var _a, _b, _c, _d;
    const diffs = (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings;
    if (!diffs || diffs.length === 0) {
      return;
    }
    const curLineNumber = this._editors.modified.getPosition().lineNumber;
    let diff;
    if (target === "next") {
      diff = (_c = diffs.find((d) => d.lineRangeMapping.modified.startLineNumber > curLineNumber)) !== null && _c !== void 0 ? _c : diffs[0];
    } else {
      diff = (_d = findLast(diffs, (d) => d.lineRangeMapping.modified.startLineNumber < curLineNumber)) !== null && _d !== void 0 ? _d : diffs[diffs.length - 1];
    }
    this._goTo(diff);
    if (diff.lineRangeMapping.modified.isEmpty) {
      this._audioCueService.playAudioCue(AudioCue.diffLineDeleted, { source: "diffEditor.goToDiff" });
    } else if (diff.lineRangeMapping.original.isEmpty) {
      this._audioCueService.playAudioCue(AudioCue.diffLineInserted, { source: "diffEditor.goToDiff" });
    } else if (diff) {
      this._audioCueService.playAudioCue(AudioCue.diffLineModified, { source: "diffEditor.goToDiff" });
    }
  }
  revealFirstDiff() {
    const diffModel = this._diffModel.get();
    if (!diffModel) {
      return;
    }
    this.waitForDiff().then(() => {
      var _a;
      const diffs = (_a = diffModel.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings;
      if (!diffs || diffs.length === 0) {
        return;
      }
      this._goTo(diffs[0]);
    });
  }
  accessibleDiffViewerNext() {
    this._accessibleDiffViewer.get().next();
  }
  accessibleDiffViewerPrev() {
    this._accessibleDiffViewer.get().prev();
  }
  async waitForDiff() {
    const diffModel = this._diffModel.get();
    if (!diffModel) {
      return;
    }
    await diffModel.waitForDiff();
  }
  mapToOtherSide() {
    var _a, _b;
    const isModifiedFocus = this._editors.modified.hasWidgetFocus();
    const source = isModifiedFocus ? this._editors.modified : this._editors.original;
    const destination = isModifiedFocus ? this._editors.original : this._editors.modified;
    let destinationSelection;
    const sourceSelection = source.getSelection();
    if (sourceSelection) {
      const mappings = (_b = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.diff.get()) === null || _b === void 0 ? void 0 : _b.mappings.map((m) => isModifiedFocus ? m.lineRangeMapping.flip() : m.lineRangeMapping);
      if (mappings) {
        const newRange1 = translatePosition(sourceSelection.getStartPosition(), mappings);
        const newRange2 = translatePosition(sourceSelection.getEndPosition(), mappings);
        destinationSelection = Range.plusRange(newRange1, newRange2);
      }
    }
    return { destination, destinationSelection };
  }
  switchSide() {
    const { destination, destinationSelection } = this.mapToOtherSide();
    destination.focus();
    if (destinationSelection) {
      destination.setSelection(destinationSelection);
    }
  }
  exitCompareMove() {
    const model = this._diffModel.get();
    if (!model) {
      return;
    }
    model.movedTextToCompare.set(void 0, void 0);
  }
  collapseAllUnchangedRegions() {
    var _a;
    const unchangedRegions = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.unchangedRegions.get();
    if (!unchangedRegions) {
      return;
    }
    transaction((tx) => {
      for (const region of unchangedRegions) {
        region.collapseAll(tx);
      }
    });
  }
  showAllUnchangedRegions() {
    var _a;
    const unchangedRegions = (_a = this._diffModel.get()) === null || _a === void 0 ? void 0 : _a.unchangedRegions.get();
    if (!unchangedRegions) {
      return;
    }
    transaction((tx) => {
      for (const region of unchangedRegions) {
        region.showAll(tx);
      }
    });
  }
};
DiffEditorWidget = __decorate32([
  __param30(3, IContextKeyService),
  __param30(4, IInstantiationService),
  __param30(5, ICodeEditorService),
  __param30(6, IAudioCueService),
  __param30(7, IEditorProgressService)
], DiffEditorWidget);
function toLineChanges(state) {
  return state.mappings.map((x) => {
    const m = x.lineRangeMapping;
    let originalStartLineNumber;
    let originalEndLineNumber;
    let modifiedStartLineNumber;
    let modifiedEndLineNumber;
    let innerChanges = m.innerChanges;
    if (m.original.isEmpty) {
      originalStartLineNumber = m.original.startLineNumber - 1;
      originalEndLineNumber = 0;
      innerChanges = void 0;
    } else {
      originalStartLineNumber = m.original.startLineNumber;
      originalEndLineNumber = m.original.endLineNumberExclusive - 1;
    }
    if (m.modified.isEmpty) {
      modifiedStartLineNumber = m.modified.startLineNumber - 1;
      modifiedEndLineNumber = 0;
      innerChanges = void 0;
    } else {
      modifiedStartLineNumber = m.modified.startLineNumber;
      modifiedEndLineNumber = m.modified.endLineNumberExclusive - 1;
    }
    return {
      originalStartLineNumber,
      originalEndLineNumber,
      modifiedStartLineNumber,
      modifiedEndLineNumber,
      charChanges: innerChanges === null || innerChanges === void 0 ? void 0 : innerChanges.map((m2) => ({
        originalStartLineNumber: m2.originalRange.startLineNumber,
        originalStartColumn: m2.originalRange.startColumn,
        originalEndLineNumber: m2.originalRange.endLineNumber,
        originalEndColumn: m2.originalRange.endColumn,
        modifiedStartLineNumber: m2.modifiedRange.startLineNumber,
        modifiedStartColumn: m2.modifiedRange.startColumn,
        modifiedEndLineNumber: m2.modifiedRange.endLineNumber,
        modifiedEndColumn: m2.modifiedRange.endColumn
      }))
    };
  });
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditor.js
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LAST_GENERATED_COMMAND_ID = 0;
var ariaDomNodeCreated = false;
function createAriaDomNode(parent) {
  if (!parent) {
    if (ariaDomNodeCreated) {
      return;
    }
    ariaDomNodeCreated = true;
  }
  setARIAContainer(parent || mainWindow.document.body);
}
var StandaloneCodeEditor = class StandaloneCodeEditor2 extends CodeEditorWidget {
  constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
    const options = { ..._options };
    options.ariaLabel = options.ariaLabel || StandaloneCodeEditorNLS.editorViewAccessibleLabel;
    options.ariaLabel = options.ariaLabel + ";" + StandaloneCodeEditorNLS.accessibilityHelpMessage;
    super(domElement, options, {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
    if (keybindingService instanceof StandaloneKeybindingService) {
      this._standaloneKeybindingService = keybindingService;
    } else {
      this._standaloneKeybindingService = null;
    }
    createAriaDomNode(options.ariaContainerElement);
  }
  addCommand(keybinding, handler, context) {
    if (!this._standaloneKeybindingService) {
      console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService");
      return null;
    }
    const commandId = "DYNAMIC_" + ++LAST_GENERATED_COMMAND_ID;
    const whenExpression = ContextKeyExpr.deserialize(context);
    this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, whenExpression);
    return commandId;
  }
  createContextKey(key, defaultValue) {
    return this._contextKeyService.createKey(key, defaultValue);
  }
  addAction(_descriptor) {
    if (typeof _descriptor.id !== "string" || typeof _descriptor.label !== "string" || typeof _descriptor.run !== "function") {
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    }
    if (!this._standaloneKeybindingService) {
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
      return Disposable.None;
    }
    const id = _descriptor.id;
    const label = _descriptor.label;
    const precondition = ContextKeyExpr.and(ContextKeyExpr.equals("editorId", this.getId()), ContextKeyExpr.deserialize(_descriptor.precondition));
    const keybindings = _descriptor.keybindings;
    const keybindingsWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(_descriptor.keybindingContext));
    const contextMenuGroupId = _descriptor.contextMenuGroupId || null;
    const contextMenuOrder = _descriptor.contextMenuOrder || 0;
    const run = (_accessor, ...args) => {
      return Promise.resolve(_descriptor.run(this, ...args));
    };
    const toDispose = new DisposableStore();
    const uniqueId = this.getId() + ":" + id;
    toDispose.add(CommandsRegistry.registerCommand(uniqueId, run));
    if (contextMenuGroupId) {
      const menuItem = {
        command: {
          id: uniqueId,
          title: label
        },
        when: precondition,
        group: contextMenuGroupId,
        order: contextMenuOrder
      };
      toDispose.add(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));
    }
    if (Array.isArray(keybindings)) {
      for (const kb of keybindings) {
        toDispose.add(this._standaloneKeybindingService.addDynamicKeybinding(uniqueId, kb, run, keybindingsWhen));
      }
    }
    const internalAction = new InternalEditorAction(uniqueId, label, label, void 0, precondition, (...args) => Promise.resolve(_descriptor.run(this, ...args)), this._contextKeyService);
    this._actions.set(id, internalAction);
    toDispose.add(toDisposable(() => {
      this._actions.delete(id);
    }));
    return toDispose;
  }
  _triggerCommand(handlerId, payload) {
    if (this._codeEditorService instanceof StandaloneCodeEditorService) {
      try {
        this._codeEditorService.setActiveCodeEditor(this);
        super._triggerCommand(handlerId, payload);
      } finally {
        this._codeEditorService.setActiveCodeEditor(null);
      }
    } else {
      super._triggerCommand(handlerId, payload);
    }
  }
};
StandaloneCodeEditor = __decorate33([
  __param31(2, IInstantiationService),
  __param31(3, ICodeEditorService),
  __param31(4, ICommandService),
  __param31(5, IContextKeyService),
  __param31(6, IKeybindingService),
  __param31(7, IThemeService),
  __param31(8, INotificationService),
  __param31(9, IAccessibilityService),
  __param31(10, ILanguageConfigurationService),
  __param31(11, ILanguageFeaturesService)
], StandaloneCodeEditor);
var StandaloneEditor = class StandaloneEditor2 extends StandaloneCodeEditor {
  constructor(domElement, _options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, configurationService, accessibilityService, modelService, languageService, languageConfigurationService, languageFeaturesService) {
    const options = { ..._options };
    updateConfigurationService(configurationService, options, false);
    const themeDomRegistration = themeService.registerEditorContainer(domElement);
    if (typeof options.theme === "string") {
      themeService.setTheme(options.theme);
    }
    if (typeof options.autoDetectHighContrast !== "undefined") {
      themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));
    }
    const _model = options.model;
    delete options.model;
    super(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
    this._configurationService = configurationService;
    this._standaloneThemeService = themeService;
    this._register(themeDomRegistration);
    let model;
    if (typeof _model === "undefined") {
      const languageId = languageService.getLanguageIdByMimeType(options.language) || options.language || PLAINTEXT_LANGUAGE_ID;
      model = createTextModel(modelService, languageService, options.value || "", languageId, void 0);
      this._ownsModel = true;
    } else {
      model = _model;
      this._ownsModel = false;
    }
    this._attachModel(model);
    if (model) {
      const e = {
        oldModelUrl: null,
        newModelUrl: model.uri
      };
      this._onDidChangeModel.fire(e);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(newOptions) {
    updateConfigurationService(this._configurationService, newOptions, false);
    if (typeof newOptions.theme === "string") {
      this._standaloneThemeService.setTheme(newOptions.theme);
    }
    if (typeof newOptions.autoDetectHighContrast !== "undefined") {
      this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));
    }
    super.updateOptions(newOptions);
  }
  _postDetachModelCleanup(detachedModel) {
    super._postDetachModelCleanup(detachedModel);
    if (detachedModel && this._ownsModel) {
      detachedModel.dispose();
      this._ownsModel = false;
    }
  }
};
StandaloneEditor = __decorate33([
  __param31(2, IInstantiationService),
  __param31(3, ICodeEditorService),
  __param31(4, ICommandService),
  __param31(5, IContextKeyService),
  __param31(6, IKeybindingService),
  __param31(7, IStandaloneThemeService),
  __param31(8, INotificationService),
  __param31(9, IConfigurationService),
  __param31(10, IAccessibilityService),
  __param31(11, IModelService),
  __param31(12, ILanguageService),
  __param31(13, ILanguageConfigurationService),
  __param31(14, ILanguageFeaturesService)
], StandaloneEditor);
var StandaloneDiffEditor2 = class StandaloneDiffEditor22 extends DiffEditorWidget {
  constructor(domElement, _options, instantiationService, contextKeyService, codeEditorService, themeService, notificationService, configurationService, contextMenuService, editorProgressService, clipboardService, audioCueService) {
    const options = { ..._options };
    updateConfigurationService(configurationService, options, true);
    const themeDomRegistration = themeService.registerEditorContainer(domElement);
    if (typeof options.theme === "string") {
      themeService.setTheme(options.theme);
    }
    if (typeof options.autoDetectHighContrast !== "undefined") {
      themeService.setAutoDetectHighContrast(Boolean(options.autoDetectHighContrast));
    }
    super(domElement, options, {}, contextKeyService, instantiationService, codeEditorService, audioCueService, editorProgressService);
    this._configurationService = configurationService;
    this._standaloneThemeService = themeService;
    this._register(themeDomRegistration);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(newOptions) {
    updateConfigurationService(this._configurationService, newOptions, true);
    if (typeof newOptions.theme === "string") {
      this._standaloneThemeService.setTheme(newOptions.theme);
    }
    if (typeof newOptions.autoDetectHighContrast !== "undefined") {
      this._standaloneThemeService.setAutoDetectHighContrast(Boolean(newOptions.autoDetectHighContrast));
    }
    super.updateOptions(newOptions);
  }
  _createInnerEditor(instantiationService, container, options) {
    return instantiationService.createInstance(StandaloneCodeEditor, container, options);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(keybinding, handler, context) {
    return this.getModifiedEditor().addCommand(keybinding, handler, context);
  }
  createContextKey(key, defaultValue) {
    return this.getModifiedEditor().createContextKey(key, defaultValue);
  }
  addAction(descriptor) {
    return this.getModifiedEditor().addAction(descriptor);
  }
};
StandaloneDiffEditor2 = __decorate33([
  __param31(2, IInstantiationService),
  __param31(3, IContextKeyService),
  __param31(4, ICodeEditorService),
  __param31(5, IStandaloneThemeService),
  __param31(6, INotificationService),
  __param31(7, IConfigurationService),
  __param31(8, IContextMenuService),
  __param31(9, IEditorProgressService),
  __param31(10, IClipboardService),
  __param31(11, IAudioCueService)
], StandaloneDiffEditor2);
function createTextModel(modelService, languageService, value, languageId, uri) {
  value = value || "";
  if (!languageId) {
    const firstLF = value.indexOf("\n");
    let firstLine = value;
    if (firstLF !== -1) {
      firstLine = value.substring(0, firstLF);
    }
    return doCreateModel(modelService, value, languageService.createByFilepathOrFirstLine(uri || null, firstLine), uri);
  }
  return doCreateModel(modelService, value, languageService.createById(languageId), uri);
}
function doCreateModel(modelService, value, languageSelection, uri) {
  return modelService.createModel(value, languageSelection, uri);
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/multiDiffEditorWidget/multiDiffEditorWidgetImpl.js
import "C:/Users/Huell/Documents/Studium/HIWI/WebEditor/node_modules/monaco-editor/esm/vs/editor/browser/widget/multiDiffEditorWidget/style.css";

// node_modules/monaco-editor/esm/vs/editor/browser/widget/multiDiffEditorWidget/utils.js
var ActionRunnerWithContext = class extends ActionRunner {
  constructor(_getContext) {
    super();
    this._getContext = _getContext;
  }
  runAction(action, _context) {
    return super.runAction(action, this._getContext());
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/widget/multiDiffEditorWidget/diffEditorItemTemplate.js
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var TemplateData = class {
  constructor(viewModel) {
    this.viewModel = viewModel;
  }
  getId() {
    return this.viewModel;
  }
};
var DiffEditorItemTemplate = class DiffEditorItemTemplate2 extends Disposable {
  constructor(_container, _overflowWidgetsDomNode, _workbenchUIElementFactory, _instantiationService) {
    super();
    this._container = _container;
    this._overflowWidgetsDomNode = _overflowWidgetsDomNode;
    this._workbenchUIElementFactory = _workbenchUIElementFactory;
    this._instantiationService = _instantiationService;
    this._viewModel = observableValue(this, void 0);
    this._collapsed = derived(this, (reader) => {
      var _a;
      return (_a = this._viewModel.read(reader)) === null || _a === void 0 ? void 0 : _a.collapsed.read(reader);
    });
    this._contentHeight = observableValue(this, 500);
    this.height = derived(this, (reader) => {
      const h2 = this._collapsed.read(reader) ? 0 : this._contentHeight.read(reader);
      return h2 + this._outerEditorHeight;
    });
    this._modifiedContentWidth = observableValue(this, 0);
    this._modifiedWidth = observableValue(this, 0);
    this._originalContentWidth = observableValue(this, 0);
    this._originalWidth = observableValue(this, 0);
    this.maxScroll = derived(this, (reader) => {
      const scroll1 = this._modifiedContentWidth.read(reader) - this._modifiedWidth.read(reader);
      const scroll2 = this._originalContentWidth.read(reader) - this._originalWidth.read(reader);
      if (scroll1 > scroll2) {
        return { maxScroll: scroll1, width: this._modifiedWidth.read(reader) };
      } else {
        return { maxScroll: scroll2, width: this._originalWidth.read(reader) };
      }
    });
    this._elements = h("div.multiDiffEntry", [
      h("div.content", {
        style: {
          display: "flex",
          flexDirection: "column",
          flex: "1",
          overflow: "hidden"
        }
      }, [
        h("div.header@header", [
          h("div.collapse-button@collapseButton"),
          h("div.title.show-file-icons@title", []),
          h("div.actions@actions")
        ]),
        h("div.editorParent", {
          style: {
            flex: "1",
            display: "flex",
            flexDirection: "column"
          }
        }, [
          h("div.editorContainer@editor", { style: { flex: "1" } })
        ])
      ])
    ]);
    this.editor = this._register(this._instantiationService.createInstance(DiffEditorWidget, this._elements.editor, {
      overflowWidgetsDomNode: this._overflowWidgetsDomNode
    }, {}));
    this.isModifedFocused = isFocused(this.editor.getModifiedEditor());
    this.isOriginalFocused = isFocused(this.editor.getOriginalEditor());
    this.isFocused = derived(this, (reader) => this.isModifedFocused.read(reader) || this.isOriginalFocused.read(reader));
    this._resourceLabel = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.title)) : void 0;
    this._dataStore = new DisposableStore();
    this._headerHeight = this._elements.header.clientHeight;
    const btn = new Button(this._elements.collapseButton, {});
    this._register(autorun((reader) => {
      btn.element.className = "";
      btn.icon = this._collapsed.read(reader) ? Codicon.chevronRight : Codicon.chevronDown;
    }));
    this._register(btn.onDidClick(() => {
      var _a;
      (_a = this._viewModel.get()) === null || _a === void 0 ? void 0 : _a.collapsed.set(!this._collapsed.get(), void 0);
    }));
    this._register(autorun((reader) => {
      this._elements.editor.style.display = this._collapsed.read(reader) ? "none" : "block";
    }));
    this.editor.getModifiedEditor().onDidLayoutChange((e) => {
      const width = this.editor.getModifiedEditor().getLayoutInfo().contentWidth;
      this._modifiedWidth.set(width, void 0);
    });
    this.editor.getOriginalEditor().onDidLayoutChange((e) => {
      const width = this.editor.getOriginalEditor().getLayoutInfo().contentWidth;
      this._originalWidth.set(width, void 0);
    });
    this._register(this.editor.onDidContentSizeChange((e) => {
      globalTransaction((tx) => {
        this._contentHeight.set(e.contentHeight, tx);
        this._modifiedContentWidth.set(this.editor.getModifiedEditor().getContentWidth(), tx);
        this._originalContentWidth.set(this.editor.getOriginalEditor().getContentWidth(), tx);
      });
    }));
    this._register(autorun((reader) => {
      const isFocused2 = this.isFocused.read(reader);
      this._elements.root.classList.toggle("focused", isFocused2);
    }));
    this._container.appendChild(this._elements.root);
    this._outerEditorHeight = 38;
    this._register(this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.actions, MenuId.MultiDiffEditorFileToolbar, {
      actionRunner: this._register(new ActionRunnerWithContext(() => {
        var _a, _b;
        return (_b = (_a = this._viewModel.get()) === null || _a === void 0 ? void 0 : _a.diffEditorViewModel) === null || _b === void 0 ? void 0 : _b.model.modified.uri;
      })),
      menuOptions: {
        shouldForwardArgs: true
      }
    }));
  }
  setScrollLeft(left) {
    if (this._modifiedContentWidth.get() - this._modifiedWidth.get() > this._originalContentWidth.get() - this._originalWidth.get()) {
      this.editor.getModifiedEditor().setScrollLeft(left);
    } else {
      this.editor.getOriginalEditor().setScrollLeft(left);
    }
  }
  setData(data) {
    function updateOptions(options) {
      return {
        ...options,
        scrollBeyondLastLine: false,
        hideUnchangedRegions: {
          enabled: true
        },
        scrollbar: {
          vertical: "hidden",
          horizontal: "hidden",
          handleMouseWheel: false,
          useShadows: false
        },
        renderOverviewRuler: false,
        fixedOverflowWidgets: true
      };
    }
    const value = data.viewModel.entry.value;
    if (value.onOptionsDidChange) {
      this._dataStore.add(value.onOptionsDidChange(() => {
        var _a;
        this.editor.updateOptions(updateOptions((_a = value.options) !== null && _a !== void 0 ? _a : {}));
      }));
    }
    globalTransaction((tx) => {
      var _a, _b;
      (_a = this._resourceLabel) === null || _a === void 0 ? void 0 : _a.setUri(data.viewModel.diffEditorViewModel.model.modified.uri);
      this._dataStore.clear();
      this._viewModel.set(data.viewModel, tx);
      this.editor.setModel(data.viewModel.diffEditorViewModel, tx);
      this.editor.updateOptions(updateOptions((_b = value.options) !== null && _b !== void 0 ? _b : {}));
    });
  }
  render(verticalRange, width, editorScroll, viewPort) {
    this._elements.root.style.visibility = "visible";
    this._elements.root.style.top = `${verticalRange.start}px`;
    this._elements.root.style.height = `${verticalRange.length}px`;
    this._elements.root.style.width = `${width}px`;
    this._elements.root.style.position = "absolute";
    const delta = Math.max(0, Math.min(verticalRange.length - this._headerHeight, viewPort.start - verticalRange.start));
    this._elements.header.style.transform = `translateY(${delta}px)`;
    globalTransaction((tx) => {
      this.editor.layout({
        width,
        height: verticalRange.length - this._outerEditorHeight
      });
    });
    this.editor.getOriginalEditor().setScrollTop(editorScroll);
    this._elements.header.classList.toggle("shadow", delta > 0 || editorScroll > 0);
  }
  hide() {
    this._elements.root.style.top = `-100000px`;
    this._elements.root.style.visibility = "hidden";
  }
};
DiffEditorItemTemplate = __decorate34([
  __param32(3, IInstantiationService)
], DiffEditorItemTemplate);
function isFocused(editor2) {
  return observableFromEvent((h2) => {
    const store = new DisposableStore();
    store.add(editor2.onDidFocusEditorWidget(() => h2(true)));
    store.add(editor2.onDidBlurEditorWidget(() => h2(false)));
    return store;
  }, () => editor2.hasWidgetFocus());
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/multiDiffEditorWidget/objectPool.js
var ObjectPool = class {
  constructor(_create) {
    this._create = _create;
    this._unused = /* @__PURE__ */ new Set();
    this._used = /* @__PURE__ */ new Set();
    this._itemData = /* @__PURE__ */ new Map();
  }
  getUnusedObj(data) {
    var _a;
    let obj;
    if (this._unused.size === 0) {
      obj = this._create(data);
      this._itemData.set(obj, data);
    } else {
      const values = [...this._unused.values()];
      obj = (_a = values.find((obj2) => this._itemData.get(obj2).getId() === data.getId())) !== null && _a !== void 0 ? _a : values[0];
      this._unused.delete(obj);
      this._itemData.set(obj, data);
      obj.setData(data);
    }
    this._used.add(obj);
    return {
      object: obj,
      dispose: () => {
        this._used.delete(obj);
        if (this._unused.size > 5) {
          obj.dispose();
        } else {
          this._unused.add(obj);
        }
      }
    };
  }
  dispose() {
    for (const obj of this._used) {
      obj.dispose();
    }
    for (const obj of this._unused) {
      obj.dispose();
    }
    this._used.clear();
    this._unused.clear();
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/widget/multiDiffEditorWidget/multiDiffEditorWidgetImpl.js
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MultiDiffEditorWidgetImpl = class MultiDiffEditorWidgetImpl2 extends Disposable {
  constructor(_element, _dimension, _viewModel, _workbenchUIElementFactory, _parentContextKeyService, _parentInstantiationService) {
    super();
    this._element = _element;
    this._dimension = _dimension;
    this._viewModel = _viewModel;
    this._workbenchUIElementFactory = _workbenchUIElementFactory;
    this._parentContextKeyService = _parentContextKeyService;
    this._parentInstantiationService = _parentInstantiationService;
    this._elements = h("div", {
      style: {
        overflowY: "hidden"
      }
    }, [
      h("div@content", {
        style: {
          overflow: "hidden"
        }
      }),
      h("div.monaco-editor@overflowWidgetsDomNode", {})
    ]);
    this._sizeObserver = this._register(new ObservableElementSizeObserver(this._element, void 0));
    this._objectPool = this._register(new ObjectPool((data) => {
      const template = this._instantiationService.createInstance(DiffEditorItemTemplate, this._elements.content, this._elements.overflowWidgetsDomNode, this._workbenchUIElementFactory);
      template.setData(data);
      return template;
    }));
    this._scrollable = this._register(new Scrollable({
      forceIntegerValues: false,
      scheduleAtNextAnimationFrame: (cb) => scheduleAtNextAnimationFrame(getWindow(this._element), cb),
      smoothScrollDuration: 100
    }));
    this._scrollableElement = this._register(new SmoothScrollableElement(this._elements.root, {
      vertical: 1,
      horizontal: 1,
      className: "monaco-component",
      useShadows: false
    }, this._scrollable));
    this.scrollTop = observableFromEvent(this._scrollableElement.onScroll, () => (
      /** @description scrollTop */
      this._scrollableElement.getScrollPosition().scrollTop
    ));
    this.scrollLeft = observableFromEvent(this._scrollableElement.onScroll, () => (
      /** @description scrollLeft */
      this._scrollableElement.getScrollPosition().scrollLeft
    ));
    this._viewItems = derivedWithStore(this, (reader, store) => {
      const vm = this._viewModel.read(reader);
      if (!vm) {
        return [];
      }
      const items = vm.items.read(reader);
      return items.map((d) => store.add(new VirtualizedViewItem(d, this._objectPool, this.scrollLeft)));
    });
    this._totalHeight = this._viewItems.map(this, (items, reader) => items.reduce((r, i) => r + i.contentHeight.read(reader), 0));
    this.activeDiffItem = derived(this, (reader) => this._viewItems.read(reader).find((i) => {
      var _a;
      return (_a = i.template.read(reader)) === null || _a === void 0 ? void 0 : _a.isFocused.read(reader);
    }));
    this.lastActiveDiffItem = derivedObservableWithCache((reader, lastValue) => {
      var _a;
      return (_a = this.activeDiffItem.read(reader)) !== null && _a !== void 0 ? _a : lastValue;
    });
    this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._element));
    this._instantiationService = this._parentInstantiationService.createChild(new ServiceCollection([IContextKeyService, this._contextKeyService]));
    this._contextKeyService.createKey(EditorContextKeys.inMultiDiffEditor.key, true);
    const ctxAllCollapsed = this._parentContextKeyService.createKey(EditorContextKeys.multiDiffEditorAllCollapsed.key, false);
    this._register(autorun((reader) => {
      const viewModel = this._viewModel.read(reader);
      if (viewModel) {
        const allCollapsed = viewModel.items.read(reader).every((item) => item.collapsed.read(reader));
        ctxAllCollapsed.set(allCollapsed);
      }
    }));
    this._register(autorun((reader) => {
      const lastActiveDiffItem = this.lastActiveDiffItem.read(reader);
      transaction((tx) => {
        var _a;
        (_a = this._viewModel.read(reader)) === null || _a === void 0 ? void 0 : _a.activeDiffItem.set(lastActiveDiffItem === null || lastActiveDiffItem === void 0 ? void 0 : lastActiveDiffItem.viewModel, tx);
      });
    }));
    this._register(autorun((reader) => {
      const dimension = this._dimension.read(reader);
      this._sizeObserver.observe(dimension);
    }));
    this._elements.content.style.position = "relative";
    this._register(autorun((reader) => {
      const height = this._sizeObserver.height.read(reader);
      this._elements.root.style.height = `${height}px`;
      const totalHeight = this._totalHeight.read(reader);
      this._elements.content.style.height = `${totalHeight}px`;
      const width = this._sizeObserver.width.read(reader);
      let scrollWidth = width;
      const viewItems = this._viewItems.read(reader);
      const max = findFirstMaxBy(viewItems, (i) => i.maxScroll.read(reader).maxScroll);
      if (max) {
        const maxScroll = max.maxScroll.read(reader);
        scrollWidth = width + maxScroll.maxScroll;
      }
      this._scrollableElement.setScrollDimensions({
        width,
        height,
        scrollHeight: totalHeight,
        scrollWidth
      });
    }));
    _element.replaceChildren(this._scrollableElement.getDomNode());
    this._register(toDisposable(() => {
      _element.replaceChildren();
    }));
    this._register(this._register(autorun((reader) => {
      globalTransaction((tx) => {
        this.render(reader);
      });
    })));
  }
  render(reader) {
    const scrollTop = this.scrollTop.read(reader);
    let contentScrollOffsetToScrollOffset = 0;
    let itemHeightSumBefore = 0;
    let itemContentHeightSumBefore = 0;
    const viewPortHeight = this._sizeObserver.height.read(reader);
    const contentViewPort = OffsetRange.ofStartAndLength(scrollTop, viewPortHeight);
    const width = this._sizeObserver.width.read(reader);
    for (const v of this._viewItems.read(reader)) {
      const itemContentHeight = v.contentHeight.read(reader);
      const itemHeight = Math.min(itemContentHeight, viewPortHeight);
      const itemRange = OffsetRange.ofStartAndLength(itemHeightSumBefore, itemHeight);
      const itemContentRange = OffsetRange.ofStartAndLength(itemContentHeightSumBefore, itemContentHeight);
      if (itemContentRange.isBefore(contentViewPort)) {
        contentScrollOffsetToScrollOffset -= itemContentHeight - itemHeight;
        v.hide();
      } else if (itemContentRange.isAfter(contentViewPort)) {
        v.hide();
      } else {
        const scroll = Math.max(0, Math.min(contentViewPort.start - itemContentRange.start, itemContentHeight - itemHeight));
        contentScrollOffsetToScrollOffset -= scroll;
        const viewPort = OffsetRange.ofStartAndLength(scrollTop + contentScrollOffsetToScrollOffset, viewPortHeight);
        v.render(itemRange, scroll, width, viewPort);
      }
      itemHeightSumBefore += itemHeight;
      itemContentHeightSumBefore += itemContentHeight;
    }
    this._elements.content.style.transform = `translateY(${-(scrollTop + contentScrollOffsetToScrollOffset)}px)`;
  }
};
MultiDiffEditorWidgetImpl = __decorate35([
  __param33(4, IContextKeyService),
  __param33(5, IInstantiationService)
], MultiDiffEditorWidgetImpl);
var VirtualizedViewItem = class extends Disposable {
  constructor(viewModel, _objectPool, _scrollLeft) {
    super();
    this.viewModel = viewModel;
    this._objectPool = _objectPool;
    this._scrollLeft = _scrollLeft;
    this._lastTemplateData = observableValue(this, { contentHeight: 500, maxScroll: { maxScroll: 0, width: 0 } });
    this._templateRef = this._register(disposableObservableValue(this, void 0));
    this.contentHeight = derived(this, (reader) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = this._templateRef.read(reader)) === null || _a === void 0 ? void 0 : _a.object.height) === null || _b === void 0 ? void 0 : _b.read(reader)) !== null && _c !== void 0 ? _c : this._lastTemplateData.read(reader).contentHeight;
    });
    this.maxScroll = derived(this, (reader) => {
      var _a, _b;
      return (_b = (_a = this._templateRef.read(reader)) === null || _a === void 0 ? void 0 : _a.object.maxScroll.read(reader)) !== null && _b !== void 0 ? _b : this._lastTemplateData.read(reader).maxScroll;
    });
    this.template = derived(this, (reader) => {
      var _a;
      return (_a = this._templateRef.read(reader)) === null || _a === void 0 ? void 0 : _a.object;
    });
    this._isHidden = observableValue(this, false);
    this._register(autorun((reader) => {
      var _a;
      const scrollLeft = this._scrollLeft.read(reader);
      (_a = this._templateRef.read(reader)) === null || _a === void 0 ? void 0 : _a.object.setScrollLeft(scrollLeft);
    }));
    this._register(autorun((reader) => {
      const ref = this._templateRef.read(reader);
      if (!ref) {
        return;
      }
      const isHidden = this._isHidden.read(reader);
      if (!isHidden) {
        return;
      }
      const isFocused2 = ref.object.isFocused.read(reader);
      if (isFocused2) {
        return;
      }
      transaction((tx) => {
        this._lastTemplateData.set({
          contentHeight: ref.object.height.get(),
          maxScroll: { maxScroll: 0, width: 0 }
          // Reset max scroll
        }, tx);
        ref.object.hide();
        this._templateRef.set(void 0, tx);
      });
    }));
  }
  dispose() {
    this.hide();
    super.dispose();
  }
  toString() {
    return `VirtualViewItem(${this.viewModel.entry.value.title})`;
  }
  hide() {
    this._isHidden.set(true, void 0);
  }
  render(verticalSpace, offset, width, viewPort) {
    this._isHidden.set(false, void 0);
    let ref = this._templateRef.get();
    if (!ref) {
      ref = this._objectPool.getUnusedObj(new TemplateData(this.viewModel));
      this._templateRef.set(ref, void 0);
    }
    ref.object.render(verticalSpace, width, offset, viewPort);
  }
};

// node_modules/monaco-editor/esm/vs/editor/browser/widget/multiDiffEditorWidget/colors.js
var multiDiffEditorHeaderBackground = registerColor("multiDiffEditor.headerBackground", { dark: "#808080", light: "#b4b4b4", hcDark: "#808080", hcLight: "#b4b4b4" }, localize("multiDiffEditor.headerBackground", "The background color of the diff editor's header"));

// node_modules/monaco-editor/esm/vs/editor/browser/widget/multiDiffEditorWidget/multiDiffEditorWidget.js
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param34 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MultiDiffEditorWidget = class MultiDiffEditorWidget2 extends Disposable {
  constructor(_element, _workbenchUIElementFactory, _instantiationService) {
    super();
    this._element = _element;
    this._workbenchUIElementFactory = _workbenchUIElementFactory;
    this._instantiationService = _instantiationService;
    this._dimension = observableValue(this, void 0);
    this._viewModel = observableValue(this, void 0);
    this._widgetImpl = derivedWithStore(this, (reader, store) => {
      readHotReloadableExport(DiffEditorItemTemplate, reader);
      return store.add(this._instantiationService.createInstance(readHotReloadableExport(MultiDiffEditorWidgetImpl, reader), this._element, this._dimension, this._viewModel, this._workbenchUIElementFactory));
    });
    this._register(recomputeInitiallyAndOnChange(this._widgetImpl));
  }
};
MultiDiffEditorWidget = __decorate36([
  __param34(2, IInstantiationService)
], MultiDiffEditorWidget);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneEditor.js
function create(domElement, options, override) {
  const instantiationService = StandaloneServices.initialize(override || {});
  return instantiationService.createInstance(StandaloneEditor, domElement, options);
}
function onDidCreateEditor(listener) {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.onCodeEditorAdd((editor2) => {
    listener(editor2);
  });
}
function onDidCreateDiffEditor(listener) {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.onDiffEditorAdd((editor2) => {
    listener(editor2);
  });
}
function getEditors() {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.listCodeEditors();
}
function getDiffEditors() {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.listDiffEditors();
}
function createDiffEditor(domElement, options, override) {
  const instantiationService = StandaloneServices.initialize(override || {});
  return instantiationService.createInstance(StandaloneDiffEditor2, domElement, options);
}
function createMultiFileDiffEditor(domElement, override) {
  const instantiationService = StandaloneServices.initialize(override || {});
  return new MultiDiffEditorWidget(domElement, {}, instantiationService);
}
function addCommand(descriptor) {
  if (typeof descriptor.id !== "string" || typeof descriptor.run !== "function") {
    throw new Error("Invalid command descriptor, `id` and `run` are required properties!");
  }
  return CommandsRegistry.registerCommand(descriptor.id, descriptor.run);
}
function addEditorAction(descriptor) {
  if (typeof descriptor.id !== "string" || typeof descriptor.label !== "string" || typeof descriptor.run !== "function") {
    throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
  }
  const precondition = ContextKeyExpr.deserialize(descriptor.precondition);
  const run = (accessor, ...args) => {
    return EditorCommand.runEditorCommand(accessor, args, precondition, (accessor2, editor2, args2) => Promise.resolve(descriptor.run(editor2, ...args2)));
  };
  const toDispose = new DisposableStore();
  toDispose.add(CommandsRegistry.registerCommand(descriptor.id, run));
  if (descriptor.contextMenuGroupId) {
    const menuItem = {
      command: {
        id: descriptor.id,
        title: descriptor.label
      },
      when: precondition,
      group: descriptor.contextMenuGroupId,
      order: descriptor.contextMenuOrder || 0
    };
    toDispose.add(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));
  }
  if (Array.isArray(descriptor.keybindings)) {
    const keybindingService = StandaloneServices.get(IKeybindingService);
    if (!(keybindingService instanceof StandaloneKeybindingService)) {
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
    } else {
      const keybindingsWhen = ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(descriptor.keybindingContext));
      toDispose.add(keybindingService.addDynamicKeybindings(descriptor.keybindings.map((keybinding) => {
        return {
          keybinding,
          command: descriptor.id,
          when: keybindingsWhen
        };
      })));
    }
  }
  return toDispose;
}
function addKeybindingRule(rule) {
  return addKeybindingRules([rule]);
}
function addKeybindingRules(rules) {
  const keybindingService = StandaloneServices.get(IKeybindingService);
  if (!(keybindingService instanceof StandaloneKeybindingService)) {
    console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
    return Disposable.None;
  }
  return keybindingService.addDynamicKeybindings(rules.map((rule) => {
    return {
      keybinding: rule.keybinding,
      command: rule.command,
      commandArgs: rule.commandArgs,
      when: ContextKeyExpr.deserialize(rule.when)
    };
  }));
}
function createModel(value, language, uri) {
  const languageService = StandaloneServices.get(ILanguageService);
  const languageId = languageService.getLanguageIdByMimeType(language) || language;
  return createTextModel(StandaloneServices.get(IModelService), languageService, value, languageId, uri);
}
function setModelLanguage(model, mimeTypeOrLanguageId) {
  const languageService = StandaloneServices.get(ILanguageService);
  const languageId = languageService.getLanguageIdByMimeType(mimeTypeOrLanguageId) || mimeTypeOrLanguageId || PLAINTEXT_LANGUAGE_ID;
  model.setLanguage(languageService.createById(languageId));
}
function setModelMarkers(model, owner, markers) {
  if (model) {
    const markerService = StandaloneServices.get(IMarkerService);
    markerService.changeOne(owner, model.uri, markers);
  }
}
function removeAllMarkers(owner) {
  const markerService = StandaloneServices.get(IMarkerService);
  markerService.changeAll(owner, []);
}
function getModelMarkers(filter) {
  const markerService = StandaloneServices.get(IMarkerService);
  return markerService.read(filter);
}
function onDidChangeMarkers(listener) {
  const markerService = StandaloneServices.get(IMarkerService);
  return markerService.onMarkerChanged(listener);
}
function getModel(uri) {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.getModel(uri);
}
function getModels() {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.getModels();
}
function onDidCreateModel(listener) {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.onModelAdded(listener);
}
function onWillDisposeModel(listener) {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.onModelRemoved(listener);
}
function onDidChangeModelLanguage(listener) {
  const modelService = StandaloneServices.get(IModelService);
  return modelService.onModelLanguageChanged((e) => {
    listener({
      model: e.model,
      oldLanguage: e.oldLanguageId
    });
  });
}
function createWebWorker2(opts) {
  return createWebWorker(StandaloneServices.get(IModelService), StandaloneServices.get(ILanguageConfigurationService), opts);
}
function colorizeElement(domNode, options) {
  const languageService = StandaloneServices.get(ILanguageService);
  const themeService = StandaloneServices.get(IStandaloneThemeService);
  return Colorizer.colorizeElement(themeService, languageService, domNode, options).then(() => {
    themeService.registerEditorContainer(domNode);
  });
}
function colorize(text, languageId, options) {
  const languageService = StandaloneServices.get(ILanguageService);
  const themeService = StandaloneServices.get(IStandaloneThemeService);
  themeService.registerEditorContainer(mainWindow.document.body);
  return Colorizer.colorize(languageService, text, languageId, options);
}
function colorizeModelLine(model, lineNumber, tabSize = 4) {
  const themeService = StandaloneServices.get(IStandaloneThemeService);
  themeService.registerEditorContainer(mainWindow.document.body);
  return Colorizer.colorizeModelLine(model, lineNumber, tabSize);
}
function getSafeTokenizationSupport(language) {
  const tokenizationSupport = TokenizationRegistry.get(language);
  if (tokenizationSupport) {
    return tokenizationSupport;
  }
  return {
    getInitialState: () => NullState,
    tokenize: (line, hasEOL, state) => nullTokenize(language, state)
  };
}
function tokenize(text, languageId) {
  TokenizationRegistry.getOrCreate(languageId);
  const tokenizationSupport = getSafeTokenizationSupport(languageId);
  const lines = splitLines(text);
  const result = [];
  let state = tokenizationSupport.getInitialState();
  for (let i = 0, len = lines.length; i < len; i++) {
    const line = lines[i];
    const tokenizationResult = tokenizationSupport.tokenize(line, true, state);
    result[i] = tokenizationResult.tokens;
    state = tokenizationResult.endState;
  }
  return result;
}
function defineTheme(themeName, themeData) {
  const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
  standaloneThemeService.defineTheme(themeName, themeData);
}
function setTheme(themeName) {
  const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
  standaloneThemeService.setTheme(themeName);
}
function remeasureFonts() {
  FontMeasurements.clearAllFontInfos();
}
function registerCommand(id, handler) {
  return CommandsRegistry.registerCommand({ id, handler });
}
function registerLinkOpener(opener) {
  const openerService = StandaloneServices.get(IOpenerService);
  return openerService.registerOpener({
    async open(resource) {
      if (typeof resource === "string") {
        resource = URI.parse(resource);
      }
      return opener.open(resource);
    }
  });
}
function registerEditorOpener(opener) {
  const codeEditorService = StandaloneServices.get(ICodeEditorService);
  return codeEditorService.registerCodeEditorOpenHandler(async (input, source, sideBySide) => {
    var _a;
    if (!source) {
      return null;
    }
    const selection = (_a = input.options) === null || _a === void 0 ? void 0 : _a.selection;
    let selectionOrPosition;
    if (selection && typeof selection.endLineNumber === "number" && typeof selection.endColumn === "number") {
      selectionOrPosition = selection;
    } else if (selection) {
      selectionOrPosition = { lineNumber: selection.startLineNumber, column: selection.startColumn };
    }
    if (await opener.openCodeEditor(source, input.resource, selectionOrPosition)) {
      return source;
    }
    return null;
  });
}
function createMonacoEditorAPI() {
  return {
    // methods
    create,
    getEditors,
    getDiffEditors,
    onDidCreateEditor,
    onDidCreateDiffEditor,
    createDiffEditor,
    addCommand,
    addEditorAction,
    addKeybindingRule,
    addKeybindingRules,
    createModel,
    setModelLanguage,
    setModelMarkers,
    getModelMarkers,
    removeAllMarkers,
    onDidChangeMarkers,
    getModels,
    getModel,
    onDidCreateModel,
    onWillDisposeModel,
    onDidChangeModelLanguage,
    createWebWorker: createWebWorker2,
    colorizeElement,
    colorize,
    colorizeModelLine,
    tokenize,
    defineTheme,
    setTheme,
    remeasureFonts,
    registerCommand,
    registerLinkOpener,
    registerEditorOpener,
    // enums
    AccessibilitySupport,
    ContentWidgetPositionPreference,
    CursorChangeReason,
    DefaultEndOfLine,
    EditorAutoIndentStrategy,
    EditorOption,
    EndOfLinePreference,
    EndOfLineSequence,
    MinimapPosition: MinimapPosition2,
    MouseTargetType,
    OverlayWidgetPositionPreference,
    OverviewRulerLane: OverviewRulerLane2,
    GlyphMarginLane: GlyphMarginLane2,
    RenderLineNumbersType,
    RenderMinimap,
    ScrollbarVisibility,
    ScrollType,
    TextEditorCursorBlinkingStyle,
    TextEditorCursorStyle,
    TrackedRangeStickiness,
    WrappingIndent,
    InjectedTextCursorStops,
    PositionAffinity,
    ShowAiIconMode,
    // classes
    ConfigurationChangedEvent,
    BareFontInfo,
    FontInfo,
    TextModelResolvedOptions,
    FindMatch,
    ApplyUpdateResult,
    EditorZoom,
    createMultiFileDiffEditor,
    // vars
    EditorType,
    EditorOptions
  };
}

// node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile.js
function isArrayOf(elemType, obj) {
  if (!obj) {
    return false;
  }
  if (!Array.isArray(obj)) {
    return false;
  }
  for (const el of obj) {
    if (!elemType(el)) {
      return false;
    }
  }
  return true;
}
function bool(prop, defValue) {
  if (typeof prop === "boolean") {
    return prop;
  }
  return defValue;
}
function string(prop, defValue) {
  if (typeof prop === "string") {
    return prop;
  }
  return defValue;
}
function arrayToHash(array) {
  const result = {};
  for (const e of array) {
    result[e] = true;
  }
  return result;
}
function createKeywordMatcher(arr, caseInsensitive = false) {
  if (caseInsensitive) {
    arr = arr.map(function(x) {
      return x.toLowerCase();
    });
  }
  const hash = arrayToHash(arr);
  if (caseInsensitive) {
    return function(word) {
      return hash[word.toLowerCase()] !== void 0 && hash.hasOwnProperty(word.toLowerCase());
    };
  } else {
    return function(word) {
      return hash[word] !== void 0 && hash.hasOwnProperty(word);
    };
  }
}
function compileRegExp(lexer, str) {
  str = str.replace(/@@/g, ``);
  let n = 0;
  let hadExpansion;
  do {
    hadExpansion = false;
    str = str.replace(/@(\w+)/g, function(s, attr) {
      hadExpansion = true;
      let sub = "";
      if (typeof lexer[attr] === "string") {
        sub = lexer[attr];
      } else if (lexer[attr] && lexer[attr] instanceof RegExp) {
        sub = lexer[attr].source;
      } else {
        if (lexer[attr] === void 0) {
          throw createError(lexer, "language definition does not contain attribute '" + attr + "', used at: " + str);
        } else {
          throw createError(lexer, "attribute reference '" + attr + "' must be a string, used at: " + str);
        }
      }
      return empty(sub) ? "" : "(?:" + sub + ")";
    });
    n++;
  } while (hadExpansion && n < 5);
  str = str.replace(/\x01/g, "@");
  const flags = (lexer.ignoreCase ? "i" : "") + (lexer.unicode ? "u" : "");
  return new RegExp(str, flags);
}
function selectScrutinee(id, matches, state, num) {
  if (num < 0) {
    return id;
  }
  if (num < matches.length) {
    return matches[num];
  }
  if (num >= 100) {
    num = num - 100;
    const parts = state.split(".");
    parts.unshift(state);
    if (num < parts.length) {
      return parts[num];
    }
  }
  return null;
}
function createGuard(lexer, ruleName, tkey, val) {
  let scrut = -1;
  let oppat = tkey;
  let matches = tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  if (matches) {
    if (matches[3]) {
      scrut = parseInt(matches[3]);
      if (matches[2]) {
        scrut = scrut + 100;
      }
    }
    oppat = matches[4];
  }
  let op = "~";
  let pat = oppat;
  if (!oppat || oppat.length === 0) {
    op = "!=";
    pat = "";
  } else if (/^\w*$/.test(pat)) {
    op = "==";
  } else {
    matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);
    if (matches) {
      op = matches[1];
      pat = matches[2];
    }
  }
  let tester;
  if ((op === "~" || op === "!~") && /^(\w|\|)*$/.test(pat)) {
    const inWords = createKeywordMatcher(pat.split("|"), lexer.ignoreCase);
    tester = function(s) {
      return op === "~" ? inWords(s) : !inWords(s);
    };
  } else if (op === "@" || op === "!@") {
    const words = lexer[pat];
    if (!words) {
      throw createError(lexer, "the @ match target '" + pat + "' is not defined, in rule: " + ruleName);
    }
    if (!isArrayOf(function(elem) {
      return typeof elem === "string";
    }, words)) {
      throw createError(lexer, "the @ match target '" + pat + "' must be an array of strings, in rule: " + ruleName);
    }
    const inWords = createKeywordMatcher(words, lexer.ignoreCase);
    tester = function(s) {
      return op === "@" ? inWords(s) : !inWords(s);
    };
  } else if (op === "~" || op === "!~") {
    if (pat.indexOf("$") < 0) {
      const re = compileRegExp(lexer, "^" + pat + "$");
      tester = function(s) {
        return op === "~" ? re.test(s) : !re.test(s);
      };
    } else {
      tester = function(s, id, matches2, state) {
        const re = compileRegExp(lexer, "^" + substituteMatches(lexer, pat, id, matches2, state) + "$");
        return re.test(s);
      };
    }
  } else {
    if (pat.indexOf("$") < 0) {
      const patx = fixCase(lexer, pat);
      tester = function(s) {
        return op === "==" ? s === patx : s !== patx;
      };
    } else {
      const patx = fixCase(lexer, pat);
      tester = function(s, id, matches2, state, eos) {
        const patexp = substituteMatches(lexer, patx, id, matches2, state);
        return op === "==" ? s === patexp : s !== patexp;
      };
    }
  }
  if (scrut === -1) {
    return {
      name: tkey,
      value: val,
      test: function(id, matches2, state, eos) {
        return tester(id, id, matches2, state, eos);
      }
    };
  } else {
    return {
      name: tkey,
      value: val,
      test: function(id, matches2, state, eos) {
        const scrutinee = selectScrutinee(id, matches2, state, scrut);
        return tester(!scrutinee ? "" : scrutinee, id, matches2, state, eos);
      }
    };
  }
}
function compileAction(lexer, ruleName, action) {
  if (!action) {
    return { token: "" };
  } else if (typeof action === "string") {
    return action;
  } else if (action.token || action.token === "") {
    if (typeof action.token !== "string") {
      throw createError(lexer, "a 'token' attribute must be of type string, in rule: " + ruleName);
    } else {
      const newAction = { token: action.token };
      if (action.token.indexOf("$") >= 0) {
        newAction.tokenSubst = true;
      }
      if (typeof action.bracket === "string") {
        if (action.bracket === "@open") {
          newAction.bracket = 1;
        } else if (action.bracket === "@close") {
          newAction.bracket = -1;
        } else {
          throw createError(lexer, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + ruleName);
        }
      }
      if (action.next) {
        if (typeof action.next !== "string") {
          throw createError(lexer, "the next state must be a string value in rule: " + ruleName);
        } else {
          let next = action.next;
          if (!/^(@pop|@push|@popall)$/.test(next)) {
            if (next[0] === "@") {
              next = next.substr(1);
            }
            if (next.indexOf("$") < 0) {
              if (!stateExists(lexer, substituteMatches(lexer, next, "", [], ""))) {
                throw createError(lexer, "the next state '" + action.next + "' is not defined in rule: " + ruleName);
              }
            }
          }
          newAction.next = next;
        }
      }
      if (typeof action.goBack === "number") {
        newAction.goBack = action.goBack;
      }
      if (typeof action.switchTo === "string") {
        newAction.switchTo = action.switchTo;
      }
      if (typeof action.log === "string") {
        newAction.log = action.log;
      }
      if (typeof action.nextEmbedded === "string") {
        newAction.nextEmbedded = action.nextEmbedded;
        lexer.usesEmbedded = true;
      }
      return newAction;
    }
  } else if (Array.isArray(action)) {
    const results = [];
    for (let i = 0, len = action.length; i < len; i++) {
      results[i] = compileAction(lexer, ruleName, action[i]);
    }
    return { group: results };
  } else if (action.cases) {
    const cases = [];
    for (const tkey in action.cases) {
      if (action.cases.hasOwnProperty(tkey)) {
        const val = compileAction(lexer, ruleName, action.cases[tkey]);
        if (tkey === "@default" || tkey === "@" || tkey === "") {
          cases.push({ test: void 0, value: val, name: tkey });
        } else if (tkey === "@eos") {
          cases.push({ test: function(id, matches, state, eos) {
            return eos;
          }, value: val, name: tkey });
        } else {
          cases.push(createGuard(lexer, ruleName, tkey, val));
        }
      }
    }
    const def = lexer.defaultToken;
    return {
      test: function(id, matches, state, eos) {
        for (const _case of cases) {
          const didmatch = !_case.test || _case.test(id, matches, state, eos);
          if (didmatch) {
            return _case.value;
          }
        }
        return def;
      }
    };
  } else {
    throw createError(lexer, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + ruleName);
  }
}
var Rule = class {
  constructor(name) {
    this.regex = new RegExp("");
    this.action = { token: "" };
    this.matchOnlyAtLineStart = false;
    this.name = "";
    this.name = name;
  }
  setRegex(lexer, re) {
    let sregex;
    if (typeof re === "string") {
      sregex = re;
    } else if (re instanceof RegExp) {
      sregex = re.source;
    } else {
      throw createError(lexer, "rules must start with a match string or regular expression: " + this.name);
    }
    this.matchOnlyAtLineStart = sregex.length > 0 && sregex[0] === "^";
    this.name = this.name + ": " + sregex;
    this.regex = compileRegExp(lexer, "^(?:" + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ")");
  }
  setAction(lexer, act) {
    this.action = compileAction(lexer, this.name, act);
  }
};
function compile(languageId, json) {
  if (!json || typeof json !== "object") {
    throw new Error("Monarch: expecting a language definition object");
  }
  const lexer = {};
  lexer.languageId = languageId;
  lexer.includeLF = bool(json.includeLF, false);
  lexer.noThrow = false;
  lexer.maxStack = 100;
  lexer.start = typeof json.start === "string" ? json.start : null;
  lexer.ignoreCase = bool(json.ignoreCase, false);
  lexer.unicode = bool(json.unicode, false);
  lexer.tokenPostfix = string(json.tokenPostfix, "." + lexer.languageId);
  lexer.defaultToken = string(json.defaultToken, "source");
  lexer.usesEmbedded = false;
  const lexerMin = json;
  lexerMin.languageId = languageId;
  lexerMin.includeLF = lexer.includeLF;
  lexerMin.ignoreCase = lexer.ignoreCase;
  lexerMin.unicode = lexer.unicode;
  lexerMin.noThrow = lexer.noThrow;
  lexerMin.usesEmbedded = lexer.usesEmbedded;
  lexerMin.stateNames = json.tokenizer;
  lexerMin.defaultToken = lexer.defaultToken;
  function addRules(state, newrules, rules) {
    for (const rule of rules) {
      let include = rule.include;
      if (include) {
        if (typeof include !== "string") {
          throw createError(lexer, "an 'include' attribute must be a string at: " + state);
        }
        if (include[0] === "@") {
          include = include.substr(1);
        }
        if (!json.tokenizer[include]) {
          throw createError(lexer, "include target '" + include + "' is not defined at: " + state);
        }
        addRules(state + "." + include, newrules, json.tokenizer[include]);
      } else {
        const newrule = new Rule(state);
        if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {
          newrule.setRegex(lexerMin, rule[0]);
          if (rule.length >= 3) {
            if (typeof rule[1] === "string") {
              newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });
            } else if (typeof rule[1] === "object") {
              const rule1 = rule[1];
              rule1.next = rule[2];
              newrule.setAction(lexerMin, rule1);
            } else {
              throw createError(lexer, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + state);
            }
          } else {
            newrule.setAction(lexerMin, rule[1]);
          }
        } else {
          if (!rule.regex) {
            throw createError(lexer, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + state);
          }
          if (rule.name) {
            if (typeof rule.name === "string") {
              newrule.name = rule.name;
            }
          }
          if (rule.matchOnlyAtStart) {
            newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart, false);
          }
          newrule.setRegex(lexerMin, rule.regex);
          newrule.setAction(lexerMin, rule.action);
        }
        newrules.push(newrule);
      }
    }
  }
  if (!json.tokenizer || typeof json.tokenizer !== "object") {
    throw createError(lexer, "a language definition must define the 'tokenizer' attribute as an object");
  }
  lexer.tokenizer = [];
  for (const key in json.tokenizer) {
    if (json.tokenizer.hasOwnProperty(key)) {
      if (!lexer.start) {
        lexer.start = key;
      }
      const rules = json.tokenizer[key];
      lexer.tokenizer[key] = new Array();
      addRules("tokenizer." + key, lexer.tokenizer[key], rules);
    }
  }
  lexer.usesEmbedded = lexerMin.usesEmbedded;
  if (json.brackets) {
    if (!Array.isArray(json.brackets)) {
      throw createError(lexer, "the 'brackets' attribute must be defined as an array");
    }
  } else {
    json.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  }
  const brackets = [];
  for (const el of json.brackets) {
    let desc = el;
    if (desc && Array.isArray(desc) && desc.length === 3) {
      desc = { token: desc[2], open: desc[0], close: desc[1] };
    }
    if (desc.open === desc.close) {
      throw createError(lexer, "open and close brackets in a 'brackets' attribute must be different: " + desc.open + "\n hint: use the 'bracket' attribute if matching on equal brackets is required.");
    }
    if (typeof desc.open === "string" && typeof desc.token === "string" && typeof desc.close === "string") {
      brackets.push({
        token: desc.token + lexer.tokenPostfix,
        open: fixCase(lexer, desc.open),
        close: fixCase(lexer, desc.close)
      });
    } else {
      throw createError(lexer, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
    }
  }
  lexer.brackets = brackets;
  lexer.noThrow = true;
  return lexer;
}

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneLanguages.js
function register(language) {
  ModesRegistry.registerLanguage(language);
}
function getLanguages() {
  let result = [];
  result = result.concat(ModesRegistry.getLanguages());
  return result;
}
function getEncodedLanguageId(languageId) {
  const languageService = StandaloneServices.get(ILanguageService);
  return languageService.languageIdCodec.encodeLanguageId(languageId);
}
function onLanguage(languageId, callback) {
  return StandaloneServices.withServices(() => {
    const languageService = StandaloneServices.get(ILanguageService);
    const disposable = languageService.onDidRequestRichLanguageFeatures((encounteredLanguageId) => {
      if (encounteredLanguageId === languageId) {
        disposable.dispose();
        callback();
      }
    });
    return disposable;
  });
}
function onLanguageEncountered(languageId, callback) {
  return StandaloneServices.withServices(() => {
    const languageService = StandaloneServices.get(ILanguageService);
    const disposable = languageService.onDidRequestBasicLanguageFeatures((encounteredLanguageId) => {
      if (encounteredLanguageId === languageId) {
        disposable.dispose();
        callback();
      }
    });
    return disposable;
  });
}
function setLanguageConfiguration(languageId, configuration) {
  const languageService = StandaloneServices.get(ILanguageService);
  if (!languageService.isRegisteredLanguageId(languageId)) {
    throw new Error(`Cannot set configuration for unknown language ${languageId}`);
  }
  const languageConfigurationService = StandaloneServices.get(ILanguageConfigurationService);
  return languageConfigurationService.register(languageId, configuration, 100);
}
var EncodedTokenizationSupportAdapter = class {
  constructor(languageId, actual) {
    this._languageId = languageId;
    this._actual = actual;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(line, hasEOL, state) {
    if (typeof this._actual.tokenize === "function") {
      return TokenizationSupportAdapter.adaptTokenize(this._languageId, this._actual, line, state);
    }
    throw new Error("Not supported!");
  }
  tokenizeEncoded(line, hasEOL, state) {
    const result = this._actual.tokenizeEncoded(line, state);
    return new EncodedTokenizationResult(result.tokens, result.endState);
  }
};
var TokenizationSupportAdapter = class _TokenizationSupportAdapter {
  constructor(_languageId, _actual, _languageService, _standaloneThemeService) {
    this._languageId = _languageId;
    this._actual = _actual;
    this._languageService = _languageService;
    this._standaloneThemeService = _standaloneThemeService;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(tokens, language) {
    const result = [];
    let previousStartIndex = 0;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const t = tokens[i];
      let startIndex = t.startIndex;
      if (i === 0) {
        startIndex = 0;
      } else if (startIndex < previousStartIndex) {
        startIndex = previousStartIndex;
      }
      result[i] = new Token(startIndex, t.scopes, language);
      previousStartIndex = startIndex;
    }
    return result;
  }
  static adaptTokenize(language, actual, line, state) {
    const actualResult = actual.tokenize(line, state);
    const tokens = _TokenizationSupportAdapter._toClassicTokens(actualResult.tokens, language);
    let endState;
    if (actualResult.endState.equals(state)) {
      endState = state;
    } else {
      endState = actualResult.endState;
    }
    return new TokenizationResult(tokens, endState);
  }
  tokenize(line, hasEOL, state) {
    return _TokenizationSupportAdapter.adaptTokenize(this._languageId, this._actual, line, state);
  }
  _toBinaryTokens(languageIdCodec, tokens) {
    const languageId = languageIdCodec.encodeLanguageId(this._languageId);
    const tokenTheme = this._standaloneThemeService.getColorTheme().tokenTheme;
    const result = [];
    let resultLen = 0;
    let previousStartIndex = 0;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const t = tokens[i];
      const metadata = tokenTheme.match(languageId, t.scopes) | 1024;
      if (resultLen > 0 && result[resultLen - 1] === metadata) {
        continue;
      }
      let startIndex = t.startIndex;
      if (i === 0) {
        startIndex = 0;
      } else if (startIndex < previousStartIndex) {
        startIndex = previousStartIndex;
      }
      result[resultLen++] = startIndex;
      result[resultLen++] = metadata;
      previousStartIndex = startIndex;
    }
    const actualResult = new Uint32Array(resultLen);
    for (let i = 0; i < resultLen; i++) {
      actualResult[i] = result[i];
    }
    return actualResult;
  }
  tokenizeEncoded(line, hasEOL, state) {
    const actualResult = this._actual.tokenize(line, state);
    const tokens = this._toBinaryTokens(this._languageService.languageIdCodec, actualResult.tokens);
    let endState;
    if (actualResult.endState.equals(state)) {
      endState = state;
    } else {
      endState = actualResult.endState;
    }
    return new EncodedTokenizationResult(tokens, endState);
  }
};
function isATokensProvider(provider) {
  return typeof provider.getInitialState === "function";
}
function isEncodedTokensProvider(provider) {
  return "tokenizeEncoded" in provider;
}
function isThenable2(obj) {
  return obj && typeof obj.then === "function";
}
function setColorMap(colorMap) {
  const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
  if (colorMap) {
    const result = [null];
    for (let i = 1, len = colorMap.length; i < len; i++) {
      result[i] = Color.fromHex(colorMap[i]);
    }
    standaloneThemeService.setColorMapOverride(result);
  } else {
    standaloneThemeService.setColorMapOverride(null);
  }
}
function createTokenizationSupportAdapter(languageId, provider) {
  if (isEncodedTokensProvider(provider)) {
    return new EncodedTokenizationSupportAdapter(languageId, provider);
  } else {
    return new TokenizationSupportAdapter(languageId, provider, StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService));
  }
}
function registerTokensProviderFactory(languageId, factory) {
  const adaptedFactory = new LazyTokenizationSupport(async () => {
    const result = await Promise.resolve(factory.create());
    if (!result) {
      return null;
    }
    if (isATokensProvider(result)) {
      return createTokenizationSupportAdapter(languageId, result);
    }
    return new MonarchTokenizer(StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService), languageId, compile(languageId, result), StandaloneServices.get(IConfigurationService));
  });
  return TokenizationRegistry.registerFactory(languageId, adaptedFactory);
}
function setTokensProvider(languageId, provider) {
  const languageService = StandaloneServices.get(ILanguageService);
  if (!languageService.isRegisteredLanguageId(languageId)) {
    throw new Error(`Cannot set tokens provider for unknown language ${languageId}`);
  }
  if (isThenable2(provider)) {
    return registerTokensProviderFactory(languageId, { create: () => provider });
  }
  return TokenizationRegistry.register(languageId, createTokenizationSupportAdapter(languageId, provider));
}
function setMonarchTokensProvider(languageId, languageDef) {
  const create2 = (languageDef2) => {
    return new MonarchTokenizer(StandaloneServices.get(ILanguageService), StandaloneServices.get(IStandaloneThemeService), languageId, compile(languageId, languageDef2), StandaloneServices.get(IConfigurationService));
  };
  if (isThenable2(languageDef)) {
    return registerTokensProviderFactory(languageId, { create: () => languageDef });
  }
  return TokenizationRegistry.register(languageId, create2(languageDef));
}
function registerReferenceProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.referenceProvider.register(languageSelector, provider);
}
function registerRenameProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.renameProvider.register(languageSelector, provider);
}
function registerSignatureHelpProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.signatureHelpProvider.register(languageSelector, provider);
}
function registerHoverProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.hoverProvider.register(languageSelector, {
    provideHover: (model, position, token) => {
      const word = model.getWordAtPosition(position);
      return Promise.resolve(provider.provideHover(model, position, token)).then((value) => {
        if (!value) {
          return void 0;
        }
        if (!value.range && word) {
          value.range = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
        }
        if (!value.range) {
          value.range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
        }
        return value;
      });
    }
  });
}
function registerDocumentSymbolProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentSymbolProvider.register(languageSelector, provider);
}
function registerDocumentHighlightProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentHighlightProvider.register(languageSelector, provider);
}
function registerLinkedEditingRangeProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.linkedEditingRangeProvider.register(languageSelector, provider);
}
function registerDefinitionProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.definitionProvider.register(languageSelector, provider);
}
function registerImplementationProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.implementationProvider.register(languageSelector, provider);
}
function registerTypeDefinitionProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.typeDefinitionProvider.register(languageSelector, provider);
}
function registerCodeLensProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.codeLensProvider.register(languageSelector, provider);
}
function registerCodeActionProvider(languageSelector, provider, metadata) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.codeActionProvider.register(languageSelector, {
    providedCodeActionKinds: metadata === null || metadata === void 0 ? void 0 : metadata.providedCodeActionKinds,
    documentation: metadata === null || metadata === void 0 ? void 0 : metadata.documentation,
    provideCodeActions: (model, range2, context, token) => {
      const markerService = StandaloneServices.get(IMarkerService);
      const markers = markerService.read({ resource: model.uri }).filter((m) => {
        return Range.areIntersectingOrTouching(m, range2);
      });
      return provider.provideCodeActions(model, range2, { markers, only: context.only, trigger: context.trigger }, token);
    },
    resolveCodeAction: provider.resolveCodeAction
  });
}
function registerDocumentFormattingEditProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentFormattingEditProvider.register(languageSelector, provider);
}
function registerDocumentRangeFormattingEditProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentRangeFormattingEditProvider.register(languageSelector, provider);
}
function registerOnTypeFormattingEditProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.onTypeFormattingEditProvider.register(languageSelector, provider);
}
function registerLinkProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.linkProvider.register(languageSelector, provider);
}
function registerCompletionItemProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.completionProvider.register(languageSelector, provider);
}
function registerColorProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.colorProvider.register(languageSelector, provider);
}
function registerFoldingRangeProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.foldingRangeProvider.register(languageSelector, provider);
}
function registerDeclarationProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.declarationProvider.register(languageSelector, provider);
}
function registerSelectionRangeProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.selectionRangeProvider.register(languageSelector, provider);
}
function registerDocumentSemanticTokensProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentSemanticTokensProvider.register(languageSelector, provider);
}
function registerDocumentRangeSemanticTokensProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.documentRangeSemanticTokensProvider.register(languageSelector, provider);
}
function registerInlineCompletionsProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.inlineCompletionsProvider.register(languageSelector, provider);
}
function registerInlayHintsProvider(languageSelector, provider) {
  const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
  return languageFeaturesService.inlayHintsProvider.register(languageSelector, provider);
}
function createMonacoLanguagesAPI() {
  return {
    register,
    getLanguages,
    onLanguage,
    onLanguageEncountered,
    getEncodedLanguageId,
    // provider methods
    setLanguageConfiguration,
    setColorMap,
    registerTokensProviderFactory,
    setTokensProvider,
    setMonarchTokensProvider,
    registerReferenceProvider,
    registerRenameProvider,
    registerCompletionItemProvider,
    registerSignatureHelpProvider,
    registerHoverProvider,
    registerDocumentSymbolProvider,
    registerDocumentHighlightProvider,
    registerLinkedEditingRangeProvider,
    registerDefinitionProvider,
    registerImplementationProvider,
    registerTypeDefinitionProvider,
    registerCodeLensProvider,
    registerCodeActionProvider,
    registerDocumentFormattingEditProvider,
    registerDocumentRangeFormattingEditProvider,
    registerOnTypeFormattingEditProvider,
    registerLinkProvider,
    registerColorProvider,
    registerFoldingRangeProvider,
    registerDeclarationProvider,
    registerSelectionRangeProvider,
    registerDocumentSemanticTokensProvider,
    registerDocumentRangeSemanticTokensProvider,
    registerInlineCompletionsProvider,
    registerInlayHintsProvider,
    // enums
    DocumentHighlightKind,
    CompletionItemKind,
    CompletionItemTag,
    CompletionItemInsertTextRule,
    SymbolKind,
    SymbolTag,
    IndentAction,
    CompletionTriggerKind,
    SignatureHelpTriggerKind,
    InlayHintKind,
    InlineCompletionTriggerKind,
    CodeActionTriggerType,
    // classes
    FoldingRangeKind,
    SelectedSuggestionInfo
  };
}

// node_modules/monaco-editor/esm/vs/platform/extensions/common/extensions.js
var ExtensionIdentifier = class {
  constructor(value) {
    this.value = value;
    this._lower = value.toLowerCase();
  }
  /**
   * Gives the value by which to index (for equality).
   */
  static toKey(id) {
    if (typeof id === "string") {
      return id.toLowerCase();
    }
    return id._lower;
  }
};
var ExtensionIdentifierSet = class {
  constructor(iterable) {
    this._set = /* @__PURE__ */ new Set();
    if (iterable) {
      for (const value of iterable) {
        this.add(value);
      }
    }
  }
  add(id) {
    this._set.add(ExtensionIdentifier.toKey(id));
  }
  has(id) {
    return this._set.has(ExtensionIdentifier.toKey(id));
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/format.js
function getRealAndSyntheticDocumentFormattersOrdered(documentFormattingEditProvider, documentRangeFormattingEditProvider, model) {
  const result = [];
  const seen = new ExtensionIdentifierSet();
  const docFormatter = documentFormattingEditProvider.ordered(model);
  for (const formatter of docFormatter) {
    result.push(formatter);
    if (formatter.extensionId) {
      seen.add(formatter.extensionId);
    }
  }
  const rangeFormatter = documentRangeFormattingEditProvider.ordered(model);
  for (const formatter of rangeFormatter) {
    if (formatter.extensionId) {
      if (seen.has(formatter.extensionId)) {
        continue;
      }
      seen.add(formatter.extensionId);
    }
    result.push({
      displayName: formatter.displayName,
      extensionId: formatter.extensionId,
      provideDocumentFormattingEdits(model2, options, token) {
        return formatter.provideDocumentRangeFormattingEdits(model2, model2.getFullModelRange(), options, token);
      }
    });
  }
  return result;
}
var FormattingConflicts = class _FormattingConflicts {
  static setFormatterSelector(selector) {
    const remove = _FormattingConflicts._selectors.unshift(selector);
    return { dispose: remove };
  }
  static async select(formatter, document2, mode) {
    if (formatter.length === 0) {
      return void 0;
    }
    const selector = Iterable.first(_FormattingConflicts._selectors);
    if (selector) {
      return await selector(formatter, document2, mode);
    }
    return void 0;
  }
};
FormattingConflicts._selectors = new LinkedList();
async function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range2, options, token) {
  const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);
  for (const provider of providers) {
    const rawEdits = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range2, options, token)).catch(onUnexpectedExternalError);
    if (isNonEmptyArray(rawEdits)) {
      return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
    }
  }
  return void 0;
}
async function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {
  const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);
  for (const provider of providers) {
    const rawEdits = await Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);
    if (isNonEmptyArray(rawEdits)) {
      return await workerService.computeMoreMinimalEdits(model.uri, rawEdits);
    }
  }
  return void 0;
}
function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {
  const providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
  if (providers.length === 0) {
    return Promise.resolve(void 0);
  }
  if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {
    return Promise.resolve(void 0);
  }
  return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then((edits) => {
    return workerService.computeMoreMinimalEdits(model.uri, edits);
  });
}
CommandsRegistry.registerCommand("_executeFormatRangeProvider", async function(accessor, ...args) {
  const [resource, range2, options] = args;
  assertType(URI.isUri(resource));
  assertType(Range.isIRange(range2));
  const resolverService = accessor.get(ITextModelService);
  const workerService = accessor.get(IEditorWorkerService);
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const reference = await resolverService.createModelReference(resource);
  try {
    return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range2), options, CancellationToken.None);
  } finally {
    reference.dispose();
  }
});
CommandsRegistry.registerCommand("_executeFormatDocumentProvider", async function(accessor, ...args) {
  const [resource, options] = args;
  assertType(URI.isUri(resource));
  const resolverService = accessor.get(ITextModelService);
  const workerService = accessor.get(IEditorWorkerService);
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const reference = await resolverService.createModelReference(resource);
  try {
    return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);
  } finally {
    reference.dispose();
  }
});
CommandsRegistry.registerCommand("_executeFormatOnTypeProvider", async function(accessor, ...args) {
  const [resource, position, ch, options] = args;
  assertType(URI.isUri(resource));
  assertType(Position.isIPosition(position));
  assertType(typeof ch === "string");
  const resolverService = accessor.get(ITextModelService);
  const workerService = accessor.get(IEditorWorkerService);
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const reference = await resolverService.createModelReference(resource);
  try {
    return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);
  } finally {
    reference.dispose();
  }
});

// node_modules/monaco-editor/esm/vs/editor/editor.api.js
EditorOptions.wrappingIndent.defaultValue = 0;
EditorOptions.glyphMargin.defaultValue = false;
EditorOptions.autoIndent.defaultValue = 3;
EditorOptions.overviewRulerLanes.defaultValue = 2;
FormattingConflicts.setFormatterSelector((formatter, document2, mode) => Promise.resolve(formatter[0]));
var api = createMonacoBaseAPI();
api.editor = createMonacoEditorAPI();
api.languages = createMonacoLanguagesAPI();
var CancellationTokenSource2 = api.CancellationTokenSource;
var Emitter2 = api.Emitter;
var KeyCode2 = api.KeyCode;
var KeyMod2 = api.KeyMod;
var Position2 = api.Position;
var Range3 = api.Range;
var Selection2 = api.Selection;
var SelectionDirection2 = api.SelectionDirection;
var MarkerSeverity3 = api.MarkerSeverity;
var MarkerTag2 = api.MarkerTag;
var Uri = api.Uri;
var Token2 = api.Token;
var editor = api.editor;
var languages = api.languages;
var monacoEnvironment = globalThis.MonacoEnvironment;
if ((monacoEnvironment === null || monacoEnvironment === void 0 ? void 0 : monacoEnvironment.globalAPI) || typeof define === "function" && define.amd) {
  globalThis.monaco = api;
}
if (typeof globalThis.require !== "undefined" && typeof globalThis.require.config === "function") {
  globalThis.require.config({
    ignoreDuplicateModules: [
      "vscode-languageserver-types",
      "vscode-languageserver-types/main",
      "vscode-languageserver-textdocument",
      "vscode-languageserver-textdocument/main",
      "vscode-nls",
      "vscode-nls/vscode-nls",
      "jsonc-parser",
      "jsonc-parser/main",
      "vscode-uri",
      "vscode-uri/index",
      "vs/basic-languages/typescript/typescript"
    ]
  });
}
export {
  CancellationTokenSource2 as CancellationTokenSource,
  Emitter2 as Emitter,
  KeyCode2 as KeyCode,
  KeyMod2 as KeyMod,
  MarkerSeverity3 as MarkerSeverity,
  MarkerTag2 as MarkerTag,
  Position2 as Position,
  Range3 as Range,
  Selection2 as Selection,
  SelectionDirection2 as SelectionDirection,
  Token2 as Token,
  Uri,
  editor,
  languages
};
//# sourceMappingURL=monaco-editor_esm_vs_editor_editor__api.js.map
