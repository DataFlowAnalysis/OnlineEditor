import {
  init_inversify,
  inversify_exports
} from "./chunk-RWN4KKDG.js";
import {
  require_model_utils
} from "./chunk-VAGWBBZP.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-6NOISVLF.js";

// node_modules/sprotty-elk/lib/elk-layout.js
var require_elk_layout = __commonJS({
  "node_modules/sprotty-elk/lib/elk-layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultLayoutConfigurator = exports.DefaultElementFilter = exports.ElkLayoutEngine = void 0;
    var model_utils_1 = require_model_utils();
    var ElkLayoutEngine = class {
      constructor(elkFactory, filter = new DefaultElementFilter(), configurator = new DefaultLayoutConfigurator(), preprocessor, postprocessor) {
        this.filter = filter;
        this.configurator = configurator;
        this.preprocessor = preprocessor;
        this.postprocessor = postprocessor;
        this.elk = elkFactory();
      }
      /**
       * Transform the Sprotty graph into an ELK graph, invoke the ELK layout engine,
       * apply the results to the original graph, and return it.
       *
       * _Note:_ The basic type of the root element must be `graph`.
       */
      layout(sgraph, index) {
        if (this.getBasicType(sgraph) !== "graph") {
          return sgraph;
        }
        if (!index) {
          index = new model_utils_1.SModelIndex();
          index.add(sgraph);
        }
        const elkGraph = this.transformGraph(sgraph, index);
        if (this.preprocessor) {
          this.preprocessor.preprocess(elkGraph, sgraph, index);
        }
        return this.elk.layout(elkGraph).then((result) => {
          if (this.postprocessor) {
            this.postprocessor.postprocess(result, sgraph, index);
          }
          this.applyLayout(result, index);
          return sgraph;
        });
      }
      /**
       * Determine the _basic type_ of the given model element. The layout engine supports
       * the following values: `graph`, `node`, `edge`, `label`, `port` and `compartment`
       */
      getBasicType(smodel) {
        return (0, model_utils_1.getBasicType)(smodel);
      }
      /**
       * Transform a Sprotty graph element to an ELK graph element.
       */
      transformGraph(sgraph, index) {
        const elkGraph = {
          id: sgraph.id,
          layoutOptions: this.configurator.apply(sgraph, index)
        };
        if (sgraph.children) {
          elkGraph.children = sgraph.children.filter((c) => this.getBasicType(c) === "node" && this.filter.apply(c, index)).map((c) => this.transformNode(c, index));
          elkGraph.edges = sgraph.children.filter((c) => this.getBasicType(c) === "edge" && this.filter.apply(c, index)).map((c) => this.transformEdge(c, index));
        }
        return elkGraph;
      }
      /**
       * Transform a Sprotty node element to an ELK node element.
       */
      transformNode(snode, index) {
        var _a, _b;
        var _c;
        const elkNode = {
          id: snode.id,
          layoutOptions: this.configurator.apply(snode, index)
        };
        if (snode.children) {
          const padding = { top: 0, right: 0, bottom: 0, left: 0 };
          elkNode.children = this.transformCompartment(snode, index, padding);
          if (padding.top !== 0 || padding.right !== 0 || padding.bottom !== 0 || padding.left !== 0) {
            (_a = elkNode.layoutOptions) !== null && _a !== void 0 ? _a : elkNode.layoutOptions = {};
            (_b = (_c = elkNode.layoutOptions)["org.eclipse.elk.padding"]) !== null && _b !== void 0 ? _b : _c["org.eclipse.elk.padding"] = `[top=${padding.top},left=${padding.left},bottom=${padding.bottom},right=${padding.right}]`;
          }
          elkNode.edges = snode.children.filter((c) => this.getBasicType(c) === "edge" && this.filter.apply(c, index)).map((c) => this.transformEdge(c, index));
          elkNode.labels = snode.children.filter((c) => this.getBasicType(c) === "label" && this.filter.apply(c, index)).map((c) => this.transformLabel(c, index));
          elkNode.ports = snode.children.filter((c) => this.getBasicType(c) === "port" && this.filter.apply(c, index)).map((c) => this.transformPort(c, index));
        }
        this.transformShape(elkNode, snode);
        return elkNode;
      }
      transformCompartment(scomp, index, padding) {
        if (!scomp.children) {
          return void 0;
        }
        const nodes = scomp.children.filter((c) => this.getBasicType(c) === "node" && this.filter.apply(c, index));
        if (nodes.length > 0) {
          return nodes.map((c) => this.transformNode(c, index));
        }
        for (const c of scomp.children) {
          if (this.getBasicType(c) === "compartment" && this.filter.apply(c, index)) {
            const ccomp = c;
            if (scomp.layout) {
              if (ccomp.position) {
                padding.left += ccomp.position.x;
                padding.top += ccomp.position.y;
              }
              if (ccomp.size && scomp.size) {
                padding.right += scomp.size.width - ccomp.size.width - (ccomp.position ? ccomp.position.x : 0);
                padding.bottom += scomp.size.height - ccomp.size.height - (ccomp.position ? ccomp.position.y : 0);
              }
            }
            const childNodes = this.transformCompartment(ccomp, index, padding);
            if (childNodes) {
              return childNodes;
            }
          }
        }
        return void 0;
      }
      /**
       * Transform a Sprotty edge element to an ELK edge element.
       */
      transformEdge(sedge, index) {
        const elkEdge = {
          id: sedge.id,
          sources: [sedge.sourceId],
          targets: [sedge.targetId],
          layoutOptions: this.configurator.apply(sedge, index)
        };
        if (sedge.children) {
          elkEdge.labels = sedge.children.filter((c) => this.getBasicType(c) === "label" && this.filter.apply(c, index)).map((c) => this.transformLabel(c, index));
        }
        const points = sedge.routingPoints;
        if (points && points.length >= 2) {
          elkEdge.sections = [{
            id: sedge.id + ":section",
            startPoint: points[0],
            bendPoints: points.slice(1, points.length - 1),
            endPoint: points[points.length - 1]
          }];
        }
        return elkEdge;
      }
      /**
       * Transform a Sprotty label element to an ELK label element.
       */
      transformLabel(slabel, index) {
        const elkLabel = {
          id: slabel.id,
          text: slabel.text,
          layoutOptions: this.configurator.apply(slabel, index)
        };
        this.transformShape(elkLabel, slabel);
        return elkLabel;
      }
      /**
       * Transform a Sprotty port element to an ELK port element.
       */
      transformPort(sport, index) {
        const elkPort = {
          id: sport.id,
          layoutOptions: this.configurator.apply(sport, index)
        };
        if (sport.children) {
          elkPort.labels = sport.children.filter((c) => this.getBasicType(c) === "label" && this.filter.apply(c, index)).map((c) => this.transformLabel(c, index));
        }
        this.transformShape(elkPort, sport);
        return elkPort;
      }
      /**
       * Copy the position and size of a Sprotty shape to an ELK shape.
       */
      transformShape(elkShape, sshape) {
        if (sshape.position) {
          elkShape.x = sshape.position.x;
          elkShape.y = sshape.position.y;
        }
        if (sshape.size) {
          elkShape.width = sshape.size.width;
          elkShape.height = sshape.size.height;
        }
      }
      /**
       * Apply the results of the ELK layout engine to the original Sprotty model.
       */
      applyLayout(elkNode, index) {
        const snode = index.getById(elkNode.id);
        if (snode && this.getBasicType(snode) === "node") {
          this.applyShape(snode, elkNode, index);
        }
        if (elkNode.children) {
          for (const child of elkNode.children) {
            this.applyLayout(child, index);
          }
        }
        if (elkNode.edges) {
          for (const elkEdge of elkNode.edges) {
            const sedge = index.getById(elkEdge.id);
            if (sedge && this.getBasicType(sedge) === "edge") {
              this.applyEdge(sedge, elkEdge, index);
            }
          }
        }
        if (elkNode.ports) {
          for (const elkPort of elkNode.ports) {
            const sport = index.getById(elkPort.id);
            if (sport && this.getBasicType(sport) === "port") {
              this.applyShape(sport, elkPort, index);
            }
          }
        }
      }
      /**
       * Apply shape layout results, i.e. position and size.
       */
      applyShape(sshape, elkShape, index) {
        if (elkShape.x !== void 0 && elkShape.y !== void 0) {
          sshape.position = { x: elkShape.x, y: elkShape.y };
        }
        if (elkShape.width !== void 0 && elkShape.height !== void 0) {
          sshape.size = { width: elkShape.width, height: elkShape.height };
        }
        if (elkShape.labels) {
          for (const elkLabel of elkShape.labels) {
            const slabel = elkLabel.id && index.getById(elkLabel.id);
            if (slabel) {
              this.applyShape(slabel, elkLabel, index);
            }
          }
        }
      }
      /**
       * Apply edge layout results, i.e. start point, end point and bend points.
       */
      applyEdge(sedge, elkEdge, index) {
        const points = [];
        if (elkEdge.sections && elkEdge.sections.length > 0) {
          const section = elkEdge.sections[0];
          if (section.startPoint) {
            points.push(section.startPoint);
          }
          if (section.bendPoints) {
            points.push(...section.bendPoints);
          }
          if (section.endPoint) {
            points.push(section.endPoint);
          }
        } else if (isPrimitiveEdge(elkEdge)) {
          if (elkEdge.sourcePoint) {
            points.push(elkEdge.sourcePoint);
          }
          if (elkEdge.bendPoints) {
            points.push(...elkEdge.bendPoints);
          }
          if (elkEdge.targetPoint) {
            points.push(elkEdge.targetPoint);
          }
        }
        sedge.routingPoints = points;
        if (elkEdge.labels) {
          elkEdge.labels.forEach((elkLabel) => {
            const sLabel = elkLabel.id && index.getById(elkLabel.id);
            if (sLabel) {
              this.applyShape(sLabel, elkLabel, index);
            }
          });
        }
      }
    };
    exports.ElkLayoutEngine = ElkLayoutEngine;
    function isPrimitiveEdge(edge) {
      return typeof edge.source === "string" && typeof edge.target === "string";
    }
    var DefaultElementFilter = class {
      apply(element, index) {
        switch (this.getBasicType(element)) {
          case "node":
            return this.filterNode(element, index);
          case "edge":
            return this.filterEdge(element, index);
          case "label":
            return this.filterLabel(element, index);
          case "port":
            return this.filterPort(element, index);
          case "compartment":
            return this.filterCompartment(element, index);
          default:
            return true;
        }
      }
      getBasicType(smodel) {
        return (0, model_utils_1.getBasicType)(smodel);
      }
      filterNode(node, index) {
        return true;
      }
      filterEdge(edge, index) {
        const source = index.getById(edge.sourceId);
        if (!source)
          return false;
        const sourceType = this.getBasicType(source);
        if (sourceType === "node" && !this.filterNode(source, index) || sourceType === "port" && !this.filterPort(source, index))
          return false;
        const target = index.getById(edge.targetId);
        if (!target)
          return false;
        const targetType = this.getBasicType(target);
        if (targetType === "node" && !this.filterNode(target, index) || targetType === "port" && !this.filterPort(target, index))
          return false;
        return true;
      }
      filterLabel(label, index) {
        return true;
      }
      filterPort(port, index) {
        return true;
      }
      filterCompartment(compartment, index) {
        return true;
      }
    };
    exports.DefaultElementFilter = DefaultElementFilter;
    var DefaultLayoutConfigurator = class {
      apply(element, index) {
        switch (this.getBasicType(element)) {
          case "graph":
            return this.graphOptions(element, index);
          case "node":
            return this.nodeOptions(element, index);
          case "edge":
            return this.edgeOptions(element, index);
          case "label":
            return this.labelOptions(element, index);
          case "port":
            return this.portOptions(element, index);
          default:
            return void 0;
        }
      }
      getBasicType(smodel) {
        return (0, model_utils_1.getBasicType)(smodel);
      }
      graphOptions(sgraph, index) {
        return void 0;
      }
      nodeOptions(snode, index) {
        return void 0;
      }
      edgeOptions(sedge, index) {
        return void 0;
      }
      labelOptions(slabel, index) {
        return void 0;
      }
      portOptions(sport, index) {
        return void 0;
      }
    };
    exports.DefaultLayoutConfigurator = DefaultLayoutConfigurator;
  }
});

// node_modules/sprotty-elk/lib/inversify.js
var require_inversify = __commonJS({
  "node_modules/sprotty-elk/lib/inversify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.elkLayoutModule = exports.ILayoutPostprocessor = exports.ILayoutPreprocessor = exports.DefaultLayoutConfigurator = exports.ILayoutConfigurator = exports.DefaultElementFilter = exports.IElementFilter = exports.ElkFactory = exports.ElkLayoutEngine = void 0;
    var inversify_1 = (init_inversify(), __toCommonJS(inversify_exports));
    var elk_layout_1 = require_elk_layout();
    exports.ElkLayoutEngine = (0, inversify_1.injectable)()(elk_layout_1.ElkLayoutEngine);
    exports.ElkFactory = Symbol("ElkFactory");
    exports.IElementFilter = Symbol("IElementFilter");
    exports.DefaultElementFilter = (0, inversify_1.injectable)()(elk_layout_1.DefaultElementFilter);
    exports.ILayoutConfigurator = Symbol("ILayoutConfigurator");
    exports.DefaultLayoutConfigurator = (0, inversify_1.injectable)()(elk_layout_1.DefaultLayoutConfigurator);
    exports.ILayoutPreprocessor = Symbol("ILayoutPreprocessor");
    exports.ILayoutPostprocessor = Symbol("ILayoutPostprocessor");
    exports.elkLayoutModule = new inversify_1.ContainerModule((bind) => {
      bind(exports.ElkLayoutEngine).toDynamicValue((context) => {
        const elkFactory = context.container.get(exports.ElkFactory);
        const elementFilter = context.container.get(exports.IElementFilter);
        const layoutConfigurator = context.container.get(exports.ILayoutConfigurator);
        const layoutPreprocessor = context.container.isBound(exports.ILayoutPreprocessor) ? context.container.get(exports.ILayoutPreprocessor) : void 0;
        const layoutPostprocessor = context.container.isBound(exports.ILayoutPostprocessor) ? context.container.get(exports.ILayoutPostprocessor) : void 0;
        return new exports.ElkLayoutEngine(elkFactory, elementFilter, layoutConfigurator, layoutPreprocessor, layoutPostprocessor);
      }).inSingletonScope();
      bind(exports.IElementFilter).to(exports.DefaultElementFilter);
      bind(exports.ILayoutConfigurator).to(exports.DefaultLayoutConfigurator);
    });
  }
});

// node_modules/sprotty-elk/lib/index.js
var require_lib = __commonJS({
  "node_modules/sprotty-elk/lib/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_inversify(), exports);
  }
});
export default require_lib();
//# sourceMappingURL=sprotty-elk.js.map
