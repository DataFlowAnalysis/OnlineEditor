{
  "version": 3,
  "sources": ["../../sprotty-elk/src/elk-layout.ts", "../../sprotty-elk/src/inversify.ts", "../../sprotty-elk/src/index.ts"],
  "sourcesContent": ["/********************************************************************************\n * Copyright (c) 2018-2022 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {\n    ELK, ElkNode, ElkLabel, ElkPort, ElkShape, ElkExtendedEdge, LayoutOptions, ElkPrimitiveEdge\n} from 'elkjs/lib/elk-api';\nimport { IModelLayoutEngine } from 'sprotty-protocol/lib/diagram-services';\nimport { SCompartment, SEdge, SGraph, SLabel, SModelElement, SNode, SPort, SShapeElement } from 'sprotty-protocol/lib/model';\nimport { Point } from 'sprotty-protocol/lib/utils/geometry';\nimport { getBasicType, SModelIndex } from 'sprotty-protocol/lib/utils/model-utils';\n\n/**\n * Layout engine that delegates to ELK by transforming the Sprotty graph into an ELK graph.\n *\n * This layout engine requires that the _basic type_ of every model element conforms to the\n * convention: `graph` for the top-level element, `node` for nodes, `edge` for edges, `label`\n * for labels, and `port` for ports. The basic type is either the value of the `type` property\n * or the substring preceding the separator `:` if present. Example: `'node:state'` is\n * interpreted as a node, while `'edge:transition'` is interpreted as an edge.\n */\nexport class ElkLayoutEngine implements IModelLayoutEngine {\n\n    protected readonly elk: ELK;\n\n    constructor(elkFactory: ElkFactory,\n                protected readonly filter: IElementFilter = new DefaultElementFilter(),\n                protected readonly configurator: ILayoutConfigurator = new DefaultLayoutConfigurator(),\n                protected readonly preprocessor?: ILayoutPreprocessor,\n                protected readonly postprocessor?: ILayoutPostprocessor) {\n        this.elk = elkFactory();\n    }\n\n    /**\n     * Transform the Sprotty graph into an ELK graph, invoke the ELK layout engine,\n     * apply the results to the original graph, and return it.\n     *\n     * _Note:_ The basic type of the root element must be `graph`.\n     */\n    layout(sgraph: SGraph, index?: SModelIndex): SGraph | Promise<SGraph> {\n        if (this.getBasicType(sgraph) !== 'graph') {\n            return sgraph;\n        }\n        if (!index) {\n            index = new SModelIndex();\n            index.add(sgraph);\n        }\n\n        // STEP 1: Transform the Sprotty graph into an ELK graph with optional pre-processing\n        const elkGraph = this.transformGraph(sgraph, index);\n        if (this.preprocessor) {\n            this.preprocessor.preprocess(elkGraph, sgraph, index);\n        }\n\n        // STEP 2: Invoke the ELK layout engine\n        return this.elk.layout(elkGraph).then(result => {\n\n            // STEP 3: Apply the results with optional post-processing to the original graph\n            if (this.postprocessor) {\n                this.postprocessor.postprocess(result, sgraph, index!);\n            }\n            this.applyLayout(result, index!);\n            return sgraph;\n        });\n    }\n\n    /**\n     * Determine the _basic type_ of the given model element. The layout engine supports\n     * the following values: `graph`, `node`, `edge`, `label`, `port` and `compartment`\n     */\n    protected getBasicType(smodel: SModelElement): string {\n        return getBasicType(smodel);\n    }\n\n    /**\n     * Transform a Sprotty graph element to an ELK graph element.\n     */\n    protected transformGraph(sgraph: SGraph, index: SModelIndex): ElkNode {\n        const elkGraph: ElkNode = {\n            id: sgraph.id,\n            layoutOptions: this.configurator.apply(sgraph, index)\n        };\n        if (sgraph.children) {\n            elkGraph.children = sgraph.children\n                .filter(c => this.getBasicType(c) === 'node' && this.filter.apply(c, index))\n                .map(c => this.transformNode(c as SNode, index));\n            elkGraph.edges = sgraph.children\n                .filter(c => this.getBasicType(c) === 'edge' && this.filter.apply(c, index))\n                .map(c => this.transformEdge(c as SEdge, index));\n        }\n        return elkGraph;\n    }\n\n    /**\n     * Transform a Sprotty node element to an ELK node element.\n     */\n    protected transformNode(snode: SNode, index: SModelIndex): ElkNode {\n        const elkNode: ElkNode = {\n            id: snode.id,\n            layoutOptions: this.configurator.apply(snode, index)\n        };\n        if (snode.children) {\n            const padding: LayoutPadding = { top: 0, right: 0, bottom: 0, left: 0 };\n            elkNode.children = this.transformCompartment(snode, index, padding);\n            if (padding.top !== 0 || padding.right !== 0 || padding.bottom !== 0 || padding.left !== 0) {\n                elkNode.layoutOptions ??= {};\n                elkNode.layoutOptions['org.eclipse.elk.padding'] ??= `[top=${padding.top},left=${padding.left},bottom=${padding.bottom},right=${padding.right}]`;\n            }\n            elkNode.edges = snode.children\n                .filter(c => this.getBasicType(c) === 'edge' && this.filter.apply(c, index))\n                .map(c => this.transformEdge(c as SEdge, index));\n            elkNode.labels = snode.children\n                .filter(c => this.getBasicType(c) === 'label' && this.filter.apply(c, index))\n                .map(c => this.transformLabel(c as SLabel, index));\n            elkNode.ports = snode.children\n                .filter(c => this.getBasicType(c) === 'port' && this.filter.apply(c, index))\n                .map(c => this.transformPort(c as SPort, index));\n        }\n        this.transformShape(elkNode, snode);\n        return elkNode;\n    }\n\n    protected transformCompartment(scomp: SNode | SCompartment, index: SModelIndex, padding: LayoutPadding): ElkNode[] | undefined {\n        if (!scomp.children) {\n            return undefined;\n        }\n        const nodes = scomp.children.filter(c => this.getBasicType(c) === 'node' && this.filter.apply(c, index));\n        if (nodes.length > 0) {\n            return nodes.map(c => this.transformNode(c as SNode, index));\n        }\n        for (const c of scomp.children) {\n            if (this.getBasicType(c) === 'compartment' && this.filter.apply(c, index)) {\n                const ccomp = c as SCompartment;\n                if (scomp.layout) {\n                    if (ccomp.position) {\n                        padding.left += ccomp.position.x;\n                        padding.top += ccomp.position.y;\n                    }\n                    if (ccomp.size && scomp.size) {\n                        padding.right += scomp.size.width - ccomp.size.width - (ccomp.position ? ccomp.position.x : 0);\n                        padding.bottom += scomp.size.height - ccomp.size.height - (ccomp.position ? ccomp.position.y : 0);\n                    }\n                }\n                const childNodes = this.transformCompartment(ccomp, index, padding);\n                if (childNodes) {\n                    return childNodes;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Transform a Sprotty edge element to an ELK edge element.\n     */\n    protected transformEdge(sedge: SEdge, index: SModelIndex): ElkExtendedEdge {\n        const elkEdge: ElkExtendedEdge = {\n            id: sedge.id,\n            sources: [sedge.sourceId],\n            targets: [sedge.targetId],\n            layoutOptions: this.configurator.apply(sedge, index)\n        };\n        if (sedge.children) {\n            elkEdge.labels = sedge.children\n                .filter(c => this.getBasicType(c) === 'label' && this.filter.apply(c, index))\n                .map(c => this.transformLabel(c as SLabel, index));\n        }\n        const points = sedge.routingPoints;\n        if (points && points.length >= 2) {\n            elkEdge.sections = [{\n                id: sedge.id + ':section',\n                startPoint: points[0],\n                bendPoints: points.slice(1, points.length - 1),\n                endPoint: points[points.length - 1]\n            }];\n        }\n        return elkEdge;\n    }\n\n    /**\n     * Transform a Sprotty label element to an ELK label element.\n     */\n    protected transformLabel(slabel: SLabel, index: SModelIndex): ElkLabel {\n        const elkLabel: ElkLabel = {\n            id: slabel.id,\n            text: slabel.text,\n            layoutOptions: this.configurator.apply(slabel, index)\n        };\n        this.transformShape(elkLabel, slabel);\n        return elkLabel;\n    }\n\n    /**\n     * Transform a Sprotty port element to an ELK port element.\n     */\n    protected transformPort(sport: SPort, index: SModelIndex): ElkPort {\n        const elkPort: ElkPort = {\n            id: sport.id,\n            layoutOptions: this.configurator.apply(sport, index)\n        };\n        if (sport.children) {\n            elkPort.labels = sport.children\n                .filter(c => this.getBasicType(c) === 'label' && this.filter.apply(c, index))\n                .map(c => this.transformLabel(c as SLabel, index));\n        }\n        this.transformShape(elkPort, sport);\n        return elkPort;\n    }\n\n    /**\n     * Copy the position and size of a Sprotty shape to an ELK shape.\n     */\n    protected transformShape(elkShape: ElkShape, sshape: SShapeElement): void {\n        if (sshape.position) {\n            elkShape.x = sshape.position.x;\n            elkShape.y = sshape.position.y;\n        }\n        if (sshape.size) {\n            elkShape.width = sshape.size.width;\n            elkShape.height = sshape.size.height;\n        }\n    }\n\n    /**\n     * Apply the results of the ELK layout engine to the original Sprotty model.\n     */\n    protected applyLayout(elkNode: ElkNode, index: SModelIndex): void {\n        const snode = index.getById(elkNode.id);\n        if (snode && this.getBasicType(snode) === 'node') {\n            this.applyShape(snode as SNode, elkNode, index);\n        }\n        if (elkNode.children) {\n            for (const child of elkNode.children) {\n                this.applyLayout(child, index);\n            }\n        }\n        if (elkNode.edges) {\n            for (const elkEdge of elkNode.edges) {\n                const sedge = index.getById(elkEdge.id);\n                if (sedge && this.getBasicType(sedge) === 'edge') {\n                    this.applyEdge(sedge as SEdge, elkEdge, index);\n                }\n            }\n        }\n        if (elkNode.ports) {\n            for (const elkPort of elkNode.ports) {\n                const sport = index.getById(elkPort.id);\n                if (sport && this.getBasicType(sport) === 'port') {\n                    this.applyShape(sport as SPort, elkPort, index);\n                }\n            }\n        }\n    }\n\n    /**\n     * Apply shape layout results, i.e. position and size.\n     */\n    protected applyShape(sshape: SShapeElement, elkShape: ElkShape, index: SModelIndex): void {\n        if (elkShape.x !== undefined && elkShape.y !== undefined) {\n            sshape.position = { x: elkShape.x, y: elkShape.y };\n        }\n        if (elkShape.width !== undefined && elkShape.height !== undefined) {\n            sshape.size = { width: elkShape.width, height: elkShape.height };\n        }\n\n        if (elkShape.labels) {\n            for (const elkLabel of elkShape.labels) {\n                const slabel = elkLabel.id && index.getById(elkLabel.id);\n                if (slabel) {\n                    this.applyShape(slabel as SLabel, elkLabel, index);\n                }\n            }\n        }\n    }\n\n    /**\n     * Apply edge layout results, i.e. start point, end point and bend points.\n     */\n    protected applyEdge(sedge: SEdge, elkEdge: ElkExtendedEdge, index: SModelIndex): void {\n        const points: Point[] = [];\n        if (elkEdge.sections && elkEdge.sections.length > 0) {\n            const section = elkEdge.sections[0];\n            if (section.startPoint) {\n                points.push(section.startPoint);\n            }\n            if (section.bendPoints) {\n                points.push(...section.bendPoints);\n            }\n            if (section.endPoint) {\n                points.push(section.endPoint);\n            }\n        } else if (isPrimitiveEdge(elkEdge)) {\n            if (elkEdge.sourcePoint) {\n                points.push(elkEdge.sourcePoint);\n            }\n            if (elkEdge.bendPoints) {\n                points.push(...elkEdge.bendPoints);\n            }\n            if (elkEdge.targetPoint) {\n                points.push(elkEdge.targetPoint);\n            }\n        }\n        sedge.routingPoints = points;\n\n        if (elkEdge.labels) {\n            elkEdge.labels.forEach((elkLabel) => {\n                const sLabel = elkLabel.id && index.getById(elkLabel.id);\n                if (sLabel) {\n                    this.applyShape(sLabel, elkLabel, index);\n                }\n            });\n        }\n    }\n\n}\n\nfunction isPrimitiveEdge(edge: unknown): edge is ElkPrimitiveEdge {\n    return typeof (edge as ElkPrimitiveEdge).source === 'string'\n        && typeof (edge as ElkPrimitiveEdge).target === 'string';\n}\n\n/**\n * Factory for ELK instances. Follow the elkjs package documentation on how to configure ELK\n * instances. For example, the bundled version can be used by importing the ELK constructor\n * from `\"elkjs/lib/elk.bundled\"`. For the webworker version, import the constructor from\n * `\"elkjs/lib/elk-api\"` and add the option `workerUrl: \"elk/elk-worker.min.js\"`.\n */\nexport type ElkFactory = () => ELK;\n\n/**\n * Filter used to determine which model elements should be included in the automatic layout.\n */\nexport interface IElementFilter {\n    apply(element: SModelElement, index: SModelIndex): boolean\n}\n\nexport class DefaultElementFilter implements IElementFilter {\n\n    apply(element: SModelElement, index: SModelIndex): boolean {\n        switch (this.getBasicType(element)) {\n            case 'node':\n                return this.filterNode(element as SNode, index);\n            case 'edge':\n                return this.filterEdge(element as SEdge, index);\n            case 'label':\n                return this.filterLabel(element as SLabel, index);\n            case 'port':\n                return this.filterPort(element as SPort, index);\n            case 'compartment':\n                return this.filterCompartment(element as SCompartment, index);\n            default:\n                return true;\n        }\n    }\n\n    protected getBasicType(smodel: SModelElement): string{\n        return getBasicType(smodel);\n    }\n\n    protected filterNode(node: SNode, index: SModelIndex): boolean {\n        return true;\n    }\n\n    protected filterEdge(edge: SEdge, index: SModelIndex): boolean {\n        const source = index.getById(edge.sourceId);\n        if (!source)\n            return false;\n        const sourceType = this.getBasicType(source);\n        if (sourceType === 'node' && !this.filterNode(source, index)\n            || sourceType === 'port' && !this.filterPort(source, index))\n            return false;\n        const target = index.getById(edge.targetId);\n        if (!target)\n            return false;\n        const targetType = this.getBasicType(target);\n        if (targetType === 'node' && !this.filterNode(target, index)\n            || targetType === 'port' && !this.filterPort(target, index))\n            return false;\n        return true;\n    }\n\n    protected filterLabel(label: SLabel, index: SModelIndex): boolean {\n        return true;\n    }\n\n    protected filterPort(port: SPort, index: SModelIndex): boolean {\n        return true;\n    }\n\n    protected filterCompartment(compartment: SCompartment, index: SModelIndex): boolean {\n        return true;\n    }\n\n}\n\n/**\n * Configurator of layout algorithms; provides mappings of layout options for each model element.\n */\nexport interface ILayoutConfigurator {\n    apply(element: SModelElement, index: SModelIndex): LayoutOptions | undefined\n}\n\nexport class DefaultLayoutConfigurator implements ILayoutConfigurator {\n\n    apply(element: SModelElement, index: SModelIndex): LayoutOptions | undefined {\n        switch (this.getBasicType(element)) {\n            case 'graph':\n                return this.graphOptions(element as SGraph, index);\n            case 'node':\n                return this.nodeOptions(element as SNode, index);\n            case 'edge':\n                return this.edgeOptions(element as SEdge, index);\n            case 'label':\n                return this.labelOptions(element as SLabel, index);\n            case 'port':\n                return this.portOptions(element as SPort, index);\n            default:\n                return undefined;\n        }\n    }\n\n    protected getBasicType(smodel: SModelElement): string{\n        return getBasicType(smodel);\n    }\n\n    protected graphOptions(sgraph: SGraph, index: SModelIndex): LayoutOptions | undefined {\n        return undefined;\n    }\n\n    protected nodeOptions(snode: SNode, index: SModelIndex): LayoutOptions | undefined {\n        return undefined;\n    }\n\n    protected edgeOptions(sedge: SEdge, index: SModelIndex): LayoutOptions | undefined {\n        return undefined;\n    }\n\n    protected labelOptions(slabel: SLabel, index: SModelIndex): LayoutOptions | undefined {\n        return undefined;\n    }\n\n    protected portOptions(sport: SPort, index: SModelIndex): LayoutOptions | undefined {\n        return undefined;\n    }\n\n}\n\nexport interface ILayoutPreprocessor {\n    preprocess(elkGraph: ElkNode, sgraph: SGraph, index: SModelIndex): void\n}\n\nexport interface ILayoutPostprocessor {\n    postprocess(elkGraph: ElkNode, sgraph: SGraph, index: SModelIndex): void\n}\n\nexport type LayoutPadding = {\n    top: number,\n    right: number,\n    bottom: number,\n    left: number\n};\n", "/********************************************************************************\n * Copyright (c) 2018-2021 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { ContainerModule, injectable } from 'inversify';\nimport {\n    ElkLayoutEngine as ElkLayoutEnginePlain, DefaultElementFilter as DefaultElementFilterPlain,\n    DefaultLayoutConfigurator as DefaultLayoutConfiguratorPlain, ElkFactory as ElkFactoryPlain,\n    IElementFilter as IElementFilterPlain, ILayoutConfigurator as ILayoutConfiguratorPlain,\n    ILayoutPreprocessor as ILayoutPreprocessorPlain, ILayoutPostprocessor as ILayoutPostprocessorPlain\n} from './elk-layout';\n\nexport const ElkLayoutEngine: typeof ElkLayoutEnginePlain = injectable()(ElkLayoutEnginePlain);\n\nexport type ElkFactory = ElkFactoryPlain;\nexport const ElkFactory = Symbol('ElkFactory');\n\nexport type IElementFilter = IElementFilterPlain;\nexport const IElementFilter = Symbol('IElementFilter');\nexport const DefaultElementFilter: typeof DefaultElementFilterPlain = injectable()(DefaultElementFilterPlain);\n\nexport type ILayoutConfigurator = ILayoutConfiguratorPlain;\nexport const ILayoutConfigurator = Symbol('ILayoutConfigurator');\nexport const DefaultLayoutConfigurator: typeof DefaultLayoutConfiguratorPlain = injectable()(DefaultLayoutConfiguratorPlain);\n\nexport type ILayoutPreprocessor = ILayoutPreprocessorPlain;\nexport const ILayoutPreprocessor = Symbol('ILayoutPreprocessor');\n\nexport type ILayoutPostprocessor = ILayoutPostprocessorPlain;\nexport const ILayoutPostprocessor = Symbol('ILayoutPostprocessor');\n\n/**\n * This dependency injection module adds the default bindings for the frontend integration of ELK.\n * **Note:** Since this package has no direct dependency to the `sprotty` frontend package,\n * this module does not include a binding for `TYPES.IModelLayoutEngine`. Add it like this:\n * ```\n * bind(TYPES.IModelLayoutEngine).toService(ElkLayoutEngine);\n * ```\n * Furthermore, you need to add a binding for `ElkFactory` and choose between the bundled or the\n * webworker variant of `elkjs`:\n * ```\n * const elkFactory: ElkFactory = () => new ElkConstructor({ ... }); // See elkjs documentation\n * bind(ElkFactory).toConstantValue(elkFactory);\n * ```\n * You can import `ElkConstructor` from `'elkjs/lib/elk.bundled'` for the bundled variant or\n * `'elkjs/lib/elk-api'` for the webworker variant.\n */\nexport const elkLayoutModule = new ContainerModule(bind => {\n    bind(ElkLayoutEngine).toDynamicValue(context => {\n        const elkFactory = context.container.get<ElkFactory>(ElkFactory);\n        const elementFilter = context.container.get<IElementFilter>(IElementFilter);\n        const layoutConfigurator = context.container.get<ILayoutConfigurator>(ILayoutConfigurator);\n        const layoutPreprocessor = context.container.isBound(ILayoutPreprocessor)\n            ? context.container.get<ILayoutPreprocessor>(ILayoutPreprocessor) : undefined;\n        const layoutPostprocessor = context.container.isBound(ILayoutPostprocessor)\n            ? context.container.get<ILayoutPostprocessor>(ILayoutPostprocessor) : undefined;\n        return new ElkLayoutEngine(elkFactory, elementFilter, layoutConfigurator, layoutPreprocessor, layoutPostprocessor);\n    }).inSingletonScope();\n    bind(IElementFilter).to(DefaultElementFilter);\n    bind(ILayoutConfigurator).to(DefaultLayoutConfigurator);\n});\n", "/********************************************************************************\n * Copyright (c) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n// By default we export the Inversify-ready version. If you want to use the plain\n// version, import from `sprotty-elk/lib/elk-layout`.\nexport * from './inversify';\n"],
  "mappings": "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",
  "names": []
}
