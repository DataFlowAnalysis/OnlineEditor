import {
  __commonJS
} from "./chunk-6NOISVLF.js";

// node_modules/sprotty-protocol/lib/utils/model-utils.js
var require_model_utils = __commonJS({
  "node_modules/sprotty-protocol/lib/utils/model-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SModelIndex = exports.findElement = exports.getSubType = exports.getBasicType = exports.applyBounds = exports.cloneModel = void 0;
    function cloneModel(model) {
      return JSON.parse(JSON.stringify(model));
    }
    exports.cloneModel = cloneModel;
    function applyBounds(root, action) {
      const index = new SModelIndex();
      index.add(root);
      for (const b of action.bounds) {
        const element = index.getById(b.elementId);
        if (element) {
          const bae = element;
          if (b.newPosition) {
            bae.position = { x: b.newPosition.x, y: b.newPosition.y };
          }
          if (b.newSize) {
            bae.size = { width: b.newSize.width, height: b.newSize.height };
          }
        }
      }
      if (action.alignments) {
        for (const a of action.alignments) {
          const element = index.getById(a.elementId);
          if (element) {
            const alignable = element;
            alignable.alignment = { x: a.newAlignment.x, y: a.newAlignment.y };
          }
        }
      }
    }
    exports.applyBounds = applyBounds;
    function getBasicType(element) {
      if (!element.type) {
        return "";
      }
      const colonIndex = element.type.indexOf(":");
      return colonIndex >= 0 ? element.type.substring(0, colonIndex) : element.type;
    }
    exports.getBasicType = getBasicType;
    function getSubType(schema) {
      if (!schema.type) {
        return "";
      }
      const colonIndex = schema.type.indexOf(":");
      return colonIndex >= 0 ? schema.type.substring(colonIndex + 1) : schema.type;
    }
    exports.getSubType = getSubType;
    function findElement(parent, elementId) {
      if (parent.id === elementId)
        return parent;
      if (parent.children !== void 0) {
        for (const child of parent.children) {
          const result = findElement(child, elementId);
          if (result !== void 0)
            return result;
        }
      }
      return void 0;
    }
    exports.findElement = findElement;
    var SModelIndex = class {
      constructor() {
        this.id2element = /* @__PURE__ */ new Map();
        this.id2parent = /* @__PURE__ */ new Map();
      }
      add(element) {
        if (!element.id) {
          throw new Error("Model element has no ID.");
        } else if (this.contains(element)) {
          throw new Error("Duplicate ID in model: " + element.id);
        }
        this.id2element.set(element.id, element);
        if (Array.isArray(element.children)) {
          for (const child of element.children) {
            this.add(child);
            this.id2parent.set(child.id, element);
          }
        }
      }
      remove(element) {
        this.id2element.delete(element.id);
        if (Array.isArray(element.children)) {
          for (const child of element.children) {
            this.id2parent.delete(child.id);
            this.remove(child);
          }
        }
      }
      contains(element) {
        return this.id2element.has(element.id);
      }
      getById(id) {
        return this.id2element.get(id);
      }
      getParent(id) {
        return this.id2parent.get(id);
      }
      getRoot(element) {
        let current = element;
        while (current) {
          const parent = this.id2parent.get(current.id);
          if (parent === void 0) {
            return current;
          }
          current = parent;
        }
        throw new Error("Element has no root");
      }
    };
    exports.SModelIndex = SModelIndex;
  }
});

export {
  require_model_utils
};
//# sourceMappingURL=chunk-VAGWBBZP.js.map
