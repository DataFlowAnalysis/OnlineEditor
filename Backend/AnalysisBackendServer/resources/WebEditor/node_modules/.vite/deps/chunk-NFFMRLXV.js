import {
  ILogService,
  LRUCache,
  MovingAverage,
  Range,
  SlidingWindowAverage,
  URI,
  basename,
  clamp,
  compare,
  compareIgnoreCase,
  compareSubstring,
  compareSubstringIgnoreCase,
  createDecorator,
  doHash,
  localize,
  matchesScheme,
  registerSingleton
} from "./chunk-XW5MQKS3.js";

// node_modules/monaco-editor/esm/vs/platform/environment/common/environment.js
var IEnvironmentService = createDecorator("environmentService");

// node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ILanguageFeatureDebounceService = createDecorator("ILanguageFeatureDebounceService");
var IdentityHash;
(function(IdentityHash2) {
  const _hashes = /* @__PURE__ */ new WeakMap();
  let pool = 0;
  function of(obj) {
    let value = _hashes.get(obj);
    if (value === void 0) {
      value = ++pool;
      _hashes.set(obj, value);
    }
    return value;
  }
  IdentityHash2.of = of;
})(IdentityHash || (IdentityHash = {}));
var NullDebounceInformation = class {
  constructor(_default) {
    this._default = _default;
  }
  get(_model) {
    return this._default;
  }
  update(_model, _value) {
    return this._default;
  }
  default() {
    return this._default;
  }
};
var FeatureDebounceInformation = class {
  constructor(_logService, _name, _registry, _default, _min, _max) {
    this._logService = _logService;
    this._name = _name;
    this._registry = _registry;
    this._default = _default;
    this._min = _min;
    this._max = _max;
    this._cache = new LRUCache(50, 0.7);
  }
  _key(model) {
    return model.id + this._registry.all(model).reduce((hashVal, obj) => doHash(IdentityHash.of(obj), hashVal), 0);
  }
  get(model) {
    const key = this._key(model);
    const avg = this._cache.get(key);
    return avg ? clamp(avg.value, this._min, this._max) : this.default();
  }
  update(model, value) {
    const key = this._key(model);
    let avg = this._cache.get(key);
    if (!avg) {
      avg = new SlidingWindowAverage(6);
      this._cache.set(key, avg);
    }
    const newValue = clamp(avg.update(value), this._min, this._max);
    if (!matchesScheme(model.uri, "output")) {
      this._logService.trace(`[DEBOUNCE: ${this._name}] for ${model.uri.toString()} is ${newValue}ms`);
    }
    return newValue;
  }
  _overall() {
    const result = new MovingAverage();
    for (const [, avg] of this._cache) {
      result.update(avg.value);
    }
    return result.value;
  }
  default() {
    const value = this._overall() | 0 || this._default;
    return clamp(value, this._min, this._max);
  }
};
var LanguageFeatureDebounceService = class LanguageFeatureDebounceService2 {
  constructor(_logService, envService) {
    this._logService = _logService;
    this._data = /* @__PURE__ */ new Map();
    this._isDev = envService.isExtensionDevelopment || !envService.isBuilt;
  }
  for(feature, name, config) {
    var _a, _b, _c;
    const min = (_a = config === null || config === void 0 ? void 0 : config.min) !== null && _a !== void 0 ? _a : 50;
    const max = (_b = config === null || config === void 0 ? void 0 : config.max) !== null && _b !== void 0 ? _b : min ** 2;
    const extra = (_c = config === null || config === void 0 ? void 0 : config.key) !== null && _c !== void 0 ? _c : void 0;
    const key = `${IdentityHash.of(feature)},${min}${extra ? "," + extra : ""}`;
    let info = this._data.get(key);
    if (!info) {
      if (!this._isDev) {
        this._logService.debug(`[DEBOUNCE: ${name}] is disabled in developed mode`);
        info = new NullDebounceInformation(min * 1.5);
      } else {
        info = new FeatureDebounceInformation(
          this._logService,
          name,
          feature,
          this._overallAverage() | 0 || min * 1.5,
          // default is overall default or derived from min-value
          min,
          max
        );
      }
      this._data.set(key, info);
    }
    return info;
  }
  _overallAverage() {
    const result = new MovingAverage();
    for (const info of this._data.values()) {
      result.update(info.default());
    }
    return result.value;
  }
};
LanguageFeatureDebounceService = __decorate([
  __param(0, ILogService),
  __param(1, IEnvironmentService)
], LanguageFeatureDebounceService);
registerSingleton(
  ILanguageFeatureDebounceService,
  LanguageFeatureDebounceService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/common/services/editorWorker.js
var IEditorWorkerService = createDecorator("editorWorkerService");

// node_modules/monaco-editor/esm/vs/platform/audioCues/browser/audioCueService.js
var IAudioCueService = createDecorator("audioCue");
var Sound = class _Sound {
  static register(options) {
    const sound = new _Sound(options.fileName);
    return sound;
  }
  constructor(fileName) {
    this.fileName = fileName;
  }
};
Sound.error = Sound.register({ fileName: "error.mp3" });
Sound.warning = Sound.register({ fileName: "warning.mp3" });
Sound.foldedArea = Sound.register({ fileName: "foldedAreas.mp3" });
Sound.break = Sound.register({ fileName: "break.mp3" });
Sound.quickFixes = Sound.register({ fileName: "quickFixes.mp3" });
Sound.taskCompleted = Sound.register({ fileName: "taskCompleted.mp3" });
Sound.taskFailed = Sound.register({ fileName: "taskFailed.mp3" });
Sound.terminalBell = Sound.register({ fileName: "terminalBell.mp3" });
Sound.diffLineInserted = Sound.register({ fileName: "diffLineInserted.mp3" });
Sound.diffLineDeleted = Sound.register({ fileName: "diffLineDeleted.mp3" });
Sound.diffLineModified = Sound.register({ fileName: "diffLineModified.mp3" });
Sound.chatRequestSent = Sound.register({ fileName: "chatRequestSent.mp3" });
Sound.chatResponsePending = Sound.register({ fileName: "chatResponsePending.mp3" });
Sound.chatResponseReceived1 = Sound.register({ fileName: "chatResponseReceived1.mp3" });
Sound.chatResponseReceived2 = Sound.register({ fileName: "chatResponseReceived2.mp3" });
Sound.chatResponseReceived3 = Sound.register({ fileName: "chatResponseReceived3.mp3" });
Sound.chatResponseReceived4 = Sound.register({ fileName: "chatResponseReceived4.mp3" });
Sound.clear = Sound.register({ fileName: "clear.mp3" });
Sound.save = Sound.register({ fileName: "save.mp3" });
Sound.format = Sound.register({ fileName: "format.mp3" });
var SoundSource = class {
  constructor(randomOneOf) {
    this.randomOneOf = randomOneOf;
  }
};
var AudioCue = class _AudioCue {
  static register(options) {
    const soundSource = new SoundSource("randomOneOf" in options.sound ? options.sound.randomOneOf : [options.sound]);
    const audioCue = new _AudioCue(soundSource, options.name, options.settingsKey);
    _AudioCue._audioCues.add(audioCue);
    return audioCue;
  }
  constructor(sound, name, settingsKey) {
    this.sound = sound;
    this.name = name;
    this.settingsKey = settingsKey;
  }
};
AudioCue._audioCues = /* @__PURE__ */ new Set();
AudioCue.error = AudioCue.register({
  name: localize("audioCues.lineHasError.name", "Error on Line"),
  sound: Sound.error,
  settingsKey: "audioCues.lineHasError"
});
AudioCue.warning = AudioCue.register({
  name: localize("audioCues.lineHasWarning.name", "Warning on Line"),
  sound: Sound.warning,
  settingsKey: "audioCues.lineHasWarning"
});
AudioCue.foldedArea = AudioCue.register({
  name: localize("audioCues.lineHasFoldedArea.name", "Folded Area on Line"),
  sound: Sound.foldedArea,
  settingsKey: "audioCues.lineHasFoldedArea"
});
AudioCue.break = AudioCue.register({
  name: localize("audioCues.lineHasBreakpoint.name", "Breakpoint on Line"),
  sound: Sound.break,
  settingsKey: "audioCues.lineHasBreakpoint"
});
AudioCue.inlineSuggestion = AudioCue.register({
  name: localize("audioCues.lineHasInlineSuggestion.name", "Inline Suggestion on Line"),
  sound: Sound.quickFixes,
  settingsKey: "audioCues.lineHasInlineSuggestion"
});
AudioCue.terminalQuickFix = AudioCue.register({
  name: localize("audioCues.terminalQuickFix.name", "Terminal Quick Fix"),
  sound: Sound.quickFixes,
  settingsKey: "audioCues.terminalQuickFix"
});
AudioCue.onDebugBreak = AudioCue.register({
  name: localize("audioCues.onDebugBreak.name", "Debugger Stopped on Breakpoint"),
  sound: Sound.break,
  settingsKey: "audioCues.onDebugBreak"
});
AudioCue.noInlayHints = AudioCue.register({
  name: localize("audioCues.noInlayHints", "No Inlay Hints on Line"),
  sound: Sound.error,
  settingsKey: "audioCues.noInlayHints"
});
AudioCue.taskCompleted = AudioCue.register({
  name: localize("audioCues.taskCompleted", "Task Completed"),
  sound: Sound.taskCompleted,
  settingsKey: "audioCues.taskCompleted"
});
AudioCue.taskFailed = AudioCue.register({
  name: localize("audioCues.taskFailed", "Task Failed"),
  sound: Sound.taskFailed,
  settingsKey: "audioCues.taskFailed"
});
AudioCue.terminalCommandFailed = AudioCue.register({
  name: localize("audioCues.terminalCommandFailed", "Terminal Command Failed"),
  sound: Sound.error,
  settingsKey: "audioCues.terminalCommandFailed"
});
AudioCue.terminalBell = AudioCue.register({
  name: localize("audioCues.terminalBell", "Terminal Bell"),
  sound: Sound.terminalBell,
  settingsKey: "audioCues.terminalBell"
});
AudioCue.notebookCellCompleted = AudioCue.register({
  name: localize("audioCues.notebookCellCompleted", "Notebook Cell Completed"),
  sound: Sound.taskCompleted,
  settingsKey: "audioCues.notebookCellCompleted"
});
AudioCue.notebookCellFailed = AudioCue.register({
  name: localize("audioCues.notebookCellFailed", "Notebook Cell Failed"),
  sound: Sound.taskFailed,
  settingsKey: "audioCues.notebookCellFailed"
});
AudioCue.diffLineInserted = AudioCue.register({
  name: localize("audioCues.diffLineInserted", "Diff Line Inserted"),
  sound: Sound.diffLineInserted,
  settingsKey: "audioCues.diffLineInserted"
});
AudioCue.diffLineDeleted = AudioCue.register({
  name: localize("audioCues.diffLineDeleted", "Diff Line Deleted"),
  sound: Sound.diffLineDeleted,
  settingsKey: "audioCues.diffLineDeleted"
});
AudioCue.diffLineModified = AudioCue.register({
  name: localize("audioCues.diffLineModified", "Diff Line Modified"),
  sound: Sound.diffLineModified,
  settingsKey: "audioCues.diffLineModified"
});
AudioCue.chatRequestSent = AudioCue.register({
  name: localize("audioCues.chatRequestSent", "Chat Request Sent"),
  sound: Sound.chatRequestSent,
  settingsKey: "audioCues.chatRequestSent"
});
AudioCue.chatResponseReceived = AudioCue.register({
  name: localize("audioCues.chatResponseReceived", "Chat Response Received"),
  settingsKey: "audioCues.chatResponseReceived",
  sound: {
    randomOneOf: [
      Sound.chatResponseReceived1,
      Sound.chatResponseReceived2,
      Sound.chatResponseReceived3,
      Sound.chatResponseReceived4
    ]
  }
});
AudioCue.chatResponsePending = AudioCue.register({
  name: localize("audioCues.chatResponsePending", "Chat Response Pending"),
  sound: Sound.chatResponsePending,
  settingsKey: "audioCues.chatResponsePending"
});
AudioCue.clear = AudioCue.register({
  name: localize("audioCues.clear", "Clear"),
  sound: Sound.clear,
  settingsKey: "audioCues.clear"
});
AudioCue.save = AudioCue.register({
  name: localize("audioCues.save", "Save"),
  sound: Sound.save,
  settingsKey: "audioCues.save"
});
AudioCue.format = AudioCue.register({
  name: localize("audioCues.format", "Format"),
  sound: Sound.format,
  settingsKey: "audioCues.format"
});

// node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js
var EditOperation = class {
  static insert(position, text) {
    return {
      range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
      text,
      forceMoveMarkers: true
    };
  }
  static delete(range) {
    return {
      range,
      text: null
    };
  }
  static replace(range, text) {
    return {
      range,
      text
    };
  }
  static replaceMove(range, text) {
    return {
      range,
      text,
      forceMoveMarkers: true
    };
  }
};

// node_modules/monaco-editor/esm/vs/base/common/ternarySearchTree.js
var StringIterator = class {
  constructor() {
    this._value = "";
    this._pos = 0;
  }
  reset(key) {
    this._value = key;
    this._pos = 0;
    return this;
  }
  next() {
    this._pos += 1;
    return this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(a) {
    const aCode = a.charCodeAt(0);
    const thisCode = this._value.charCodeAt(this._pos);
    return aCode - thisCode;
  }
  value() {
    return this._value[this._pos];
  }
};
var ConfigKeysIterator = class {
  constructor(_caseSensitive = true) {
    this._caseSensitive = _caseSensitive;
  }
  reset(key) {
    this._value = key;
    this._from = 0;
    this._to = 0;
    return this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let justSeps = true;
    for (; this._to < this._value.length; this._to++) {
      const ch = this._value.charCodeAt(this._to);
      if (ch === 46) {
        if (justSeps) {
          this._from++;
        } else {
          break;
        }
      } else {
        justSeps = false;
      }
    }
    return this;
  }
  cmp(a) {
    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
};
var PathIterator = class {
  constructor(_splitOnBackslash = true, _caseSensitive = true) {
    this._splitOnBackslash = _splitOnBackslash;
    this._caseSensitive = _caseSensitive;
  }
  reset(key) {
    this._from = 0;
    this._to = 0;
    this._value = key;
    this._valueLen = key.length;
    for (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {
      const ch = this._value.charCodeAt(pos);
      if (!(ch === 47 || this._splitOnBackslash && ch === 92)) {
        break;
      }
    }
    return this.next();
  }
  hasNext() {
    return this._to < this._valueLen;
  }
  next() {
    this._from = this._to;
    let justSeps = true;
    for (; this._to < this._valueLen; this._to++) {
      const ch = this._value.charCodeAt(this._to);
      if (ch === 47 || this._splitOnBackslash && ch === 92) {
        if (justSeps) {
          this._from++;
        } else {
          break;
        }
      } else {
        justSeps = false;
      }
    }
    return this;
  }
  cmp(a) {
    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
};
var UriIterator = class {
  constructor(_ignorePathCasing, _ignoreQueryAndFragment) {
    this._ignorePathCasing = _ignorePathCasing;
    this._ignoreQueryAndFragment = _ignoreQueryAndFragment;
    this._states = [];
    this._stateIdx = 0;
  }
  reset(key) {
    this._value = key;
    this._states = [];
    if (this._value.scheme) {
      this._states.push(
        1
        /* UriIteratorState.Scheme */
      );
    }
    if (this._value.authority) {
      this._states.push(
        2
        /* UriIteratorState.Authority */
      );
    }
    if (this._value.path) {
      this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));
      this._pathIterator.reset(key.path);
      if (this._pathIterator.value()) {
        this._states.push(
          3
          /* UriIteratorState.Path */
        );
      }
    }
    if (!this._ignoreQueryAndFragment(key)) {
      if (this._value.query) {
        this._states.push(
          4
          /* UriIteratorState.Query */
        );
      }
      if (this._value.fragment) {
        this._states.push(
          5
          /* UriIteratorState.Fragment */
        );
      }
    }
    this._stateIdx = 0;
    return this;
  }
  next() {
    if (this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()) {
      this._pathIterator.next();
    } else {
      this._stateIdx += 1;
    }
    return this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(a) {
    if (this._states[this._stateIdx] === 1) {
      return compareIgnoreCase(a, this._value.scheme);
    } else if (this._states[this._stateIdx] === 2) {
      return compareIgnoreCase(a, this._value.authority);
    } else if (this._states[this._stateIdx] === 3) {
      return this._pathIterator.cmp(a);
    } else if (this._states[this._stateIdx] === 4) {
      return compare(a, this._value.query);
    } else if (this._states[this._stateIdx] === 5) {
      return compare(a, this._value.fragment);
    }
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1) {
      return this._value.scheme;
    } else if (this._states[this._stateIdx] === 2) {
      return this._value.authority;
    } else if (this._states[this._stateIdx] === 3) {
      return this._pathIterator.value();
    } else if (this._states[this._stateIdx] === 4) {
      return this._value.query;
    } else if (this._states[this._stateIdx] === 5) {
      return this._value.fragment;
    }
    throw new Error();
  }
};
var TernarySearchTreeNode = class {
  constructor() {
    this.height = 1;
  }
  rotateLeft() {
    const tmp = this.right;
    this.right = tmp.left;
    tmp.left = this;
    this.updateHeight();
    tmp.updateHeight();
    return tmp;
  }
  rotateRight() {
    const tmp = this.left;
    this.left = tmp.right;
    tmp.right = this;
    this.updateHeight();
    tmp.updateHeight();
    return tmp;
  }
  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }
  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }
  get heightLeft() {
    var _a, _b;
    return (_b = (_a = this.left) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
  }
  get heightRight() {
    var _a, _b;
    return (_b = (_a = this.right) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
  }
};
var TernarySearchTree = class _TernarySearchTree {
  static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {
    return new _TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));
  }
  static forStrings() {
    return new _TernarySearchTree(new StringIterator());
  }
  static forConfigKeys() {
    return new _TernarySearchTree(new ConfigKeysIterator());
  }
  constructor(segments) {
    this._iter = segments;
  }
  clear() {
    this._root = void 0;
  }
  set(key, element) {
    const iter = this._iter.reset(key);
    let node;
    if (!this._root) {
      this._root = new TernarySearchTreeNode();
      this._root.segment = iter.value();
    }
    const stack = [];
    node = this._root;
    while (true) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        if (!node.left) {
          node.left = new TernarySearchTreeNode();
          node.left.segment = iter.value();
        }
        stack.push([-1, node]);
        node = node.left;
      } else if (val < 0) {
        if (!node.right) {
          node.right = new TernarySearchTreeNode();
          node.right.segment = iter.value();
        }
        stack.push([1, node]);
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        if (!node.mid) {
          node.mid = new TernarySearchTreeNode();
          node.mid.segment = iter.value();
        }
        stack.push([0, node]);
        node = node.mid;
      } else {
        break;
      }
    }
    const oldElement = node.value;
    node.value = element;
    node.key = key;
    for (let i = stack.length - 1; i >= 0; i--) {
      const node2 = stack[i][1];
      node2.updateHeight();
      const bf = node2.balanceFactor();
      if (bf < -1 || bf > 1) {
        const d1 = stack[i][0];
        const d2 = stack[i + 1][0];
        if (d1 === 1 && d2 === 1) {
          stack[i][1] = node2.rotateLeft();
        } else if (d1 === -1 && d2 === -1) {
          stack[i][1] = node2.rotateRight();
        } else if (d1 === 1 && d2 === -1) {
          node2.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();
          stack[i][1] = node2.rotateLeft();
        } else if (d1 === -1 && d2 === 1) {
          node2.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();
          stack[i][1] = node2.rotateRight();
        } else {
          throw new Error();
        }
        if (i > 0) {
          switch (stack[i - 1][0]) {
            case -1:
              stack[i - 1][1].left = stack[i][1];
              break;
            case 1:
              stack[i - 1][1].right = stack[i][1];
              break;
            case 0:
              stack[i - 1][1].mid = stack[i][1];
              break;
          }
        } else {
          this._root = stack[0][1];
        }
      }
    }
    return oldElement;
  }
  get(key) {
    var _a;
    return (_a = this._getNode(key)) === null || _a === void 0 ? void 0 : _a.value;
  }
  _getNode(key) {
    const iter = this._iter.reset(key);
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        node = node.mid;
      } else {
        break;
      }
    }
    return node;
  }
  has(key) {
    const node = this._getNode(key);
    return !((node === null || node === void 0 ? void 0 : node.value) === void 0 && (node === null || node === void 0 ? void 0 : node.mid) === void 0);
  }
  delete(key) {
    return this._delete(key, false);
  }
  deleteSuperstr(key) {
    return this._delete(key, true);
  }
  _delete(key, superStr) {
    var _a;
    const iter = this._iter.reset(key);
    const stack = [];
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        stack.push([-1, node]);
        node = node.left;
      } else if (val < 0) {
        stack.push([1, node]);
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        stack.push([0, node]);
        node = node.mid;
      } else {
        break;
      }
    }
    if (!node) {
      return;
    }
    if (superStr) {
      node.left = void 0;
      node.mid = void 0;
      node.right = void 0;
      node.height = 1;
    } else {
      node.key = void 0;
      node.value = void 0;
    }
    if (!node.mid && !node.value) {
      if (node.left && node.right) {
        const min = this._min(node.right);
        if (min.key) {
          const { key: key2, value, segment } = min;
          this._delete(min.key, false);
          node.key = key2;
          node.value = value;
          node.segment = segment;
        }
      } else {
        const newChild = (_a = node.left) !== null && _a !== void 0 ? _a : node.right;
        if (stack.length > 0) {
          const [dir, parent] = stack[stack.length - 1];
          switch (dir) {
            case -1:
              parent.left = newChild;
              break;
            case 0:
              parent.mid = newChild;
              break;
            case 1:
              parent.right = newChild;
              break;
          }
        } else {
          this._root = newChild;
        }
      }
    }
    for (let i = stack.length - 1; i >= 0; i--) {
      const node2 = stack[i][1];
      node2.updateHeight();
      const bf = node2.balanceFactor();
      if (bf > 1) {
        if (node2.right.balanceFactor() >= 0) {
          stack[i][1] = node2.rotateLeft();
        } else {
          node2.right = node2.right.rotateRight();
          stack[i][1] = node2.rotateLeft();
        }
      } else if (bf < -1) {
        if (node2.left.balanceFactor() <= 0) {
          stack[i][1] = node2.rotateRight();
        } else {
          node2.left = node2.left.rotateLeft();
          stack[i][1] = node2.rotateRight();
        }
      }
      if (i > 0) {
        switch (stack[i - 1][0]) {
          case -1:
            stack[i - 1][1].left = stack[i][1];
            break;
          case 1:
            stack[i - 1][1].right = stack[i][1];
            break;
          case 0:
            stack[i - 1][1].mid = stack[i][1];
            break;
        }
      } else {
        this._root = stack[0][1];
      }
    }
  }
  _min(node) {
    while (node.left) {
      node = node.left;
    }
    return node;
  }
  findSubstr(key) {
    const iter = this._iter.reset(key);
    let node = this._root;
    let candidate = void 0;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        candidate = node.value || candidate;
        node = node.mid;
      } else {
        break;
      }
    }
    return node && node.value || candidate;
  }
  findSuperstr(key) {
    return this._findSuperstrOrElement(key, false);
  }
  _findSuperstrOrElement(key, allowValue) {
    const iter = this._iter.reset(key);
    let node = this._root;
    while (node) {
      const val = iter.cmp(node.segment);
      if (val > 0) {
        node = node.left;
      } else if (val < 0) {
        node = node.right;
      } else if (iter.hasNext()) {
        iter.next();
        node = node.mid;
      } else {
        if (!node.mid) {
          if (allowValue) {
            return node.value;
          } else {
            return void 0;
          }
        } else {
          return this._entries(node.mid);
        }
      }
    }
    return void 0;
  }
  forEach(callback) {
    for (const [key, value] of this) {
      callback(value, key);
    }
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  _entries(node) {
    const result = [];
    this._dfsEntries(node, result);
    return result[Symbol.iterator]();
  }
  _dfsEntries(node, bucket) {
    if (!node) {
      return;
    }
    if (node.left) {
      this._dfsEntries(node.left, bucket);
    }
    if (node.value) {
      bucket.push([node.key, node.value]);
    }
    if (node.mid) {
      this._dfsEntries(node.mid, bucket);
    }
    if (node.right) {
      this._dfsEntries(node.right, bucket);
    }
  }
};

// node_modules/monaco-editor/esm/vs/platform/workspace/common/workspace.js
var IWorkspaceContextService = createDecorator("contextService");
function isSingleFolderWorkspaceIdentifier(obj) {
  const singleFolderIdentifier = obj;
  return typeof (singleFolderIdentifier === null || singleFolderIdentifier === void 0 ? void 0 : singleFolderIdentifier.id) === "string" && URI.isUri(singleFolderIdentifier.uri);
}
function isEmptyWorkspaceIdentifier(obj) {
  const emptyWorkspaceIdentifier = obj;
  return typeof (emptyWorkspaceIdentifier === null || emptyWorkspaceIdentifier === void 0 ? void 0 : emptyWorkspaceIdentifier.id) === "string" && !isSingleFolderWorkspaceIdentifier(obj) && !isWorkspaceIdentifier(obj);
}
var EXTENSION_DEVELOPMENT_EMPTY_WINDOW_WORKSPACE = { id: "ext-dev" };
var UNKNOWN_EMPTY_WINDOW_WORKSPACE = { id: "empty-window" };
function toWorkspaceIdentifier(arg0, isExtensionDevelopment) {
  if (typeof arg0 === "string" || typeof arg0 === "undefined") {
    if (typeof arg0 === "string") {
      return {
        id: basename(arg0)
      };
    }
    if (isExtensionDevelopment) {
      return EXTENSION_DEVELOPMENT_EMPTY_WINDOW_WORKSPACE;
    }
    return UNKNOWN_EMPTY_WINDOW_WORKSPACE;
  }
  const workspace = arg0;
  if (workspace.configuration) {
    return {
      id: workspace.id,
      configPath: workspace.configuration
    };
  }
  if (workspace.folders.length === 1) {
    return {
      id: workspace.id,
      uri: workspace.folders[0].uri
    };
  }
  return {
    id: workspace.id
  };
}
function isWorkspaceIdentifier(obj) {
  const workspaceIdentifier = obj;
  return typeof (workspaceIdentifier === null || workspaceIdentifier === void 0 ? void 0 : workspaceIdentifier.id) === "string" && URI.isUri(workspaceIdentifier.configPath);
}
var WorkspaceFolder = class {
  constructor(data, raw) {
    this.raw = raw;
    this.uri = data.uri;
    this.index = data.index;
    this.name = data.name;
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
};
var WORKSPACE_EXTENSION = "code-workspace";
var WORKSPACE_FILTER = [{ name: localize("codeWorkspace", "Code Workspace"), extensions: [WORKSPACE_EXTENSION] }];
var STANDALONE_EDITOR_WORKSPACE_ID = "4064f6ec-cb38-4ad0-af64-ee6467e63c82";

// node_modules/monaco-editor/esm/vs/editor/browser/stableEditorScroll.js
var StableEditorScrollState = class _StableEditorScrollState {
  static capture(editor) {
    if (editor.getScrollTop() === 0 || editor.hasPendingScrollAnimation()) {
      return new _StableEditorScrollState(editor.getScrollTop(), editor.getContentHeight(), null, 0, null);
    }
    let visiblePosition = null;
    let visiblePositionScrollDelta = 0;
    const visibleRanges = editor.getVisibleRanges();
    if (visibleRanges.length > 0) {
      visiblePosition = visibleRanges[0].getStartPosition();
      const visiblePositionScrollTop = editor.getTopForPosition(visiblePosition.lineNumber, visiblePosition.column);
      visiblePositionScrollDelta = editor.getScrollTop() - visiblePositionScrollTop;
    }
    return new _StableEditorScrollState(editor.getScrollTop(), editor.getContentHeight(), visiblePosition, visiblePositionScrollDelta, editor.getPosition());
  }
  constructor(_initialScrollTop, _initialContentHeight, _visiblePosition, _visiblePositionScrollDelta, _cursorPosition) {
    this._initialScrollTop = _initialScrollTop;
    this._initialContentHeight = _initialContentHeight;
    this._visiblePosition = _visiblePosition;
    this._visiblePositionScrollDelta = _visiblePositionScrollDelta;
    this._cursorPosition = _cursorPosition;
  }
  restore(editor) {
    if (this._initialContentHeight === editor.getContentHeight() && this._initialScrollTop === editor.getScrollTop()) {
      return;
    }
    if (this._visiblePosition) {
      const visiblePositionScrollTop = editor.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
      editor.setScrollTop(visiblePositionScrollTop + this._visiblePositionScrollDelta);
    }
  }
  restoreRelativeVerticalPositionOfCursor(editor) {
    if (this._initialContentHeight === editor.getContentHeight() && this._initialScrollTop === editor.getScrollTop()) {
      return;
    }
    const currentCursorPosition = editor.getPosition();
    if (!this._cursorPosition || !currentCursorPosition) {
      return;
    }
    const offset = editor.getTopForLineNumber(currentCursorPosition.lineNumber) - editor.getTopForLineNumber(this._cursorPosition.lineNumber);
    editor.setScrollTop(editor.getScrollTop() + offset);
  }
};

// node_modules/monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js
var IClipboardService = createDecorator("clipboardService");

export {
  IEnvironmentService,
  ILanguageFeatureDebounceService,
  EditOperation,
  TernarySearchTree,
  IWorkspaceContextService,
  isSingleFolderWorkspaceIdentifier,
  isEmptyWorkspaceIdentifier,
  toWorkspaceIdentifier,
  WorkspaceFolder,
  WORKSPACE_EXTENSION,
  STANDALONE_EDITOR_WORKSPACE_ID,
  StableEditorScrollState,
  IEditorWorkerService,
  IClipboardService,
  IAudioCueService,
  AudioCue
};
//# sourceMappingURL=chunk-NFFMRLXV.js.map
